// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"gAoaA":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "b3c595598cfc62b9";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"6rimH":[function(require,module,exports) {
var _db = require("./js/db");
var _dom = require("./js/DOM");
var _displayMenu = require("./js/displayMenu");
var _getCategory = require("./js/getCategory");
var _showPopular = require("./js/showPopular");
var _ui = require("./js/UI");
var _showVideo = require("./js/showVideo");
var _addComponents = require("./js/addComponents");
const fs = require("3c1f68bd45acd878");
const pug = require("15814f4fa89c337f");
document.addEventListener("DOMContentLoaded", async ()=>{
    pug.renderFile("index.pug");
    (0, _displayMenu.displayMenu).createCard((0, _db.menuItems), (0, _dom.containerMenu));
});
if (0, _dom.popularMenu) document.addEventListener("DOMContentLoaded", ()=>{
    const popular = (0, _showPopular.dispayPopular).showPopular((0, _db.menuItems));
    (0, _displayMenu.displayMenu).createCard(popular, (0, _dom.popularMenu));
});
if (0, _dom.containerCategories) (0, _dom.containerCategories).addEventListener("click", (e)=>{
    e.preventDefault();
    const target = e.target;
    (0, _ui.changeStyle).changeOpacity(target, (0, _dom.categories));
    if (target.classList.contains("all")) (0, _displayMenu.displayMenu).createCard((0, _db.menuItems), (0, _dom.containerMenu));
    if (!target.classList.contains("all")) {
        const filteredCategories = (0, _getCategory.filteredByCategory).getCategory(target, (0, _db.menuItems));
        (0, _displayMenu.displayMenu).createCard(filteredCategories, (0, _dom.containerMenu));
    }
    if (!target.classList.contains("menu__category")) {
        console.log("stop");
        e.stopPropagation();
    }
});
(0, _dom.videoLink).addEventListener("click", (e)=>{
    e.preventDefault();
    (0, _showVideo.showVideo)((0, _dom.videoLink), (0, _dom.videoIframe), (0, _dom.popupOverlay));
});
if (0, _dom.popupOverlay) (0, _dom.popupOverlay).addEventListener("click", ()=>{
    (0, _dom.videoIframe).src = "";
    (0, _dom.popupOverlay).style.display = "none";
});

},{"./js/db":"8KMOv","./js/DOM":"EyUfz","./js/displayMenu":"56QUq","./js/getCategory":"ckc80","./js/showPopular":"6XmZc","./js/UI":"8BZ1U","./js/showVideo":"3RVsW","./js/addComponents":"aIHmm","3c1f68bd45acd878":"jhUEF","15814f4fa89c337f":"3LI4E"}],"8KMOv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "menuItems", ()=>menuItems);
const menuItems = [
    {
        "id": 1,
        "category": "coffee",
        "img": "/menu1.jpg",
        "name": "Drp Coffee",
        "price": 8.85
    },
    {
        "id": 2,
        "status": "popular",
        "category": "cake",
        "img": "/menu-2.801dc673.jpg",
        "name": "Choco Cup Cake",
        "price": 4.85
    },
    {
        "id": 3,
        "status": "popular",
        "category": "fastFood",
        "img": "/menu3.jpg",
        "name": "Chicken Burger",
        "price": 8.85
    },
    {
        "id": 4,
        "category": "snack",
        "img": "/menu4.jpg",
        "name": "French Fries",
        "price": 7.85
    },
    {
        "id": 5,
        "category": "fastFood",
        "img": "/menu5.jpg",
        "name": "Sandwitch",
        "price": 3.97
    },
    {
        "id": 6,
        "category": "fastFood",
        "img": "/menu6.jpg",
        "name": "Chinese Soup",
        "price": 8.85
    },
    {
        "id": 7,
        "category": "cake",
        "img": "/menu7.jpg",
        "name": "Quafe Brade",
        "price": 7.85
    },
    {
        "id": 8,
        "category": "coffee",
        "img": "/menu8.ca3800b4.jpg",
        "name": "Dalgona Cofee",
        "price": 4.97
    },
    {
        "id": 9,
        "status": "popular",
        "category": "fastFood",
        "img": "/menu9.296a6c30.jpg",
        "name": "Chowmin Noodle",
        "price": 8.85
    },
    {
        "id": 10,
        "category": "cocktails",
        "img": "/menu10.8aa0ed4c.jpg",
        "name": "Coka Cola",
        "price": 7.85
    },
    {
        "id": 11,
        "category": "fastFood",
        "img": "/menu11.79efdf3c.jpg",
        "name": "Fruit Salad",
        "price": 3.97
    },
    {
        "id": 12,
        "category": "cocktails",
        "img": "/menu12.de0af5f2.jpg",
        "name": "Coctail",
        "price": 4.97
    },
    {
        "id": 13,
        "status": "popular",
        "category": "cake",
        "img": "/menu13.0b8a64a0.jpg",
        "name": "Cheesecake",
        "price": 6.97
    },
    {
        "id": 14,
        "category": "cocktails",
        "img": "/menu14.3dcc2ce0.jpg",
        "name": "Margarita",
        "price": 8.97
    },
    {
        "id": 15,
        "category": "snack",
        "img": "/menu15.f0ec8bb1.jpg",
        "name": "Nuts",
        "price": 7.97
    },
    {
        "id": 16,
        "status": "popular",
        "category": "coffee",
        "img": "/menu16.a46bed60.jpg",
        "name": "Ice Coffee",
        "price": 8.85
    },
    {
        "id": 17,
        "category": "cake",
        "img": "/menu17.645170b0.jpg",
        "name": "Kiev cake",
        "price": 6.97
    },
    {
        "id": 18,
        "status": "popular",
        "category": "cocktails",
        "img": "/menu18.1b64b339.jpg",
        "name": "Tropicana",
        "price": 8.97
    },
    {
        "id": 19,
        "category": "cake",
        "img": "/menu19.f1efddcb.jpg",
        "name": "Honey Moon",
        "price": 7.97
    },
    {
        "id": 20,
        "category": "coffee",
        "img": "/menu20.235e2f08.jpg",
        "name": "Flat White",
        "price": 8.85
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"EyUfz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "headerContainer", ()=>headerContainer);
parcelHelpers.export(exports, "footerContainer", ()=>footerContainer);
parcelHelpers.export(exports, "containerMenu", ()=>containerMenu);
parcelHelpers.export(exports, "popularMenu", ()=>popularMenu);
parcelHelpers.export(exports, "containerCategories", ()=>containerCategories);
parcelHelpers.export(exports, "categories", ()=>categories);
parcelHelpers.export(exports, "videoLink", ()=>videoLink);
parcelHelpers.export(exports, "popupOverlay", ()=>popupOverlay);
parcelHelpers.export(exports, "videoIframe", ()=>videoIframe);
const headerContainer = document.getElementById("header-container"), footerContainer = document.getElementById("footer-container"), containerMenu = document.querySelector(".menu__grid"), popularMenu = document.getElementById("menu__popular"), containerCategories = document.querySelector(".menu__categories"), categories = document.querySelectorAll(".menu__category"), videoLink = document.querySelector(".video-link"), popupOverlay = document.querySelector(".popup-overlay"), videoIframe = document.querySelector(".video-iframe");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"56QUq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "displayMenu", ()=>displayMenu);
class Menu {
    createCard(data, selector) {
        selector.innerHTML = "";
        data.forEach((el)=>{
            return selector.innerHTML += `
        <div data-aos="zoom-in" class="menu__item"  id=${el.id} data-category=${el.category}>
                <div class="menu__img image-container">
                    <img src="${el.img}" alt="${el.name}">
                </div>
                <div class="menu__price">
                    <h6 class="heading-small name">${el.name}</h6>
                    <p class="price">${el.price}</p>
                </div>
            </div>
        `;
        });
    }
}
let displayMenu = new Menu();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ckc80":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filteredByCategory", ()=>filteredByCategory);
class Category {
    getCategory(target, data) {
        if (target) {
            let type = target.getAttribute("data-category");
            const filtred = data.filter((el)=>{
                return el.category === type;
            });
            return filtred;
        }
    }
}
let filteredByCategory = new Category();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6XmZc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dispayPopular", ()=>dispayPopular);
class Popular {
    showPopular(data) {
        const findPopular = data.filter((el)=>el.status === "popular");
        return findPopular;
    }
}
let dispayPopular = new Popular();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8BZ1U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "changeStyle", ()=>changeStyle);
class UI {
    changeOpacity(target, array) {
        array.forEach((inactive)=>inactive.style.opacity = 0.7);
        target.style.opacity = 1;
    }
}
let changeStyle = new UI();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3RVsW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showVideo", ()=>showVideo);
const showVideo = (link, frame, overlay)=>{
    const videoId = link.getAttribute("data-video-id");
    const videoUrl = `https://www.youtube.com/embed/${videoId}?rel=0&amp;autoplay=1`;
    frame.src = videoUrl;
    overlay.style.display = "block";
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aIHmm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadHeaderAndFooter", ()=>loadHeaderAndFooter) //index\components\footer.html
;
async function loadHeaderAndFooter(component, container) {
    // fetch(component)
    //   .then(response => response.text())
    //   .then(data => {
    //     document.getElementById(container).innerHTML = data;
    //   });
    const componentResponse = await fetch(component);
    const containerHtml = await componentResponse.text();
    document.getElementById(container).innerHTML = containerHtml;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"3LI4E":[function(require,module,exports) {
var Buffer = require("234f883d9c27cf7c").Buffer;
"use strict";
/*!
 * Pug
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */ /**
 * Module dependencies.
 */ var fs = require("7b015c46d7e0c055");
var path = require("3a5978461e63c0a1");
var lex = require("99d4b13c0809f5fb");
var stripComments = require("359d0bda360deb76");
var parse = require("bf9cfb915bfb1f68");
var load = require("46f00fe0827425b5");
var filters = require("627f9bdacb35c6b2");
var link = require("5a368fb28bbe73e6");
var generateCode = require("2cc7afb7bc5895e1");
var runtime = require("c160a74c18313b00");
var runtimeWrap = require("97640e37413b27dc");
/**
 * Name for detection
 */ exports.name = "Pug";
/**
 * Pug runtime helpers.
 */ exports.runtime = runtime;
/**
 * Template function cache.
 */ exports.cache = {};
function applyPlugins(value, options, plugins, name) {
    return plugins.reduce(function(value, plugin) {
        return plugin[name] ? plugin[name](value, options) : value;
    }, value);
}
function findReplacementFunc(plugins, name) {
    var eligiblePlugins = plugins.filter(function(plugin) {
        return plugin[name];
    });
    if (eligiblePlugins.length > 1) throw new Error("Two or more plugins all implement " + name + " method.");
    else if (eligiblePlugins.length) return eligiblePlugins[0][name].bind(eligiblePlugins[0]);
    return null;
}
/**
 * Object for global custom filters.  Note that you can also just pass a `filters`
 * option to any other method.
 */ exports.filters = {};
/**
 * Compile the given `str` of pug and return a function body.
 *
 * @param {String} str
 * @param {Object} options
 * @return {Object}
 * @api private
 */ function compileBody(str, options) {
    var debug_sources = {};
    debug_sources[options.filename] = str;
    var dependencies = [];
    var plugins = options.plugins || [];
    var ast = load.string(str, {
        filename: options.filename,
        basedir: options.basedir,
        lex: function(str, options) {
            var lexOptions = {};
            Object.keys(options).forEach(function(key) {
                lexOptions[key] = options[key];
            });
            lexOptions.plugins = plugins.filter(function(plugin) {
                return !!plugin.lex;
            }).map(function(plugin) {
                return plugin.lex;
            });
            var contents = applyPlugins(str, {
                filename: options.filename
            }, plugins, "preLex");
            return applyPlugins(lex(contents, lexOptions), options, plugins, "postLex");
        },
        parse: function(tokens, options) {
            tokens = tokens.map(function(token) {
                if (token.type === "path" && path.extname(token.val) === "") return {
                    type: "path",
                    loc: token.loc,
                    val: token.val + ".pug"
                };
                return token;
            });
            tokens = stripComments(tokens, options);
            tokens = applyPlugins(tokens, options, plugins, "preParse");
            var parseOptions = {};
            Object.keys(options).forEach(function(key) {
                parseOptions[key] = options[key];
            });
            parseOptions.plugins = plugins.filter(function(plugin) {
                return !!plugin.parse;
            }).map(function(plugin) {
                return plugin.parse;
            });
            return applyPlugins(applyPlugins(parse(tokens, parseOptions), options, plugins, "postParse"), options, plugins, "preLoad");
        },
        resolve: function(filename, source, loadOptions) {
            var replacementFunc = findReplacementFunc(plugins, "resolve");
            if (replacementFunc) return replacementFunc(filename, source, options);
            return load.resolve(filename, source, loadOptions);
        },
        read: function(filename, loadOptions) {
            dependencies.push(filename);
            var contents;
            var replacementFunc = findReplacementFunc(plugins, "read");
            if (replacementFunc) contents = replacementFunc(filename, options);
            else contents = load.read(filename, loadOptions);
            debug_sources[filename] = Buffer.isBuffer(contents) ? contents.toString("utf8") : contents;
            return contents;
        }
    });
    ast = applyPlugins(ast, options, plugins, "postLoad");
    ast = applyPlugins(ast, options, plugins, "preFilters");
    var filtersSet = {};
    Object.keys(exports.filters).forEach(function(key) {
        filtersSet[key] = exports.filters[key];
    });
    if (options.filters) Object.keys(options.filters).forEach(function(key) {
        filtersSet[key] = options.filters[key];
    });
    ast = filters.handleFilters(ast, filtersSet, options.filterOptions, options.filterAliases);
    ast = applyPlugins(ast, options, plugins, "postFilters");
    ast = applyPlugins(ast, options, plugins, "preLink");
    ast = link(ast);
    ast = applyPlugins(ast, options, plugins, "postLink");
    // Compile
    ast = applyPlugins(ast, options, plugins, "preCodeGen");
    var js = (findReplacementFunc(plugins, "generateCode") || generateCode)(ast, {
        pretty: options.pretty,
        compileDebug: options.compileDebug,
        doctype: options.doctype,
        inlineRuntimeFunctions: options.inlineRuntimeFunctions,
        globals: options.globals,
        self: options.self,
        includeSources: options.includeSources ? debug_sources : false,
        templateName: options.templateName
    });
    js = applyPlugins(js, options, plugins, "postCodeGen");
    // Debug compiler
    if (options.debug) console.error("\nCompiled Function:\n\n\x1b[90m%s\x1b[0m", js.replace(/^/gm, "  "));
    return {
        body: js,
        dependencies: dependencies
    };
}
/**
 * Get the template from a string or a file, either compiled on-the-fly or
 * read from cache (if enabled), and cache the template if needed.
 *
 * If `str` is not set, the file specified in `options.filename` will be read.
 *
 * If `options.cache` is true, this function reads the file from
 * `options.filename` so it must be set prior to calling this function.
 *
 * @param {Object} options
 * @param {String=} str
 * @return {Function}
 * @api private
 */ function handleTemplateCache(options, str) {
    var key = options.filename;
    if (options.cache && exports.cache[key]) return exports.cache[key];
    else {
        if (str === undefined) str = fs.readFileSync(options.filename, "utf8");
        var templ = exports.compile(str, options);
        if (options.cache) exports.cache[key] = templ;
        return templ;
    }
}
/**
 * Compile a `Function` representation of the given pug `str`.
 *
 * Options:
 *
 *   - `compileDebug` when `false` debugging code is stripped from the compiled
       template, when it is explicitly `true`, the source code is included in
       the compiled template for better accuracy.
 *   - `filename` used to improve errors when `compileDebug` is not `false` and to resolve imports/extends
 *
 * @param {String} str
 * @param {Options} options
 * @return {Function}
 * @api public
 */ exports.compile = function(str, options) {
    var options = options || {};
    str = String(str);
    var parsed = compileBody(str, {
        compileDebug: options.compileDebug !== false,
        filename: options.filename,
        basedir: options.basedir,
        pretty: options.pretty,
        doctype: options.doctype,
        inlineRuntimeFunctions: options.inlineRuntimeFunctions,
        globals: options.globals,
        self: options.self,
        includeSources: options.compileDebug === true,
        debug: options.debug,
        templateName: "template",
        filters: options.filters,
        filterOptions: options.filterOptions,
        filterAliases: options.filterAliases,
        plugins: options.plugins
    });
    var res = options.inlineRuntimeFunctions ? new Function("", parsed.body + ";return template;")() : runtimeWrap(parsed.body);
    res.dependencies = parsed.dependencies;
    return res;
};
/**
 * Compile a JavaScript source representation of the given pug `str`.
 *
 * Options:
 *
 *   - `compileDebug` When it is `true`, the source code is included in
 *     the compiled template for better error messages.
 *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
 *   - `name` the name of the resulting function (defaults to "template")
 *   - `module` when it is explicitly `true`, the source code include export module syntax
 *
 * @param {String} str
 * @param {Options} options
 * @return {Object}
 * @api public
 */ exports.compileClientWithDependenciesTracked = function(str, options) {
    var options = options || {};
    str = String(str);
    var parsed = compileBody(str, {
        compileDebug: options.compileDebug,
        filename: options.filename,
        basedir: options.basedir,
        pretty: options.pretty,
        doctype: options.doctype,
        inlineRuntimeFunctions: options.inlineRuntimeFunctions !== false,
        globals: options.globals,
        self: options.self,
        includeSources: options.compileDebug,
        debug: options.debug,
        templateName: options.name || "template",
        filters: options.filters,
        filterOptions: options.filterOptions,
        filterAliases: options.filterAliases,
        plugins: options.plugins
    });
    var body = parsed.body;
    if (options.module) {
        if (options.inlineRuntimeFunctions === false) body = 'var pug = require("pug-runtime");' + body;
        body += " module.exports = " + (options.name || "template") + ";";
    }
    return {
        body: body,
        dependencies: parsed.dependencies
    };
};
/**
 * Compile a JavaScript source representation of the given pug `str`.
 *
 * Options:
 *
 *   - `compileDebug` When it is `true`, the source code is included in
 *     the compiled template for better error messages.
 *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
 *   - `name` the name of the resulting function (defaults to "template")
 *
 * @param {String} str
 * @param {Options} options
 * @return {String}
 * @api public
 */ exports.compileClient = function(str, options) {
    return exports.compileClientWithDependenciesTracked(str, options).body;
};
/**
 * Compile a `Function` representation of the given pug file.
 *
 * Options:
 *
 *   - `compileDebug` when `false` debugging code is stripped from the compiled
       template, when it is explicitly `true`, the source code is included in
       the compiled template for better accuracy.
 *
 * @param {String} path
 * @param {Options} options
 * @return {Function}
 * @api public
 */ exports.compileFile = function(path, options) {
    options = options || {};
    options.filename = path;
    return handleTemplateCache(options);
};
/**
 * Render the given `str` of pug.
 *
 * Options:
 *
 *   - `cache` enable template caching
 *   - `filename` filename required for `include` / `extends` and caching
 *
 * @param {String} str
 * @param {Object|Function} options or fn
 * @param {Function|undefined} fn
 * @returns {String}
 * @api public
 */ exports.render = function(str, options, fn) {
    // support callback API
    if ("function" == typeof options) fn = options, options = undefined;
    if (typeof fn === "function") {
        var res;
        try {
            res = exports.render(str, options);
        } catch (ex) {
            return fn(ex);
        }
        return fn(null, res);
    }
    options = options || {};
    // cache requires .filename
    if (options.cache && !options.filename) throw new Error('the "filename" option is required for caching');
    return handleTemplateCache(options, str)(options);
};
/**
 * Render a Pug file at the given `path`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function|undefined} fn
 * @returns {String}
 * @api public
 */ exports.renderFile = function(path, options, fn) {
    // support callback API
    if ("function" == typeof options) fn = options, options = undefined;
    if (typeof fn === "function") {
        var res;
        try {
            res = exports.renderFile(path, options);
        } catch (ex) {
            return fn(ex);
        }
        return fn(null, res);
    }
    options = options || {};
    options.filename = path;
    return handleTemplateCache(options)(options);
};
/**
 * Compile a Pug file at the given `path` for use on the client.
 *
 * @param {String} path
 * @param {Object} options
 * @returns {String}
 * @api public
 */ exports.compileFileClient = function(path, options) {
    var key = path + ":client";
    options = options || {};
    options.filename = path;
    if (options.cache && exports.cache[key]) return exports.cache[key];
    var str = fs.readFileSync(options.filename, "utf8");
    var out = exports.compileClient(str, options);
    if (options.cache) exports.cache[key] = out;
    return out;
};
/**
 * Express support.
 */ exports.__express = function(path, options, fn) {
    options.compileDebug;
    exports.renderFile(path, options, fn);
};

},{"234f883d9c27cf7c":"fCgem","7b015c46d7e0c055":"jhUEF","3a5978461e63c0a1":"loE3o","99d4b13c0809f5fb":"kK6CL","359d0bda360deb76":"lywdA","bf9cfb915bfb1f68":"bqIvf","46f00fe0827425b5":"orJQ9","627f9bdacb35c6b2":"4Tb6B","5a368fb28bbe73e6":"74FvY","2cc7afb7bc5895e1":"ksxv5","c160a74c18313b00":"bDby4","97640e37413b27dc":"6dUxV"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"loE3o":[function(require,module,exports) {
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var process = require("c0743715070b1b8a");
"use strict";
function assertPath(path) {
    if (typeof path !== "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
}
// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for(var i = 0; i <= path.length; ++i){
        if (i < path.length) code = path.charCodeAt(i);
        else if (code === 47 /*/*/ ) break;
        else code = 47 /*/*/ ;
        if (code === 47 /*/*/ ) {
            if (lastSlash === i - 1 || dots === 1) ;
            else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/  || res.charCodeAt(res.length - 2) !== 46 /*.*/ ) {
                    if (res.length > 2) {
                        var lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            } else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += "/..";
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += "/" + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 /*.*/  && dots !== -1) ++dots;
        else dots = -1;
    }
    return res;
}
function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){
            var path;
            if (i >= 0) path = arguments[i];
            else {
                if (cwd === undefined) cwd = process.cwd();
                path = cwd;
            }
            assertPath(path);
            // Skip empty entries
            if (path.length === 0) continue;
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0) return "/" + resolvedPath;
            else return "/";
        } else if (resolvedPath.length > 0) return resolvedPath;
        else return ".";
    },
    normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var isAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/ ;
        // Normalize the path
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = ".";
        if (path.length > 0 && trailingSeparator) path += "/";
        if (isAbsolute) return "/" + path;
        return path;
    },
    isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47 /*/*/ ;
    },
    join: function join() {
        if (arguments.length === 0) return ".";
        var joined;
        for(var i = 0; i < arguments.length; ++i){
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
                if (joined === undefined) joined = arg;
                else joined += "/" + arg;
            }
        }
        if (joined === undefined) return ".";
        return posix.normalize(joined);
    },
    relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        // Trim any leading backslashes
        var fromStart = 1;
        for(; fromStart < from.length; ++fromStart){
            if (from.charCodeAt(fromStart) !== 47 /*/*/ ) break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        var toStart = 1;
        for(; toStart < to.length; ++toStart){
            if (to.charCodeAt(toStart) !== 47 /*/*/ ) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for(; i <= length; ++i){
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/ ) // We get here if `from` is the exact base path for `to`.
                    // For example: from='/foo/bar'; to='/foo/bar/baz'
                    return to.slice(toStart + i + 1);
                    else if (i === 0) // We get here if `from` is the root
                    // For example: from='/'; to='/foo'
                    return to.slice(toStart + i);
                } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/ ) // We get here if `to` is the exact base path for `from`.
                    // For example: from='/foo/bar/baz'; to='/foo/bar'
                    lastCommonSep = i;
                    else if (i === 0) // We get here if `to` is the root.
                    // For example: from='/foo'; to='/'
                    lastCommonSep = 0;
                }
                break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode) break;
            else if (fromCode === 47 /*/*/ ) lastCommonSep = i;
        }
        var out = "";
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i)if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/ ) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47 /*/*/ ) ++toStart;
            return to.slice(toStart);
        }
    },
    _makeLong: function _makeLong(path) {
        return path;
    },
    dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47 /*/*/ ;
        var end = -1;
        var matchedSlash = true;
        for(var i = path.length - 1; i >= 1; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            } else // We saw the first non-path separator
            matchedSlash = false;
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path.slice(0, end);
    },
    basename: function basename(path, ext) {
        if (ext !== undefined && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path) return "";
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for(i = path.length - 1; i >= 0; --i){
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) // We matched the extension, so mark this as the end of our path
                            // component
                            end = i;
                        } else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) end = firstNonSlashEnd;
            else if (end === -1) end = path.length;
            return path.slice(start, end);
        } else {
            for(i = path.length - 1; i >= 0; --i){
                if (path.charCodeAt(i) === 47 /*/*/ ) // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1) return "";
            return path.slice(start, end);
        }
    },
    extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        for(var i = path.length - 1; i >= 0; --i){
            var code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return "";
        return path.slice(startDot, end);
    },
    format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        return _format("/", pathObject);
    },
    parse: function parse(path) {
        assertPath(path);
        var ret = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47 /*/*/ ;
        var start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        } else start = 0;
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        // Get non-dir info
        for(; i >= start; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
                else ret.base = ret.name = path.slice(startPart, end);
            }
        } else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            } else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
};
posix.posix = posix;
module.exports = posix;

},{"c0743715070b1b8a":"d5jf4"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"kK6CL":[function(require,module,exports) {
"use strict";
var assert = require("78a8134a1ef366b6");
var isExpression = require("25735828ac17e18f");
var characterParser = require("ca77d928e6847b6f");
var error = require("48ffb73d8b050fde");
module.exports = lex;
module.exports.Lexer = Lexer;
function lex(str, options) {
    var lexer = new Lexer(str, options);
    return JSON.parse(JSON.stringify(lexer.getTokens()));
}
/**
 * Initialize `Lexer` with the given `str`.
 *
 * @param {String} str
 * @param {String} filename
 * @api private
 */ function Lexer(str, options) {
    options = options || {};
    if (typeof str !== "string") throw new Error('Expected source code to be a string but got "' + typeof str + '"');
    if (typeof options !== "object") throw new Error('Expected "options" to be an object but got "' + typeof options + '"');
    //Strip any UTF-8 BOM off of the start of `str`, if it exists.
    str = str.replace(/^\uFEFF/, "");
    this.input = str.replace(/\r\n|\r/g, "\n");
    this.originalInput = this.input;
    this.filename = options.filename;
    this.interpolated = options.interpolated || false;
    this.lineno = options.startingLine || 1;
    this.colno = options.startingColumn || 1;
    this.plugins = options.plugins || [];
    this.indentStack = [
        0
    ];
    this.indentRe = null;
    // If #{}, !{} or #[] syntax is allowed when adding text
    this.interpolationAllowed = true;
    this.whitespaceRe = /[ \n\t]/;
    this.tokens = [];
    this.ended = false;
}
/**
 * Lexer prototype.
 */ Lexer.prototype = {
    constructor: Lexer,
    error: function(code, message) {
        var err = error(code, message, {
            line: this.lineno,
            column: this.colno,
            filename: this.filename,
            src: this.originalInput
        });
        throw err;
    },
    assert: function(value, message) {
        if (!value) this.error("ASSERT_FAILED", message);
    },
    isExpression: function(exp) {
        return isExpression(exp, {
            throw: true
        });
    },
    assertExpression: function(exp, noThrow) {
        //this verifies that a JavaScript expression is valid
        try {
            this.callLexerFunction("isExpression", exp);
            return true;
        } catch (ex) {
            if (noThrow) return false;
            // not coming from acorn
            if (!ex.loc) throw ex;
            this.incrementLine(ex.loc.line - 1);
            this.incrementColumn(ex.loc.column);
            var msg = "Syntax Error: " + ex.message.replace(/ \([0-9]+:[0-9]+\)$/, "");
            this.error("SYNTAX_ERROR", msg);
        }
    },
    assertNestingCorrect: function(exp) {
        //this verifies that code is properly nested, but allows
        //invalid JavaScript such as the contents of `attributes`
        var res = characterParser(exp);
        if (res.isNesting()) this.error("INCORRECT_NESTING", "Nesting must match on expression `" + exp + "`");
    },
    /**
   * Construct a token with the given `type` and `val`.
   *
   * @param {String} type
   * @param {String} val
   * @return {Object}
   * @api private
   */ tok: function(type, val) {
        var res = {
            type: type,
            loc: {
                start: {
                    line: this.lineno,
                    column: this.colno
                },
                filename: this.filename
            }
        };
        if (val !== undefined) res.val = val;
        return res;
    },
    /**
   * Set the token's `loc.end` value.
   *
   * @param {Object} tok
   * @returns {Object}
   * @api private
   */ tokEnd: function(tok) {
        tok.loc.end = {
            line: this.lineno,
            column: this.colno
        };
        return tok;
    },
    /**
   * Increment `this.lineno` and reset `this.colno`.
   *
   * @param {Number} increment
   * @api private
   */ incrementLine: function(increment) {
        this.lineno += increment;
        if (increment) this.colno = 1;
    },
    /**
   * Increment `this.colno`.
   *
   * @param {Number} increment
   * @api private
   */ incrementColumn: function(increment) {
        this.colno += increment;
    },
    /**
   * Consume the given `len` of input.
   *
   * @param {Number} len
   * @api private
   */ consume: function(len) {
        this.input = this.input.substr(len);
    },
    /**
   * Scan for `type` with the given `regexp`.
   *
   * @param {String} type
   * @param {RegExp} regexp
   * @return {Object}
   * @api private
   */ scan: function(regexp, type) {
        var captures;
        if (captures = regexp.exec(this.input)) {
            var len = captures[0].length;
            var val = captures[1];
            var diff = len - (val ? val.length : 0);
            var tok = this.tok(type, val);
            this.consume(len);
            this.incrementColumn(diff);
            return tok;
        }
    },
    scanEndOfLine: function(regexp, type) {
        var captures;
        if (captures = regexp.exec(this.input)) {
            var whitespaceLength = 0;
            var whitespace;
            var tok;
            if (whitespace = /^([ ]+)([^ ]*)/.exec(captures[0])) {
                whitespaceLength = whitespace[1].length;
                this.incrementColumn(whitespaceLength);
            }
            var newInput = this.input.substr(captures[0].length);
            if (newInput[0] === ":") {
                this.input = newInput;
                tok = this.tok(type, captures[1]);
                this.incrementColumn(captures[0].length - whitespaceLength);
                return tok;
            }
            if (/^[ \t]*(\n|$)/.test(newInput)) {
                this.input = newInput.substr(/^[ \t]*/.exec(newInput)[0].length);
                tok = this.tok(type, captures[1]);
                this.incrementColumn(captures[0].length - whitespaceLength);
                return tok;
            }
        }
    },
    /**
   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.
   *
   * Make sure that when calling this function, colno is at the character
   * immediately before the beginning.
   *
   * @return {Number}
   * @api private
   */ bracketExpression: function(skip) {
        skip = skip || 0;
        var start = this.input[skip];
        assert(start === "(" || start === "{" || start === "[", 'The start character should be "(", "{" or "["');
        var end = characterParser.BRACKETS[start];
        var range;
        try {
            range = characterParser.parseUntil(this.input, end, {
                start: skip + 1
            });
        } catch (ex) {
            if (ex.index !== undefined) {
                var idx = ex.index;
                // starting from this.input[skip]
                var tmp = this.input.substr(skip).indexOf("\n");
                // starting from this.input[0]
                var nextNewline = tmp + skip;
                var ptr = 0;
                while(idx > nextNewline && tmp !== -1){
                    this.incrementLine(1);
                    idx -= nextNewline + 1;
                    ptr += nextNewline + 1;
                    tmp = nextNewline = this.input.substr(ptr).indexOf("\n");
                }
                this.incrementColumn(idx);
            }
            if (ex.code === "CHARACTER_PARSER:END_OF_STRING_REACHED") this.error("NO_END_BRACKET", "The end of the string reached with no closing bracket " + end + " found.");
            else if (ex.code === "CHARACTER_PARSER:MISMATCHED_BRACKET") this.error("BRACKET_MISMATCH", ex.message);
            throw ex;
        }
        return range;
    },
    scanIndentation: function() {
        var captures, re;
        // established regexp
        if (this.indentRe) captures = this.indentRe.exec(this.input);
        else {
            // tabs
            re = /^\n(\t*) */;
            captures = re.exec(this.input);
            // spaces
            if (captures && !captures[1].length) {
                re = /^\n( *)/;
                captures = re.exec(this.input);
            }
            // established
            if (captures && captures[1].length) this.indentRe = re;
        }
        return captures;
    },
    /**
   * end-of-source.
   */ eos: function() {
        if (this.input.length) return;
        if (this.interpolated) this.error("NO_END_BRACKET", "End of line was reached with no closing bracket for interpolation.");
        for(var i = 0; this.indentStack[i]; i++)this.tokens.push(this.tokEnd(this.tok("outdent")));
        this.tokens.push(this.tokEnd(this.tok("eos")));
        this.ended = true;
        return true;
    },
    /**
   * Blank line.
   */ blank: function() {
        var captures;
        if (captures = /^\n[ \t]*\n/.exec(this.input)) {
            this.consume(captures[0].length - 1);
            this.incrementLine(1);
            return true;
        }
    },
    /**
   * Comment.
   */ comment: function() {
        var captures;
        if (captures = /^\/\/(-)?([^\n]*)/.exec(this.input)) {
            this.consume(captures[0].length);
            var tok = this.tok("comment", captures[2]);
            tok.buffer = "-" != captures[1];
            this.interpolationAllowed = tok.buffer;
            this.tokens.push(tok);
            this.incrementColumn(captures[0].length);
            this.tokEnd(tok);
            this.callLexerFunction("pipelessText");
            return true;
        }
    },
    /**
   * Interpolated tag.
   */ interpolation: function() {
        if (/^#\{/.test(this.input)) {
            var match = this.bracketExpression(1);
            this.consume(match.end + 1);
            var tok = this.tok("interpolation", match.src);
            this.tokens.push(tok);
            this.incrementColumn(2); // '#{'
            this.assertExpression(match.src);
            var splitted = match.src.split("\n");
            var lines = splitted.length - 1;
            this.incrementLine(lines);
            this.incrementColumn(splitted[lines].length + 1); // + 1 → '}'
            this.tokEnd(tok);
            return true;
        }
    },
    /**
   * Tag.
   */ tag: function() {
        var captures;
        if (captures = /^(\w(?:[-:\w]*\w)?)/.exec(this.input)) {
            var tok, name = captures[1], len = captures[0].length;
            this.consume(len);
            tok = this.tok("tag", name);
            this.tokens.push(tok);
            this.incrementColumn(len);
            this.tokEnd(tok);
            return true;
        }
    },
    /**
   * Filter.
   */ filter: function(opts) {
        var tok = this.scan(/^:([\w\-]+)/, "filter");
        var inInclude = opts && opts.inInclude;
        if (tok) {
            this.tokens.push(tok);
            this.incrementColumn(tok.val.length);
            this.tokEnd(tok);
            this.callLexerFunction("attrs");
            if (!inInclude) {
                this.interpolationAllowed = false;
                this.callLexerFunction("pipelessText");
            }
            return true;
        }
    },
    /**
   * Doctype.
   */ doctype: function() {
        var node = this.scanEndOfLine(/^doctype *([^\n]*)/, "doctype");
        if (node) {
            this.tokens.push(this.tokEnd(node));
            return true;
        }
    },
    /**
   * Id.
   */ id: function() {
        var tok = this.scan(/^#([\w-]+)/, "id");
        if (tok) {
            this.tokens.push(tok);
            this.incrementColumn(tok.val.length);
            this.tokEnd(tok);
            return true;
        }
        if (/^#/.test(this.input)) this.error("INVALID_ID", '"' + /.[^ \t\(\#\.\:]*/.exec(this.input.substr(1))[0] + '" is not a valid ID.');
    },
    /**
   * Class.
   */ className: function() {
        var tok = this.scan(/^\.([_a-z0-9\-]*[_a-z][_a-z0-9\-]*)/i, "class");
        if (tok) {
            this.tokens.push(tok);
            this.incrementColumn(tok.val.length);
            this.tokEnd(tok);
            return true;
        }
        if (/^\.[_a-z0-9\-]+/i.test(this.input)) this.error("INVALID_CLASS_NAME", "Class names must contain at least one letter or underscore.");
        if (/^\./.test(this.input)) this.error("INVALID_CLASS_NAME", '"' + /.[^ \t\(\#\.\:]*/.exec(this.input.substr(1))[0] + '" is not a valid class name.  Class names can only contain "_", "-", a-z and 0-9, and must contain at least one of "_", or a-z');
    },
    /**
   * Text.
   */ endInterpolation: function() {
        if (this.interpolated && this.input[0] === "]") {
            this.input = this.input.substr(1);
            this.ended = true;
            return true;
        }
    },
    addText: function(type, value, prefix, escaped) {
        var tok;
        if (value + prefix === "") return;
        prefix = prefix || "";
        escaped = escaped || 0;
        var indexOfEnd = this.interpolated ? value.indexOf("]") : -1;
        var indexOfStart = this.interpolationAllowed ? value.indexOf("#[") : -1;
        var indexOfEscaped = this.interpolationAllowed ? value.indexOf("\\#[") : -1;
        var matchOfStringInterp = /(\\)?([#!]){((?:.|\n)*)$/.exec(value);
        var indexOfStringInterp = this.interpolationAllowed && matchOfStringInterp ? matchOfStringInterp.index : Infinity;
        if (indexOfEnd === -1) indexOfEnd = Infinity;
        if (indexOfStart === -1) indexOfStart = Infinity;
        if (indexOfEscaped === -1) indexOfEscaped = Infinity;
        if (indexOfEscaped !== Infinity && indexOfEscaped < indexOfEnd && indexOfEscaped < indexOfStart && indexOfEscaped < indexOfStringInterp) {
            prefix = prefix + value.substring(0, indexOfEscaped) + "#[";
            return this.addText(type, value.substring(indexOfEscaped + 3), prefix, escaped + 1);
        }
        if (indexOfStart !== Infinity && indexOfStart < indexOfEnd && indexOfStart < indexOfEscaped && indexOfStart < indexOfStringInterp) {
            tok = this.tok(type, prefix + value.substring(0, indexOfStart));
            this.incrementColumn(prefix.length + indexOfStart + escaped);
            this.tokens.push(this.tokEnd(tok));
            tok = this.tok("start-pug-interpolation");
            this.incrementColumn(2);
            this.tokens.push(this.tokEnd(tok));
            var child = new this.constructor(value.substr(indexOfStart + 2), {
                filename: this.filename,
                interpolated: true,
                startingLine: this.lineno,
                startingColumn: this.colno,
                plugins: this.plugins
            });
            var interpolated;
            try {
                interpolated = child.getTokens();
            } catch (ex) {
                if (ex.code && /^PUG:/.test(ex.code)) {
                    this.colno = ex.column;
                    this.error(ex.code.substr(4), ex.msg);
                }
                throw ex;
            }
            this.colno = child.colno;
            this.tokens = this.tokens.concat(interpolated);
            tok = this.tok("end-pug-interpolation");
            this.incrementColumn(1);
            this.tokens.push(this.tokEnd(tok));
            this.addText(type, child.input);
            return;
        }
        if (indexOfEnd !== Infinity && indexOfEnd < indexOfStart && indexOfEnd < indexOfEscaped && indexOfEnd < indexOfStringInterp) {
            if (prefix + value.substring(0, indexOfEnd)) this.addText(type, value.substring(0, indexOfEnd), prefix);
            this.ended = true;
            this.input = value.substr(value.indexOf("]") + 1) + this.input;
            return;
        }
        if (indexOfStringInterp !== Infinity) {
            if (matchOfStringInterp[1]) {
                prefix = prefix + value.substring(0, indexOfStringInterp) + matchOfStringInterp[2] + "{";
                return this.addText(type, value.substring(indexOfStringInterp + 3), prefix, escaped + 1);
            }
            var before = value.substr(0, indexOfStringInterp);
            if (prefix || before) {
                before = prefix + before;
                tok = this.tok(type, before);
                this.incrementColumn(before.length + escaped);
                this.tokens.push(this.tokEnd(tok));
            }
            var rest = matchOfStringInterp[3];
            var range;
            tok = this.tok("interpolated-code");
            this.incrementColumn(2);
            try {
                range = characterParser.parseUntil(rest, "}");
            } catch (ex) {
                if (ex.index !== undefined) this.incrementColumn(ex.index);
                if (ex.code === "CHARACTER_PARSER:END_OF_STRING_REACHED") this.error("NO_END_BRACKET", "End of line was reached with no closing bracket for interpolation.");
                else if (ex.code === "CHARACTER_PARSER:MISMATCHED_BRACKET") this.error("BRACKET_MISMATCH", ex.message);
                else throw ex;
            }
            tok.mustEscape = matchOfStringInterp[2] === "#";
            tok.buffer = true;
            tok.val = range.src;
            this.assertExpression(range.src);
            if (range.end + 1 < rest.length) {
                rest = rest.substr(range.end + 1);
                this.incrementColumn(range.end + 1);
                this.tokens.push(this.tokEnd(tok));
                this.addText(type, rest);
            } else {
                this.incrementColumn(rest.length);
                this.tokens.push(this.tokEnd(tok));
            }
            return;
        }
        value = prefix + value;
        tok = this.tok(type, value);
        this.incrementColumn(value.length + escaped);
        this.tokens.push(this.tokEnd(tok));
    },
    text: function() {
        var tok = this.scan(/^(?:\| ?| )([^\n]+)/, "text") || this.scan(/^( )/, "text") || this.scan(/^\|( ?)/, "text");
        if (tok) {
            this.addText("text", tok.val);
            return true;
        }
    },
    textHtml: function() {
        var tok = this.scan(/^(<[^\n]*)/, "text-html");
        if (tok) {
            this.addText("text-html", tok.val);
            return true;
        }
    },
    /**
   * Dot.
   */ dot: function() {
        var tok;
        if (tok = this.scanEndOfLine(/^\./, "dot")) {
            this.tokens.push(this.tokEnd(tok));
            this.callLexerFunction("pipelessText");
            return true;
        }
    },
    /**
   * Extends.
   */ extends: function() {
        var tok = this.scan(/^extends?(?= |$|\n)/, "extends");
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            if (!this.callLexerFunction("path")) this.error("NO_EXTENDS_PATH", "missing path for extends");
            return true;
        }
        if (this.scan(/^extends?\b/)) this.error("MALFORMED_EXTENDS", "malformed extends");
    },
    /**
   * Block prepend.
   */ prepend: function() {
        var captures;
        if (captures = /^(?:block +)?prepend +([^\n]+)/.exec(this.input)) {
            var name = captures[1].trim();
            var comment = "";
            if (name.indexOf("//") !== -1) {
                comment = "//" + name.split("//").slice(1).join("//");
                name = name.split("//")[0].trim();
            }
            if (!name) return;
            var tok = this.tok("block", name);
            var len = captures[0].length - comment.length;
            while(this.whitespaceRe.test(this.input.charAt(len - 1)))len--;
            this.incrementColumn(len);
            tok.mode = "prepend";
            this.tokens.push(this.tokEnd(tok));
            this.consume(captures[0].length - comment.length);
            this.incrementColumn(captures[0].length - comment.length - len);
            return true;
        }
    },
    /**
   * Block append.
   */ append: function() {
        var captures;
        if (captures = /^(?:block +)?append +([^\n]+)/.exec(this.input)) {
            var name = captures[1].trim();
            var comment = "";
            if (name.indexOf("//") !== -1) {
                comment = "//" + name.split("//").slice(1).join("//");
                name = name.split("//")[0].trim();
            }
            if (!name) return;
            var tok = this.tok("block", name);
            var len = captures[0].length - comment.length;
            while(this.whitespaceRe.test(this.input.charAt(len - 1)))len--;
            this.incrementColumn(len);
            tok.mode = "append";
            this.tokens.push(this.tokEnd(tok));
            this.consume(captures[0].length - comment.length);
            this.incrementColumn(captures[0].length - comment.length - len);
            return true;
        }
    },
    /**
   * Block.
   */ block: function() {
        var captures;
        if (captures = /^block +([^\n]+)/.exec(this.input)) {
            var name = captures[1].trim();
            var comment = "";
            if (name.indexOf("//") !== -1) {
                comment = "//" + name.split("//").slice(1).join("//");
                name = name.split("//")[0].trim();
            }
            if (!name) return;
            var tok = this.tok("block", name);
            var len = captures[0].length - comment.length;
            while(this.whitespaceRe.test(this.input.charAt(len - 1)))len--;
            this.incrementColumn(len);
            tok.mode = "replace";
            this.tokens.push(this.tokEnd(tok));
            this.consume(captures[0].length - comment.length);
            this.incrementColumn(captures[0].length - comment.length - len);
            return true;
        }
    },
    /**
   * Mixin Block.
   */ mixinBlock: function() {
        var tok;
        if (tok = this.scanEndOfLine(/^block/, "mixin-block")) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Yield.
   */ yield: function() {
        var tok = this.scanEndOfLine(/^yield/, "yield");
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Include.
   */ include: function() {
        var tok = this.scan(/^include(?=:| |$|\n)/, "include");
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            while(this.callLexerFunction("filter", {
                inInclude: true
            }));
            if (!this.callLexerFunction("path")) {
                if (/^[^ \n]+/.test(this.input)) // if there is more text
                this.fail();
                else // if not
                this.error("NO_INCLUDE_PATH", "missing path for include");
            }
            return true;
        }
        if (this.scan(/^include\b/)) this.error("MALFORMED_INCLUDE", "malformed include");
    },
    /**
   * Path
   */ path: function() {
        var tok = this.scanEndOfLine(/^ ([^\n]+)/, "path");
        if (tok && (tok.val = tok.val.trim())) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Case.
   */ case: function() {
        var tok = this.scanEndOfLine(/^case +([^\n]+)/, "case");
        if (tok) {
            this.incrementColumn(-tok.val.length);
            this.assertExpression(tok.val);
            this.incrementColumn(tok.val.length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
        if (this.scan(/^case\b/)) this.error("NO_CASE_EXPRESSION", "missing expression for case");
    },
    /**
   * When.
   */ when: function() {
        var tok = this.scanEndOfLine(/^when +([^:\n]+)/, "when");
        if (tok) {
            var parser = characterParser(tok.val);
            while(parser.isNesting() || parser.isString()){
                var rest = /:([^:\n]+)/.exec(this.input);
                if (!rest) break;
                tok.val += rest[0];
                this.consume(rest[0].length);
                this.incrementColumn(rest[0].length);
                parser = characterParser(tok.val);
            }
            this.incrementColumn(-tok.val.length);
            this.assertExpression(tok.val);
            this.incrementColumn(tok.val.length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
        if (this.scan(/^when\b/)) this.error("NO_WHEN_EXPRESSION", "missing expression for when");
    },
    /**
   * Default.
   */ default: function() {
        var tok = this.scanEndOfLine(/^default/, "default");
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
        if (this.scan(/^default\b/)) this.error("DEFAULT_WITH_EXPRESSION", "default should not have an expression");
    },
    /**
   * Call mixin.
   */ call: function() {
        var tok, captures, increment;
        if (captures = /^\+(\s*)(([-\w]+)|(#\{))/.exec(this.input)) {
            // try to consume simple or interpolated call
            if (captures[3]) {
                // simple call
                increment = captures[0].length;
                this.consume(increment);
                tok = this.tok("call", captures[3]);
            } else {
                // interpolated call
                var match = this.bracketExpression(2 + captures[1].length);
                increment = match.end + 1;
                this.consume(increment);
                this.assertExpression(match.src);
                tok = this.tok("call", "#{" + match.src + "}");
            }
            this.incrementColumn(increment);
            tok.args = null;
            // Check for args (not attributes)
            if (captures = /^ *\(/.exec(this.input)) {
                var range = this.bracketExpression(captures[0].length - 1);
                if (!/^\s*[-\w]+ *=/.test(range.src)) {
                    // not attributes
                    this.incrementColumn(1);
                    this.consume(range.end + 1);
                    tok.args = range.src;
                    this.assertExpression("[" + tok.args + "]");
                    for(var i = 0; i <= tok.args.length; i++)if (tok.args[i] === "\n") this.incrementLine(1);
                    else this.incrementColumn(1);
                }
            }
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Mixin.
   */ mixin: function() {
        var captures;
        if (captures = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) {
            this.consume(captures[0].length);
            var tok = this.tok("mixin", captures[1]);
            tok.args = captures[2] || null;
            this.incrementColumn(captures[0].length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Conditional.
   */ conditional: function() {
        var captures;
        if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
            this.consume(captures[0].length);
            var type = captures[1].replace(/ /g, "-");
            var js = captures[2] && captures[2].trim();
            // type can be "if", "else-if" and "else"
            var tok = this.tok(type, js);
            this.incrementColumn(captures[0].length - js.length);
            switch(type){
                case "if":
                case "else-if":
                    this.assertExpression(js);
                    break;
                case "unless":
                    this.assertExpression(js);
                    tok.val = "!(" + js + ")";
                    tok.type = "if";
                    break;
                case "else":
                    if (js) this.error("ELSE_CONDITION", "`else` cannot have a condition, perhaps you meant `else if`");
                    break;
            }
            this.incrementColumn(js.length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * While.
   */ while: function() {
        var captures, tok;
        if (captures = /^while +([^\n]+)/.exec(this.input)) {
            this.consume(captures[0].length);
            this.assertExpression(captures[1]);
            tok = this.tok("while", captures[1]);
            this.incrementColumn(captures[0].length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
        if (this.scan(/^while\b/)) this.error("NO_WHILE_EXPRESSION", "missing expression for while");
    },
    /**
   * Each.
   */ each: function() {
        var captures;
        if (captures = /^(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
            this.consume(captures[0].length);
            var tok = this.tok("each", captures[1]);
            tok.key = captures[2] || null;
            this.incrementColumn(captures[0].length - captures[3].length);
            this.assertExpression(captures[3]);
            tok.code = captures[3];
            this.incrementColumn(captures[3].length);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
        const name = /^each\b/.exec(this.input) ? "each" : "for";
        if (this.scan(/^(?:each|for)\b/)) this.error("MALFORMED_EACH", "This `" + name + "` has a syntax error. `" + name + "` statements should be of the form: `" + name + " VARIABLE_NAME of JS_EXPRESSION`");
        if (captures = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +in +([^\n]+)/.exec(this.input)) this.error("MALFORMED_EACH", 'Pug each and for should no longer be prefixed with a dash ("-"). They are pug keywords and not part of JavaScript.');
    },
    /**
   * EachOf.
   */ eachOf: function() {
        var captures;
        if (captures = /^(?:each|for) (.*?) of *([^\n]+)/.exec(this.input)) {
            this.consume(captures[0].length);
            var tok = this.tok("eachOf", captures[1]);
            tok.value = captures[1];
            this.incrementColumn(captures[0].length - captures[2].length);
            this.assertExpression(captures[2]);
            tok.code = captures[2];
            this.incrementColumn(captures[2].length);
            this.tokens.push(this.tokEnd(tok));
            if (!(/^[a-zA-Z_$][\w$]*$/.test(tok.value.trim()) || /^\[ *[a-zA-Z_$][\w$]* *\, *[a-zA-Z_$][\w$]* *\]$/.test(tok.value.trim()))) this.error("MALFORMED_EACH_OF_LVAL", "The value variable for each must either be a valid identifier (e.g. `item`) or a pair of identifiers in square brackets (e.g. `[key, value]`).");
            return true;
        }
        if (captures = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +of +([^\n]+)/.exec(this.input)) this.error("MALFORMED_EACH", 'Pug each and for should not be prefixed with a dash ("-"). They are pug keywords and not part of JavaScript.');
    },
    /**
   * Code.
   */ code: function() {
        var captures;
        if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
            var flags = captures[1];
            var code = captures[2];
            var shortened = 0;
            if (this.interpolated) {
                var parsed;
                try {
                    parsed = characterParser.parseUntil(code, "]");
                } catch (err) {
                    if (err.index !== undefined) this.incrementColumn(captures[0].length - code.length + err.index);
                    if (err.code === "CHARACTER_PARSER:END_OF_STRING_REACHED") this.error("NO_END_BRACKET", "End of line was reached with no closing bracket for interpolation.");
                    else if (err.code === "CHARACTER_PARSER:MISMATCHED_BRACKET") this.error("BRACKET_MISMATCH", err.message);
                    else throw err;
                }
                shortened = code.length - parsed.end;
                code = parsed.src;
            }
            var consumed = captures[0].length - shortened;
            this.consume(consumed);
            var tok = this.tok("code", code);
            tok.mustEscape = flags.charAt(0) === "=";
            tok.buffer = flags.charAt(0) === "=" || flags.charAt(1) === "=";
            // p #[!=    abc] hey
            //     ^              original colno
            //     -------------- captures[0]
            //           -------- captures[2]
            //     ------         captures[0] - captures[2]
            //           ^        after colno
            // =   abc
            // ^                  original colno
            // -------            captures[0]
            //     ---            captures[2]
            // ----               captures[0] - captures[2]
            //     ^              after colno
            this.incrementColumn(captures[0].length - captures[2].length);
            if (tok.buffer) this.assertExpression(code);
            this.tokens.push(tok);
            // p #[!=    abc] hey
            //           ^        original colno
            //              ----- shortened
            //           ---      code
            //              ^     after colno
            // =   abc
            //     ^              original colno
            //                    shortened
            //     ---            code
            //        ^           after colno
            this.incrementColumn(code.length);
            this.tokEnd(tok);
            return true;
        }
    },
    /**
   * Block code.
   */ blockCode: function() {
        var tok;
        if (tok = this.scanEndOfLine(/^-/, "blockcode")) {
            this.tokens.push(this.tokEnd(tok));
            this.interpolationAllowed = false;
            this.callLexerFunction("pipelessText");
            return true;
        }
    },
    /**
   * Attribute Name.
   */ attribute: function(str) {
        var quote = "";
        var quoteRe = /['"]/;
        var key = "";
        var i;
        // consume all whitespace before the key
        for(i = 0; i < str.length; i++){
            if (!this.whitespaceRe.test(str[i])) break;
            if (str[i] === "\n") this.incrementLine(1);
            else this.incrementColumn(1);
        }
        if (i === str.length) return "";
        var tok = this.tok("attribute");
        // quote?
        if (quoteRe.test(str[i])) {
            quote = str[i];
            this.incrementColumn(1);
            i++;
        }
        // start looping through the key
        for(; i < str.length; i++){
            if (quote) {
                if (str[i] === quote) {
                    this.incrementColumn(1);
                    i++;
                    break;
                }
            } else {
                if (this.whitespaceRe.test(str[i]) || str[i] === "!" || str[i] === "=" || str[i] === ",") break;
            }
            key += str[i];
            if (str[i] === "\n") this.incrementLine(1);
            else this.incrementColumn(1);
        }
        tok.name = key;
        var valueResponse = this.attributeValue(str.substr(i));
        if (valueResponse.val) {
            tok.val = valueResponse.val;
            tok.mustEscape = valueResponse.mustEscape;
        } else {
            // was a boolean attribute (ex: `input(disabled)`)
            tok.val = true;
            tok.mustEscape = true;
        }
        str = valueResponse.remainingSource;
        this.tokens.push(this.tokEnd(tok));
        for(i = 0; i < str.length; i++){
            if (!this.whitespaceRe.test(str[i])) break;
            if (str[i] === "\n") this.incrementLine(1);
            else this.incrementColumn(1);
        }
        if (str[i] === ",") {
            this.incrementColumn(1);
            i++;
        }
        return str.substr(i);
    },
    /**
   * Attribute Value.
   */ attributeValue: function(str) {
        var quoteRe = /['"]/;
        var val = "";
        var done, i, x;
        var escapeAttr = true;
        var state = characterParser.defaultState();
        var col = this.colno;
        var line = this.lineno;
        // consume all whitespace before the equals sign
        for(i = 0; i < str.length; i++){
            if (!this.whitespaceRe.test(str[i])) break;
            if (str[i] === "\n") {
                line++;
                col = 1;
            } else col++;
        }
        if (i === str.length) return {
            remainingSource: str
        };
        if (str[i] === "!") {
            escapeAttr = false;
            col++;
            i++;
            if (str[i] !== "=") this.error("INVALID_KEY_CHARACTER", "Unexpected character " + str[i] + " expected `=`");
        }
        if (str[i] !== "=") {
            // check for anti-pattern `div("foo"bar)`
            if (i === 0 && str && !this.whitespaceRe.test(str[0]) && str[0] !== ",") this.error("INVALID_KEY_CHARACTER", "Unexpected character " + str[0] + " expected `=`");
            else return {
                remainingSource: str
            };
        }
        this.lineno = line;
        this.colno = col + 1;
        i++;
        // consume all whitespace before the value
        for(; i < str.length; i++){
            if (!this.whitespaceRe.test(str[i])) break;
            if (str[i] === "\n") this.incrementLine(1);
            else this.incrementColumn(1);
        }
        line = this.lineno;
        col = this.colno;
        // start looping through the value
        for(; i < str.length; i++){
            // if the character is in a string or in parentheses/brackets/braces
            if (!(state.isNesting() || state.isString())) {
                if (this.whitespaceRe.test(str[i])) {
                    done = false;
                    // find the first non-whitespace character
                    for(x = i; x < str.length; x++)if (!this.whitespaceRe.test(str[x])) {
                        // if it is a JavaScript punctuator, then assume that it is
                        // a part of the value
                        const isNotPunctuator = !characterParser.isPunctuator(str[x]);
                        const isQuote = quoteRe.test(str[x]);
                        const isColon = str[x] === ":";
                        const isSpreadOperator = str[x] + str[x + 1] + str[x + 2] === "...";
                        if ((isNotPunctuator || isQuote || isColon || isSpreadOperator) && this.assertExpression(val, true)) done = true;
                        break;
                    }
                    // if everything else is whitespace, return now so last attribute
                    // does not include trailing whitespace
                    if (done || x === str.length) break;
                }
                // if there's no whitespace and the character is not ',', the
                // attribute did not end.
                if (str[i] === "," && this.assertExpression(val, true)) break;
            }
            state = characterParser.parseChar(str[i], state);
            val += str[i];
            if (str[i] === "\n") {
                line++;
                col = 1;
            } else col++;
        }
        this.assertExpression(val);
        this.lineno = line;
        this.colno = col;
        return {
            val: val,
            mustEscape: escapeAttr,
            remainingSource: str.substr(i)
        };
    },
    /**
   * Attributes.
   */ attrs: function() {
        var tok;
        if ("(" == this.input.charAt(0)) {
            tok = this.tok("start-attributes");
            var index = this.bracketExpression().end;
            var str = this.input.substr(1, index - 1);
            this.incrementColumn(1);
            this.tokens.push(this.tokEnd(tok));
            this.assertNestingCorrect(str);
            this.consume(index + 1);
            while(str)str = this.attribute(str);
            tok = this.tok("end-attributes");
            this.incrementColumn(1);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * &attributes block
   */ attributesBlock: function() {
        if (/^&attributes\b/.test(this.input)) {
            var consumed = 11;
            this.consume(consumed);
            var tok = this.tok("&attributes");
            this.incrementColumn(consumed);
            var args = this.bracketExpression();
            consumed = args.end + 1;
            this.consume(consumed);
            tok.val = args.src;
            this.incrementColumn(consumed);
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * Indent | Outdent | Newline.
   */ indent: function() {
        var captures = this.scanIndentation();
        var tok;
        if (captures) {
            var indents = captures[1].length;
            this.incrementLine(1);
            this.consume(indents + 1);
            if (" " == this.input[0] || "	" == this.input[0]) this.error("INVALID_INDENTATION", "Invalid indentation, you can use tabs or spaces but not both");
            // blank line
            if ("\n" == this.input[0]) {
                this.interpolationAllowed = true;
                return this.tokEnd(this.tok("newline"));
            }
            // outdent
            if (indents < this.indentStack[0]) {
                var outdent_count = 0;
                while(this.indentStack[0] > indents){
                    if (this.indentStack[1] < indents) this.error("INCONSISTENT_INDENTATION", "Inconsistent indentation. Expecting either " + this.indentStack[1] + " or " + this.indentStack[0] + " spaces/tabs.");
                    outdent_count++;
                    this.indentStack.shift();
                }
                while(outdent_count--){
                    this.colno = 1;
                    tok = this.tok("outdent");
                    this.colno = this.indentStack[0] + 1;
                    this.tokens.push(this.tokEnd(tok));
                }
            // indent
            } else if (indents && indents != this.indentStack[0]) {
                tok = this.tok("indent", indents);
                this.colno = 1 + indents;
                this.tokens.push(this.tokEnd(tok));
                this.indentStack.unshift(indents);
            // newline
            } else {
                tok = this.tok("newline");
                this.colno = 1 + Math.min(this.indentStack[0] || 0, indents);
                this.tokens.push(this.tokEnd(tok));
            }
            this.interpolationAllowed = true;
            return true;
        }
    },
    pipelessText: function pipelessText(indents) {
        while(this.callLexerFunction("blank"));
        var captures = this.scanIndentation();
        indents = indents || captures && captures[1].length;
        if (indents > this.indentStack[0]) {
            this.tokens.push(this.tokEnd(this.tok("start-pipeless-text")));
            var tokens = [];
            var token_indent = [];
            var isMatch;
            // Index in this.input. Can't use this.consume because we might need to
            // retry lexing the block.
            var stringPtr = 0;
            do {
                // text has `\n` as a prefix
                var i = this.input.substr(stringPtr + 1).indexOf("\n");
                if (-1 == i) i = this.input.length - stringPtr - 1;
                var str = this.input.substr(stringPtr + 1, i);
                var lineCaptures = this.indentRe.exec("\n" + str);
                var lineIndents = lineCaptures && lineCaptures[1].length;
                isMatch = lineIndents >= indents;
                token_indent.push(isMatch);
                isMatch = isMatch || !str.trim();
                if (isMatch) {
                    // consume test along with `\n` prefix if match
                    stringPtr += str.length + 1;
                    tokens.push(str.substr(indents));
                } else if (lineIndents > this.indentStack[0]) {
                    // line is indented less than the first line but is still indented
                    // need to retry lexing the text block
                    this.tokens.pop();
                    return pipelessText.call(this, lineCaptures[1].length);
                }
            }while (this.input.length - stringPtr && isMatch);
            this.consume(stringPtr);
            while(this.input.length === 0 && tokens[tokens.length - 1] === "")tokens.pop();
            tokens.forEach((function(token, i) {
                var tok;
                this.incrementLine(1);
                if (i !== 0) tok = this.tok("newline");
                if (token_indent[i]) this.incrementColumn(indents);
                if (tok) this.tokens.push(this.tokEnd(tok));
                this.addText("text", token);
            }).bind(this));
            this.tokens.push(this.tokEnd(this.tok("end-pipeless-text")));
            return true;
        }
    },
    /**
   * Slash.
   */ slash: function() {
        var tok = this.scan(/^\//, "slash");
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    /**
   * ':'
   */ colon: function() {
        var tok = this.scan(/^: +/, ":");
        if (tok) {
            this.tokens.push(this.tokEnd(tok));
            return true;
        }
    },
    fail: function() {
        this.error("UNEXPECTED_TEXT", 'unexpected text "' + this.input.substr(0, 5) + '"');
    },
    callLexerFunction: function(func) {
        var rest = [];
        for(var i = 1; i < arguments.length; i++)rest.push(arguments[i]);
        var pluginArgs = [
            this
        ].concat(rest);
        for(var i = 0; i < this.plugins.length; i++){
            var plugin = this.plugins[i];
            if (plugin[func] && plugin[func].apply(plugin, pluginArgs)) return true;
        }
        return this[func].apply(this, rest);
    },
    /**
   * Move to the next token
   *
   * @api private
   */ advance: function() {
        return this.callLexerFunction("blank") || this.callLexerFunction("eos") || this.callLexerFunction("endInterpolation") || this.callLexerFunction("yield") || this.callLexerFunction("doctype") || this.callLexerFunction("interpolation") || this.callLexerFunction("case") || this.callLexerFunction("when") || this.callLexerFunction("default") || this.callLexerFunction("extends") || this.callLexerFunction("append") || this.callLexerFunction("prepend") || this.callLexerFunction("block") || this.callLexerFunction("mixinBlock") || this.callLexerFunction("include") || this.callLexerFunction("mixin") || this.callLexerFunction("call") || this.callLexerFunction("conditional") || this.callLexerFunction("eachOf") || this.callLexerFunction("each") || this.callLexerFunction("while") || this.callLexerFunction("tag") || this.callLexerFunction("filter") || this.callLexerFunction("blockCode") || this.callLexerFunction("code") || this.callLexerFunction("id") || this.callLexerFunction("dot") || this.callLexerFunction("className") || this.callLexerFunction("attrs") || this.callLexerFunction("attributesBlock") || this.callLexerFunction("indent") || this.callLexerFunction("text") || this.callLexerFunction("textHtml") || this.callLexerFunction("comment") || this.callLexerFunction("slash") || this.callLexerFunction("colon") || this.fail();
    },
    /**
   * Return an array of tokens for the current file
   *
   * @returns {Array.<Token>}
   * @api public
   */ getTokens: function() {
        while(!this.ended)this.callLexerFunction("advance");
        return this.tokens;
    }
};

},{"78a8134a1ef366b6":"f3tT4","25735828ac17e18f":"8v6kX","ca77d928e6847b6f":"4nNrL","48ffb73d8b050fde":"khglH"}],"f3tT4":[function(require,module,exports) {
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
var process = require("17530e9a8e9dd8de");
"use strict";
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
var _require = require("67930e3bebc18ea9"), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = require("11bdd262fb706a54");
var _require2 = require("d61a3396666721b6"), inspect = _require2.inspect;
var _require$types = require("d61a3396666721b6").types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
var objectAssign = Object.assign ? Object.assign : require("613bbc2cfb4d4558").assign;
var objectIs = Object.is ? Object.is : require("f909244cb7b0ea0c");
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
    var comparison = require("131e25d2408617a4");
    isDeepEqual = comparison.isDeepEqual;
    isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "",
    "",
    "\\u000b",
    "\\f",
    "",
    "\\u000e",
    "\\u000f",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001a",
    "\\u001b",
    "\\u001c",
    "\\u001d",
    "\\u001e",
    "\\u001f"
];
var escapeFn = function escapeFn(str) {
    return meta[str.charCodeAt(0)];
};
var warned = false; // The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.
var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.
function innerFail(obj) {
    if (obj.message instanceof Error) throw obj.message;
    throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
    var argsLen = arguments.length;
    var internalMessage;
    if (argsLen === 0) internalMessage = "Failed";
    else if (argsLen === 1) {
        message = actual;
        actual = undefined;
    } else {
        if (warned === false) {
            warned = true;
            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
            warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        if (argsLen === 2) operator = "!=";
    }
    if (message instanceof Error) throw message;
    var errArgs = {
        actual: actual,
        expected: expected,
        operator: operator === undefined ? "fail" : operator,
        stackStartFn: stackStartFn || fail
    };
    if (message !== undefined) errArgs.message = message;
    var err = new AssertionError(errArgs);
    if (internalMessage) {
        err.message = internalMessage;
        err.generatedMessage = true;
    }
    throw err;
}
assert.fail = fail; // The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
    if (!value) {
        var generatedMessage = false;
        if (argLen === 0) {
            generatedMessage = true;
            message = "No value argument passed to `assert.ok()`";
        } else if (message instanceof Error) throw message;
        var err = new AssertionError({
            actual: value,
            expected: true,
            message: message,
            operator: "==",
            stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
    }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.
function ok() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    innerOk.apply(void 0, [
        ok,
        args.length
    ].concat(args));
}
assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
/* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
     // eslint-disable-next-line eqeqeq
    if (actual != expected) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "==",
        stackStartFn: equal
    });
}; // The non-equality assertion tests for whether two objects are not
// equal with !=.
assert.notEqual = function notEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
     // eslint-disable-next-line eqeqeq
    if (actual == expected) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "!=",
        stackStartFn: notEqual
    });
}; // The equivalence assertion tests a deep equality relation.
assert.deepEqual = function deepEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (!isDeepEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "deepEqual",
        stackStartFn: deepEqual
    });
}; // The non-equivalence assertion tests for any deep inequality.
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (isDeepEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "notDeepEqual",
        stackStartFn: notDeepEqual
    });
};
/* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (!isDeepStrictEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "deepStrictEqual",
        stackStartFn: deepStrictEqual
    });
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (isDeepStrictEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "notDeepStrictEqual",
        stackStartFn: notDeepStrictEqual
    });
}
assert.strictEqual = function strictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (!objectIs(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "strictEqual",
        stackStartFn: strictEqual
    });
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS("actual", "expected");
    if (objectIs(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: "notStrictEqual",
        stackStartFn: notStrictEqual
    });
};
var Comparison = function Comparison(obj, keys, actual) {
    var _this = this;
    _classCallCheck(this, Comparison);
    keys.forEach(function(key) {
        if (key in obj) {
            if (actual !== undefined && typeof actual[key] === "string" && isRegExp(obj[key]) && obj[key].test(actual[key])) _this[key] = actual[key];
            else _this[key] = obj[key];
        }
    });
};
function compareExceptionKey(actual, expected, key, message, keys, fn) {
    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
        if (!message) {
            // Create placeholder objects to create a nice output.
            var a = new Comparison(actual, keys);
            var b = new Comparison(expected, keys, actual);
            var err = new AssertionError({
                actual: a,
                expected: b,
                operator: "deepStrictEqual",
                stackStartFn: fn
            });
            err.actual = actual;
            err.expected = expected;
            err.operator = fn.name;
            throw err;
        }
        innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: fn.name,
            stackStartFn: fn
        });
    }
}
function expectedException(actual, expected, msg, fn) {
    if (typeof expected !== "function") {
        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
        if (arguments.length === 2) throw new ERR_INVALID_ARG_TYPE("expected", [
            "Function",
            "RegExp"
        ], expected);
         // Handle primitives properly.
        if (_typeof(actual) !== "object" || actual === null) {
            var err = new AssertionError({
                actual: actual,
                expected: expected,
                message: msg,
                operator: "deepStrictEqual",
                stackStartFn: fn
            });
            err.operator = fn.name;
            throw err;
        }
        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
        // as well.
        if (expected instanceof Error) keys.push("name", "message");
        else if (keys.length === 0) throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
        if (isDeepEqual === undefined) lazyLoadComparison();
        keys.forEach(function(key) {
            if (typeof actual[key] === "string" && isRegExp(expected[key]) && expected[key].test(actual[key])) return;
            compareExceptionKey(actual, expected, key, msg, keys, fn);
        });
        return true;
    } // Guard instanceof against arrow functions as they don't have a prototype.
    if (expected.prototype !== undefined && actual instanceof expected) return true;
    if (Error.isPrototypeOf(expected)) return false;
    return expected.call({}, actual) === true;
}
function getActual(fn) {
    if (typeof fn !== "function") throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
    try {
        fn();
    } catch (e) {
        return e;
    }
    return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
    // Accept native ES6 promises and promises that are implemented in a similar
    // way. Do not accept thenables that use a function as `obj` and that have no
    // `catch` handler.
    // TODO: thenables are checked up until they have the correct methods,
    // but according to documentation, the `then` method should receive
    // the `fulfill` and `reject` arguments as well or it may be never resolved.
    return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
}
function waitForActual(promiseFn) {
    return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === "function") {
            // Return a rejected promise if `promiseFn` throws synchronously.
            resultPromise = promiseFn(); // Fail in case no promise is returned.
            if (!checkIsPromise(resultPromise)) throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
        } else if (checkIsPromise(promiseFn)) resultPromise = promiseFn;
        else throw new ERR_INVALID_ARG_TYPE("promiseFn", [
            "Function",
            "Promise"
        ], promiseFn);
        return Promise.resolve().then(function() {
            return resultPromise;
        }).then(function() {
            return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
            return e;
        });
    });
}
function expectsError(stackStartFn, actual, error, message) {
    if (typeof error === "string") {
        if (arguments.length === 4) throw new ERR_INVALID_ARG_TYPE("error", [
            "Object",
            "Error",
            "Function",
            "RegExp"
        ], error);
        if (_typeof(actual) === "object" && actual !== null) {
            if (actual.message === error) throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
        } else if (actual === error) throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
        message = error;
        error = undefined;
    } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") throw new ERR_INVALID_ARG_TYPE("error", [
        "Object",
        "Error",
        "Function",
        "RegExp"
    ], error);
    if (actual === NO_EXCEPTION_SENTINEL) {
        var details = "";
        if (error && error.name) details += " (".concat(error.name, ")");
        details += message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
        innerFail({
            actual: undefined,
            expected: error,
            operator: stackStartFn.name,
            message: "Missing expected ".concat(fnType).concat(details),
            stackStartFn: stackStartFn
        });
    }
    if (error && !expectedException(actual, error, message, stackStartFn)) throw actual;
}
function expectsNoError(stackStartFn, actual, error, message) {
    if (actual === NO_EXCEPTION_SENTINEL) return;
    if (typeof error === "string") {
        message = error;
        error = undefined;
    }
    if (!error || expectedException(actual, error)) {
        var details = message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
        innerFail({
            actual: actual,
            expected: error,
            operator: stackStartFn.name,
            message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
            stackStartFn: stackStartFn
        });
    }
    throw actual;
}
assert.throws = function throws(promiseFn) {
    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
    expectsError.apply(void 0, [
        throws,
        getActual(promiseFn)
    ].concat(args));
};
assert.rejects = function rejects(promiseFn) {
    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)args[_key3 - 1] = arguments[_key3];
    return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(void 0, [
            rejects,
            result
        ].concat(args));
    });
};
assert.doesNotThrow = function doesNotThrow(fn) {
    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)args[_key4 - 1] = arguments[_key4];
    expectsNoError.apply(void 0, [
        doesNotThrow,
        getActual(fn)
    ].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++)args[_key5 - 1] = arguments[_key5];
    return waitForActual(fn).then(function(result) {
        return expectsNoError.apply(void 0, [
            doesNotReject,
            result
        ].concat(args));
    });
};
assert.ifError = function ifError(err) {
    if (err !== null && err !== undefined) {
        var message = "ifError got unwanted exception: ";
        if (_typeof(err) === "object" && typeof err.message === "string") {
            if (err.message.length === 0 && err.constructor) message += err.constructor.name;
            else message += err.message;
        } else message += inspect(err);
        var newErr = new AssertionError({
            actual: err,
            expected: null,
            operator: "ifError",
            message: message,
            stackStartFn: ifError
        }); // Make sure we actually have a stack trace!
        var origStack = err.stack;
        if (typeof origStack === "string") {
            // This will remove any duplicated frames from the error frames taken
            // from within `ifError` and add the original error frames to the newly
            // created ones.
            var tmp2 = origStack.split("\n");
            tmp2.shift(); // Filter all frames existing in err.stack.
            var tmp1 = newErr.stack.split("\n");
            for(var i = 0; i < tmp2.length; i++){
                // Find the first occurrence of the frame.
                var pos = tmp1.indexOf(tmp2[i]);
                if (pos !== -1) {
                    // Only keep new frames.
                    tmp1 = tmp1.slice(0, pos);
                    break;
                }
            }
            newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
        }
        throw newErr;
    }
}; // Expose a strict only variant of assert
function strict() {
    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++)args[_key6] = arguments[_key6];
    innerOk.apply(void 0, [
        strict,
        args.length
    ].concat(args));
}
assert.strict = objectAssign(strict, assert, {
    equal: assert.strictEqual,
    deepEqual: assert.deepStrictEqual,
    notEqual: assert.notStrictEqual,
    notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

},{"17530e9a8e9dd8de":"d5jf4","67930e3bebc18ea9":"cwQVR","11bdd262fb706a54":"lQlQt","d61a3396666721b6":"cxohQ","613bbc2cfb4d4558":"713SE","f909244cb7b0ea0c":"k2tpA","131e25d2408617a4":"d5TM9"}],"cwQVR":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
/* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ "use strict"; // The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
var codes = {}; // Lazy loaded
var assert;
var util;
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError = /*#__PURE__*/ function(_Base) {
        _inherits(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            var _this;
            _classCallCheck(this, NodeError);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
            _this.code = code;
            return _this;
        }
        return NodeError;
    }(Base);
    codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== "number") start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    if (assert === undefined) assert = require("f73a3052b95b9ed");
    assert(typeof name === "string", "'name' must be a string"); // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else determiner = "must be";
    var msg;
    if (endsWith(name, " argument")) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
    msg += ". Received type ".concat(_typeof(actual));
    return msg;
}, TypeError);
createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "is invalid";
    if (util === undefined) util = require("1fd472100fa8826f");
    var inspected = util.inspect(value);
    if (inspected.length > 128) inspected = "".concat(inspected.slice(0, 128), "...");
    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
    var type;
    if (value && value.constructor && value.constructor.name) type = "instance of ".concat(value.constructor.name);
    else type = "type ".concat(_typeof(value));
    return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
}, TypeError);
createErrorType("ERR_MISSING_ARGS", function() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    if (assert === undefined) assert = require("f73a3052b95b9ed");
    assert(args.length > 0, "At least one arg needs to be specified");
    var msg = "The ";
    var len = args.length;
    args = args.map(function(a) {
        return '"'.concat(a, '"');
    });
    switch(len){
        case 1:
            msg += "".concat(args[0], " argument");
            break;
        case 2:
            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
            break;
        default:
            msg += args.slice(0, len - 1).join(", ");
            msg += ", and ".concat(args[len - 1], " arguments");
            break;
    }
    return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

},{"f73a3052b95b9ed":"f3tT4","1fd472100fa8826f":"cxohQ"}],"cxohQ":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var process = require("bc23a3ea4a141c0b");
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for(var i = 0; i < keys.length; i++)descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    return descriptors;
};
var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
    if (!isString(f)) {
        var objects = [];
        for(var i = 0; i < arguments.length; i++)objects.push(inspect(arguments[i]));
        return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
        if (x === "%%") return "%";
        if (i >= len) return x;
        switch(x){
            case "%s":
                return String(args[i++]);
            case "%d":
                return Number(args[i++]);
            case "%j":
                try {
                    return JSON.stringify(args[i++]);
                } catch (_) {
                    return "[Circular]";
                }
            default:
                return x;
        }
    });
    for(var x = args[i]; i < len; x = args[++i])if (isNull(x) || !isObject(x)) str += " " + x;
    else str += " " + inspect(x);
    return str;
};
// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
    if (typeof process !== "undefined" && process.noDeprecation === true) return fn;
    // Allow for deprecating things in the process of starting up.
    if (typeof process === "undefined") return function() {
        return exports.deprecate(fn, msg).apply(this, arguments);
    };
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (process.throwDeprecation) throw new Error(msg);
            else if (process.traceDeprecation) console.trace(msg);
            else console.error(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
};
var debugs = {};
var debugEnvRegex = /^$/;
var debugEnv;
exports.debuglog = function(set) {
    set = set.toUpperCase();
    if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
                var msg = exports.format.apply(exports, arguments);
                console.error("%s %d: %s", set, pid, msg);
            };
        } else debugs[set] = function() {};
    }
    return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
    // default options
    var ctx = {
        seen: [],
        stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) // legacy...
    ctx.showHidden = opts;
    else if (opts) // got an "options" object
    exports._extend(ctx, opts);
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
    "bold": [
        1,
        22
    ],
    "italic": [
        3,
        23
    ],
    "underline": [
        4,
        24
    ],
    "inverse": [
        7,
        27
    ],
    "white": [
        37,
        39
    ],
    "grey": [
        90,
        39
    ],
    "black": [
        30,
        39
    ],
    "blue": [
        34,
        39
    ],
    "cyan": [
        36,
        39
    ],
    "green": [
        32,
        39
    ],
    "magenta": [
        35,
        39
    ],
    "red": [
        31,
        39
    ],
    "yellow": [
        33,
        39
    ]
};
// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
};
function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) return "\x1b[" + inspect.colors[style][0] + "m" + str + "\x1b[" + inspect.colors[style][1] + "m";
    else return str;
}
function stylizeNoColor(str, styleType) {
    return str;
}
function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
        hash[val] = true;
    });
    return hash;
}
function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) ret = formatValue(ctx, ret, recurseTimes);
        return ret;
    }
    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) return primitive;
    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) keys = Object.getOwnPropertyNames(value);
    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) return formatError(value);
    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
        if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
        if (isError(value)) return formatError(value);
    }
    var base = "", array = false, braces = [
        "{",
        "}"
    ];
    // Make Array say that they are Array
    if (isArray(value)) {
        array = true;
        braces = [
            "[",
            "]"
        ];
    }
    // Make functions say that they are functions
    if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
    }
    // Make RegExps say that they are RegExps
    if (isRegExp(value)) base = " " + RegExp.prototype.toString.call(value);
    // Make dates with properties first say the date
    if (isDate(value)) base = " " + Date.prototype.toUTCString.call(value);
    // Make error with message first say the error
    if (isError(value)) base = " " + formatError(value);
    if (keys.length === 0 && (!array || value.length == 0)) return braces[0] + base + braces[1];
    if (recurseTimes < 0) {
        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        else return ctx.stylize("[Object]", "special");
    }
    ctx.seen.push(value);
    var output;
    if (array) output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    else output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
    }
    if (isNumber(value)) return ctx.stylize("" + value, "number");
    if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
    // For some reason typeof null is "object", so special case here.
    if (isNull(value)) return ctx.stylize("null", "null");
}
function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for(var i = 0, l = value.length; i < l; ++i)if (hasOwnProperty(value, String(i))) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    else output.push("");
    keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    });
    return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
    };
    if (desc.get) {
        if (desc.set) str = ctx.stylize("[Getter/Setter]", "special");
        else str = ctx.stylize("[Getter]", "special");
    } else if (desc.set) str = ctx.stylize("[Setter]", "special");
    if (!hasOwnProperty(visibleKeys, key)) name = "[" + key + "]";
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) str = formatValue(ctx, desc.value, null);
            else str = formatValue(ctx, desc.value, recurseTimes - 1);
            if (str.indexOf("\n") > -1) {
                if (array) str = str.split("\n").map(function(line) {
                    return "  " + line;
                }).join("\n").slice(2);
                else str = "\n" + str.split("\n").map(function(line) {
                    return "   " + line;
                }).join("\n");
            }
        } else str = ctx.stylize("[Circular]", "special");
    }
    if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) return str;
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
        } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
        }
    }
    return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require("6a1c15bae847a134");
function isArray(ar) {
    return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
    return typeof arg === "boolean";
}
exports.isBoolean = isBoolean;
function isNull(arg) {
    return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
    return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
    return typeof arg === "number";
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === "string";
}
exports.isString = isString;
function isSymbol(arg) {
    return typeof arg === "symbol";
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
    return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
    return isObject(re) && objectToString(re) === "[object RegExp]";
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;
function isObject(arg) {
    return typeof arg === "object" && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
    return isObject(d) && objectToString(d) === "[object Date]";
}
exports.isDate = isDate;
exports.types.isDate = isDate;
function isError(e) {
    return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;
function isFunction(arg) {
    return typeof arg === "function";
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = require("a42137cd7fc8700d");
function objectToString(o) {
    return Object.prototype.toString.call(o);
}
function pad(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
];
// 26 Feb 16:19:34
function timestamp() {
    var d = new Date();
    var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
    ].join(":");
    return [
        d.getDate(),
        months[d.getMonth()],
        time
    ].join(" ");
}
// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
    console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports.inherits = require("a792e8e3e2aa1973");
exports._extend = function(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while(i--)origin[keys[i]] = add[keys[i]];
    return origin;
};
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
exports.promisify = function promisify(original) {
    if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
        return fn;
    }
    function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
        });
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        args.push(function(err, value) {
            if (err) promiseReject(err);
            else promiseResolve(value);
        });
        try {
            original.apply(this, args);
        } catch (err) {
            promiseReject(err);
        }
        return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};
exports.promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
    }
    return cb(reason);
}
function callbackify(original) {
    if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
    // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.
    function callbackified() {
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") throw new TypeError("The last argument must be of type Function");
        var self = this;
        var cb = function() {
            return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args).then(function(ret) {
            process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
}
exports.callbackify = callbackify;

},{"bc23a3ea4a141c0b":"d5jf4","6a1c15bae847a134":"bnQvf","a42137cd7fc8700d":"inNNy","a792e8e3e2aa1973":"bRL3M"}],"bnQvf":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
"use strict";
var isArgumentsObject = require("6b5f9ae3e436d527");
var isGeneratorFunction = require("285c2b8081bf4b68");
var whichTypedArray = require("e95b88ccd80e1671");
var isTypedArray = require("7db151546a22c2a8");
function uncurryThis(f) {
    return f.call.bind(f);
}
var BigIntSupported = typeof BigInt !== "undefined";
var SymbolSupported = typeof Symbol !== "undefined";
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);
if (BigIntSupported) var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
if (SymbolSupported) var symbolValue = uncurryThis(Symbol.prototype.valueOf);
function checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== "object") return false;
    try {
        prototypeValueOf(value);
        return true;
    } catch (e) {
        return false;
    }
}
exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;
// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
}
exports.isPromise = isPromise;
function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) return ArrayBuffer.isView(value);
    return isTypedArray(value) || isDataView(value);
}
exports.isArrayBufferView = isArrayBufferView;
function isUint8Array(value) {
    return whichTypedArray(value) === "Uint8Array";
}
exports.isUint8Array = isUint8Array;
function isUint8ClampedArray(value) {
    return whichTypedArray(value) === "Uint8ClampedArray";
}
exports.isUint8ClampedArray = isUint8ClampedArray;
function isUint16Array(value) {
    return whichTypedArray(value) === "Uint16Array";
}
exports.isUint16Array = isUint16Array;
function isUint32Array(value) {
    return whichTypedArray(value) === "Uint32Array";
}
exports.isUint32Array = isUint32Array;
function isInt8Array(value) {
    return whichTypedArray(value) === "Int8Array";
}
exports.isInt8Array = isInt8Array;
function isInt16Array(value) {
    return whichTypedArray(value) === "Int16Array";
}
exports.isInt16Array = isInt16Array;
function isInt32Array(value) {
    return whichTypedArray(value) === "Int32Array";
}
exports.isInt32Array = isInt32Array;
function isFloat32Array(value) {
    return whichTypedArray(value) === "Float32Array";
}
exports.isFloat32Array = isFloat32Array;
function isFloat64Array(value) {
    return whichTypedArray(value) === "Float64Array";
}
exports.isFloat64Array = isFloat64Array;
function isBigInt64Array(value) {
    return whichTypedArray(value) === "BigInt64Array";
}
exports.isBigInt64Array = isBigInt64Array;
function isBigUint64Array(value) {
    return whichTypedArray(value) === "BigUint64Array";
}
exports.isBigUint64Array = isBigUint64Array;
function isMapToString(value) {
    return ObjectToString(value) === "[object Map]";
}
isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
function isMap(value) {
    if (typeof Map === "undefined") return false;
    return isMapToString.working ? isMapToString(value) : value instanceof Map;
}
exports.isMap = isMap;
function isSetToString(value) {
    return ObjectToString(value) === "[object Set]";
}
isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
function isSet(value) {
    if (typeof Set === "undefined") return false;
    return isSetToString.working ? isSetToString(value) : value instanceof Set;
}
exports.isSet = isSet;
function isWeakMapToString(value) {
    return ObjectToString(value) === "[object WeakMap]";
}
isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
function isWeakMap(value) {
    if (typeof WeakMap === "undefined") return false;
    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;
function isWeakSetToString(value) {
    return ObjectToString(value) === "[object WeakSet]";
}
isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
function isWeakSet(value) {
    return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;
function isArrayBufferToString(value) {
    return ObjectToString(value) === "[object ArrayBuffer]";
}
isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
function isArrayBuffer(value) {
    if (typeof ArrayBuffer === "undefined") return false;
    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;
function isDataViewToString(value) {
    return ObjectToString(value) === "[object DataView]";
}
isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
function isDataView(value) {
    if (typeof DataView === "undefined") return false;
    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
}
exports.isDataView = isDataView;
// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === "[object SharedArrayBuffer]";
}
function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBufferCopy === "undefined") return false;
    if (typeof isSharedArrayBufferToString.working === "undefined") isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;
function isAsyncFunction(value) {
    return ObjectToString(value) === "[object AsyncFunction]";
}
exports.isAsyncFunction = isAsyncFunction;
function isMapIterator(value) {
    return ObjectToString(value) === "[object Map Iterator]";
}
exports.isMapIterator = isMapIterator;
function isSetIterator(value) {
    return ObjectToString(value) === "[object Set Iterator]";
}
exports.isSetIterator = isSetIterator;
function isGeneratorObject(value) {
    return ObjectToString(value) === "[object Generator]";
}
exports.isGeneratorObject = isGeneratorObject;
function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === "[object WebAssembly.Module]";
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
function isNumberObject(value) {
    return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;
function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;
function isBooleanObject(value) {
    return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;
function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;
function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;
function isBoxedPrimitive(value) {
    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;
[
    "isProxy",
    "isExternal",
    "isModuleNamespaceObject"
].forEach(function(method) {
    Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
            throw new Error(method + " is not supported in userland");
        }
    });
});

},{"6b5f9ae3e436d527":"czr4n","285c2b8081bf4b68":"2XUdn","e95b88ccd80e1671":"lVUO7","7db151546a22c2a8":"1ihkG"}],"czr4n":[function(require,module,exports) {
"use strict";
var hasToStringTag = require("e2b01ce809f132fb")();
var callBound = require("649cbf9949986a39");
var $toString = callBound("Object.prototype.toString");
var isStandardArguments = function isArguments(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) return false;
    return $toString(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments(value) {
    if (isStandardArguments(value)) return true;
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"e2b01ce809f132fb":"9LdQ9","649cbf9949986a39":"5yYiF"}],"9LdQ9":[function(require,module,exports) {
"use strict";
var hasSymbols = require("2ef89576d4959bff");
module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};

},{"2ef89576d4959bff":"euYk7"}],"euYk7":[function(require,module,exports) {
"use strict";
/* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
    if (typeof Symbol.iterator === "symbol") return true;
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") return false;
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(sym in obj)return false;
     // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) return false;
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
    if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
    }
    return true;
};

},{}],"5yYiF":[function(require,module,exports) {
"use strict";
var GetIntrinsic = require("8b08ecb81cf4de17");
var callBind = require("266fc50410cfc4a");
var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) return callBind(intrinsic);
    return intrinsic;
};

},{"8b08ecb81cf4de17":"dZb05","266fc50410cfc4a":"bfo8D"}],"dZb05":[function(require,module,exports) {
"use strict";
var undefined;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) try {
    $gOPD({}, "");
} catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
}
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = require("1f00f712d594ccf")();
var hasProto = require("23730654306aa64c")();
var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
    return x.__proto__;
} // eslint-disable-line no-proto
 : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    "%AsyncFromSyncIteratorPrototype%": undefined,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    "%JSON%": typeof JSON === "object" ? JSON : undefined,
    "%Map%": typeof Map === "undefined" ? undefined : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined,
    "%Symbol%": hasSymbols ? Symbol : undefined,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined : WeakSet
};
if (getProto) try {
    null.error; // eslint-disable-line no-unused-expressions
} catch (e) {
    // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
}
var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") value = getEvalledConstructor("async function () {}");
    else if (name === "%GeneratorFunction%") value = getEvalledConstructor("function* () {}");
    else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor("async function* () {}");
    else if (name === "%AsyncGenerator%") {
        var fn = doEval("%AsyncGeneratorFunction%");
        if (fn) value = fn.prototype;
    } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval("%AsyncGenerator%");
        if (gen && getProto) value = getProto(gen.prototype);
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": [
        "ArrayBuffer",
        "prototype"
    ],
    "%ArrayPrototype%": [
        "Array",
        "prototype"
    ],
    "%ArrayProto_entries%": [
        "Array",
        "prototype",
        "entries"
    ],
    "%ArrayProto_forEach%": [
        "Array",
        "prototype",
        "forEach"
    ],
    "%ArrayProto_keys%": [
        "Array",
        "prototype",
        "keys"
    ],
    "%ArrayProto_values%": [
        "Array",
        "prototype",
        "values"
    ],
    "%AsyncFunctionPrototype%": [
        "AsyncFunction",
        "prototype"
    ],
    "%AsyncGenerator%": [
        "AsyncGeneratorFunction",
        "prototype"
    ],
    "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%BooleanPrototype%": [
        "Boolean",
        "prototype"
    ],
    "%DataViewPrototype%": [
        "DataView",
        "prototype"
    ],
    "%DatePrototype%": [
        "Date",
        "prototype"
    ],
    "%ErrorPrototype%": [
        "Error",
        "prototype"
    ],
    "%EvalErrorPrototype%": [
        "EvalError",
        "prototype"
    ],
    "%Float32ArrayPrototype%": [
        "Float32Array",
        "prototype"
    ],
    "%Float64ArrayPrototype%": [
        "Float64Array",
        "prototype"
    ],
    "%FunctionPrototype%": [
        "Function",
        "prototype"
    ],
    "%Generator%": [
        "GeneratorFunction",
        "prototype"
    ],
    "%GeneratorPrototype%": [
        "GeneratorFunction",
        "prototype",
        "prototype"
    ],
    "%Int8ArrayPrototype%": [
        "Int8Array",
        "prototype"
    ],
    "%Int16ArrayPrototype%": [
        "Int16Array",
        "prototype"
    ],
    "%Int32ArrayPrototype%": [
        "Int32Array",
        "prototype"
    ],
    "%JSONParse%": [
        "JSON",
        "parse"
    ],
    "%JSONStringify%": [
        "JSON",
        "stringify"
    ],
    "%MapPrototype%": [
        "Map",
        "prototype"
    ],
    "%NumberPrototype%": [
        "Number",
        "prototype"
    ],
    "%ObjectPrototype%": [
        "Object",
        "prototype"
    ],
    "%ObjProto_toString%": [
        "Object",
        "prototype",
        "toString"
    ],
    "%ObjProto_valueOf%": [
        "Object",
        "prototype",
        "valueOf"
    ],
    "%PromisePrototype%": [
        "Promise",
        "prototype"
    ],
    "%PromiseProto_then%": [
        "Promise",
        "prototype",
        "then"
    ],
    "%Promise_all%": [
        "Promise",
        "all"
    ],
    "%Promise_reject%": [
        "Promise",
        "reject"
    ],
    "%Promise_resolve%": [
        "Promise",
        "resolve"
    ],
    "%RangeErrorPrototype%": [
        "RangeError",
        "prototype"
    ],
    "%ReferenceErrorPrototype%": [
        "ReferenceError",
        "prototype"
    ],
    "%RegExpPrototype%": [
        "RegExp",
        "prototype"
    ],
    "%SetPrototype%": [
        "Set",
        "prototype"
    ],
    "%SharedArrayBufferPrototype%": [
        "SharedArrayBuffer",
        "prototype"
    ],
    "%StringPrototype%": [
        "String",
        "prototype"
    ],
    "%SymbolPrototype%": [
        "Symbol",
        "prototype"
    ],
    "%SyntaxErrorPrototype%": [
        "SyntaxError",
        "prototype"
    ],
    "%TypedArrayPrototype%": [
        "TypedArray",
        "prototype"
    ],
    "%TypeErrorPrototype%": [
        "TypeError",
        "prototype"
    ],
    "%Uint8ArrayPrototype%": [
        "Uint8Array",
        "prototype"
    ],
    "%Uint8ClampedArrayPrototype%": [
        "Uint8ClampedArray",
        "prototype"
    ],
    "%Uint16ArrayPrototype%": [
        "Uint16Array",
        "prototype"
    ],
    "%Uint32ArrayPrototype%": [
        "Uint32Array",
        "prototype"
    ],
    "%URIErrorPrototype%": [
        "URIError",
        "prototype"
    ],
    "%WeakMapPrototype%": [
        "WeakMap",
        "prototype"
    ],
    "%WeakSetPrototype%": [
        "WeakSet",
        "prototype"
    ]
};
var bind = require("7c5e688e48cd07b0");
var hasOwn = require("b03d0058935d00bf");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    else if (last === "%" && first !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) value = doEval(intrinsicName);
        if (typeof value === "undefined" && !allowMissing) throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) throw new $TypeError("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError('"allowMissing" argument must be a boolean');
    if ($exec(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) throw new $SyntaxError("property names with quotes must have matching quotes");
        if (part === "constructor" || !isOwn) skipFurtherCaching = true;
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
        else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && "get" in desc && !("originalValue" in desc.get)) value = desc.get;
                else value = value[part];
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
        }
    }
    return value;
};

},{"1f00f712d594ccf":"3dK91","23730654306aa64c":"6eZiF","7c5e688e48cd07b0":"6J4ob","b03d0058935d00bf":"ksyoO"}],"3dK91":[function(require,module,exports) {
"use strict";
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = require("3fb25678c62d2fce");
module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") return false;
    if (typeof Symbol !== "function") return false;
    if (typeof origSymbol("foo") !== "symbol") return false;
    if (typeof Symbol("bar") !== "symbol") return false;
    return hasSymbolSham();
};

},{"3fb25678c62d2fce":"euYk7"}],"6eZiF":[function(require,module,exports) {
"use strict";
var test = {
    foo: {}
};
var $Object = Object;
module.exports = function hasProto() {
    return ({
        __proto__: test
    }).foo === test.foo && !(({
        __proto__: null
    }) instanceof $Object);
};

},{}],"6J4ob":[function(require,module,exports) {
"use strict";
var implementation = require("12e173b4dbaee960");
module.exports = Function.prototype.bind || implementation;

},{"12e173b4dbaee960":"jwaxQ"}],"jwaxQ":[function(require,module,exports) {
"use strict";
/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = "[object Function]";
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) return result;
            return this;
        } else return target.apply(that, args.concat(slice.call(arguments)));
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++)boundArgs.push("$" + i);
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};

},{}],"ksyoO":[function(require,module,exports) {
"use strict";
var bind = require("ec4f1e1d3f29fa3e");
module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"ec4f1e1d3f29fa3e":"6J4ob"}],"bfo8D":[function(require,module,exports) {
"use strict";
var bind = require("4f9d84d5de4909bc");
var GetIntrinsic = require("68d2ad3775278f43");
var $apply = GetIntrinsic("%Function.prototype.apply%");
var $call = GetIntrinsic("%Function.prototype.call%");
var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
var $max = GetIntrinsic("%Math.max%");
if ($defineProperty) try {
    $defineProperty({}, "a", {
        value: 1
    });
} catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = null;
}
module.exports = function callBind(originalFunction) {
    var func = $reflectApply(bind, $call, arguments);
    if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) // original length, plus the receiver, minus any additional arguments (after the receiver)
        $defineProperty(func, "length", {
            value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
        });
    }
    return func;
};
var applyBind = function applyBind() {
    return $reflectApply(bind, $apply, arguments);
};
if ($defineProperty) $defineProperty(module.exports, "apply", {
    value: applyBind
});
else module.exports.apply = applyBind;

},{"4f9d84d5de4909bc":"6J4ob","68d2ad3775278f43":"dZb05"}],"2XUdn":[function(require,module,exports) {
"use strict";
var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require("b42ab74c25dbb155")();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function() {
    if (!hasToStringTag) return false;
    try {
        return Function("return function*() {}")();
    } catch (e) {}
};
var GeneratorFunction;
module.exports = function isGeneratorFunction(fn) {
    if (typeof fn !== "function") return false;
    if (isFnRegex.test(fnToStr.call(fn))) return true;
    if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
    }
    if (!getProto) return false;
    if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
    }
    return getProto(fn) === GeneratorFunction;
};

},{"b42ab74c25dbb155":"9LdQ9"}],"lVUO7":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var forEach = require("2941d48f36957e3c");
var availableTypedArrays = require("beaf5502a5823cce");
var callBound = require("83f633f9b335db8f");
var gOPD = require("ce6b45c571ba4e3e");
var $toString = callBound("Object.prototype.toString");
var hasToStringTag = require("9e7ef6c88184c56")();
var g = typeof globalThis === "undefined" ? global : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound("String.prototype.slice");
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) forEach(typedArrays, function(typedArray) {
    if (typeof g[typedArray] === "function") {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
        }
    }
});
var tryTypedArrays = function tryAllTypedArrays(value) {
    var foundName = false;
    forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) try {
            var name = getter.call(value);
            if (name === typedArray) foundName = name;
        } catch (e) {}
    });
    return foundName;
};
var isTypedArray = require("41b5d056a91a2f13");
module.exports = function whichTypedArray(value) {
    if (!isTypedArray(value)) return false;
    if (!hasToStringTag || !(Symbol.toStringTag in value)) return $slice($toString(value), 8, -1);
    return tryTypedArrays(value);
};

},{"2941d48f36957e3c":"1Sol9","beaf5502a5823cce":"kfela","83f633f9b335db8f":"5yYiF","ce6b45c571ba4e3e":"eOTQB","9e7ef6c88184c56":"9LdQ9","41b5d056a91a2f13":"1ihkG"}],"1Sol9":[function(require,module,exports) {
"use strict";
var isCallable = require("e50ebc24bbb25feb");
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray(array, iterator, receiver) {
    for(var i = 0, len = array.length; i < len; i++)if (hasOwnProperty.call(array, i)) {
        if (receiver == null) iterator(array[i], i, array);
        else iterator.call(receiver, array[i], i, array);
    }
};
var forEachString = function forEachString(string, iterator, receiver) {
    for(var i = 0, len = string.length; i < len; i++)// no such thing as a sparse string.
    if (receiver == null) iterator(string.charAt(i), i, string);
    else iterator.call(receiver, string.charAt(i), i, string);
};
var forEachObject = function forEachObject(object, iterator, receiver) {
    for(var k in object)if (hasOwnProperty.call(object, k)) {
        if (receiver == null) iterator(object[k], k, object);
        else iterator.call(receiver, object[k], k, object);
    }
};
var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) throw new TypeError("iterator must be a function");
    var receiver;
    if (arguments.length >= 3) receiver = thisArg;
    if (toStr.call(list) === "[object Array]") forEachArray(list, iterator, receiver);
    else if (typeof list === "string") forEachString(list, iterator, receiver);
    else forEachObject(list, iterator, receiver);
};
module.exports = forEach;

},{"e50ebc24bbb25feb":"9ocyk"}],"9ocyk":[function(require,module,exports) {
"use strict";
var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") try {
    badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
            throw isCallableMarker;
        }
    });
    isCallableMarker = {};
    // eslint-disable-next-line no-throw-literal
    reflectApply(function() {
        throw 42;
    }, null, badArrayLike);
} catch (_) {
    if (_ !== isCallableMarker) reflectApply = null;
}
else reflectApply = null;
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
    try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
    } catch (e) {
        return false; // not a function
    }
};
var tryFunctionObject = function tryFunctionToStr(value) {
    try {
        if (isES6ClassFn(value)) return false;
        fnToStr.call(value);
        return true;
    } catch (e) {
        return false;
    }
};
var toStr = Object.prototype.toString;
var objectClass = "[object Object]";
var fnClass = "[object Function]";
var genClass = "[object GeneratorFunction]";
var ddaClass = "[object HTMLAllCollection]"; // IE 11
var ddaClass2 = "[object HTML document.all class]";
var ddaClass3 = "[object HTMLCollection]"; // IE 9-10
var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag; // better: use `has-tostringtag`
var isIE68 = !(0 in [
    , 
]); // eslint-disable-line no-sparse-arrays, comma-spacing
var isDDA = function isDocumentDotAll() {
    return false;
};
if (typeof document === "object") {
    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) isDDA = function isDocumentDotAll(value) {
        /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
             || str === objectClass // IE 6-8
            ) && value("") == null; // eslint-disable-line eqeqeq
        } catch (e) {}
        return false;
    };
}
module.exports = reflectApply ? function isCallable(value) {
    if (isDDA(value)) return true;
    if (!value) return false;
    if (typeof value !== "function" && typeof value !== "object") return false;
    try {
        reflectApply(value, null, badArrayLike);
    } catch (e) {
        if (e !== isCallableMarker) return false;
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable(value) {
    if (isDDA(value)) return true;
    if (!value) return false;
    if (typeof value !== "function" && typeof value !== "object") return false;
    if (hasToStringTag) return tryFunctionObject(value);
    if (isES6ClassFn(value)) return false;
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) return false;
    return tryFunctionObject(value);
};

},{}],"kfela":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var possibleNames = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
];
var g = typeof globalThis === "undefined" ? global : globalThis;
module.exports = function availableTypedArrays() {
    var out = [];
    for(var i = 0; i < possibleNames.length; i++)if (typeof g[possibleNames[i]] === "function") out[out.length] = possibleNames[i];
    return out;
};

},{}],"eOTQB":[function(require,module,exports) {
"use strict";
var GetIntrinsic = require("693e651525841e04");
var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) try {
    $gOPD([], "length");
} catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
}
module.exports = $gOPD;

},{"693e651525841e04":"dZb05"}],"1ihkG":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var forEach = require("68abe9b54a20c572");
var availableTypedArrays = require("aafd98fda33bbd57");
var callBound = require("a32527df8bf8b924");
var $toString = callBound("Object.prototype.toString");
var hasToStringTag = require("b3f7dbb937db3363")();
var gOPD = require("af60b1967ea134c8");
var g = typeof globalThis === "undefined" ? global : globalThis;
var typedArrays = availableTypedArrays();
var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for(var i = 0; i < array.length; i += 1){
        if (array[i] === value) return i;
    }
    return -1;
};
var $slice = callBound("String.prototype.slice");
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) forEach(typedArrays, function(typedArray) {
    var arr = new g[typedArray]();
    if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
    }
});
var tryTypedArrays = function tryAllTypedArrays(value) {
    var anyTrue = false;
    forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) try {
            anyTrue = getter.call(value) === typedArray;
        } catch (e) {}
    });
    return anyTrue;
};
module.exports = function isTypedArray(value) {
    if (!value || typeof value !== "object") return false;
    if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
    }
    if (!gOPD) return false;
    return tryTypedArrays(value);
};

},{"68abe9b54a20c572":"1Sol9","aafd98fda33bbd57":"kfela","a32527df8bf8b924":"5yYiF","b3f7dbb937db3363":"9LdQ9","af60b1967ea134c8":"eOTQB"}],"inNNy":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
};

},{}],"bRL3M":[function(require,module,exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"lQlQt":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
var process = require("228da2c254a5e871");
"use strict";
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
}
function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) _construct = Reflect.construct;
    else _construct = function _construct(Parent, args, Class) {
        var a = [
            null
        ];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
    };
    return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
var _require = require("9984e91d63ed614c"), inspect = _require.inspect;
var _require2 = require("1670766d7c5cef96"), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function repeat(str, count) {
    count = Math.floor(count);
    if (str.length == 0 || count == 0) return "";
    var maxCount = str.length * count;
    count = Math.floor(Math.log(count) / Math.log(2));
    while(count){
        str += str;
        count--;
    }
    str += str.substring(0, maxCount - str.length);
    return str;
}
var blue = "";
var green = "";
var red = "";
var white = "";
var kReadableOperator = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
}; // Comparing short primitives should just show === / !== instead of using the
// diff.
var kMaxShortLength = 10;
function copyError(source) {
    var keys = Object.keys(source);
    var target = Object.create(Object.getPrototypeOf(source));
    keys.forEach(function(key) {
        target[key] = source[key];
    });
    Object.defineProperty(target, "message", {
        value: source.message
    });
    return target;
}
function inspectValue(val) {
    // The util.inspect default values could be changed. This makes sure the
    // error messages contain the necessary information nevertheless.
    return inspect(val, {
        compact: false,
        customInspect: false,
        depth: 1000,
        maxArrayLength: Infinity,
        // Assert compares only enumerable properties (with a few exceptions).
        showHidden: false,
        // Having a long line as error is better than wrapping the line for
        // comparison for now.
        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
        // have meta information about the inspected properties (i.e., know where
        // in what line the property starts and ends).
        breakLength: Infinity,
        // Assert does not detect proxies currently.
        showProxy: false,
        sorted: true,
        // Inspect getters as we also check them when comparing entries.
        getters: true
    });
}
function createErrDiff(actual, expected, operator) {
    var other = "";
    var res = "";
    var lastPos = 0;
    var end = "";
    var skipped = false;
    var actualInspected = inspectValue(actual);
    var actualLines = actualInspected.split("\n");
    var expectedLines = inspectValue(expected).split("\n");
    var i = 0;
    var indicator = ""; // In case both values are objects explicitly mark them as not reference equal
    // for the `strictEqual` operator.
    if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) operator = "strictEqualObject";
     // If "actual" and "expected" fit on a single line and they are not strictly
    // equal, check further special handling.
    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
        // kMaxShortLength and if neither is an object and at least one of them is
        // not `zero`, use the strict equal comparison to visualize the output.
        if (inputLength <= kMaxShortLength) {
            if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) // -0 === +0
            return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
        } else if (operator !== "strictEqualObject") {
            // If the stderr is a tty and the input length is lower than the current
            // columns per line, add a mismatch indicator below the output. If it is
            // not a tty, use a default value of 80 characters.
            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
            if (inputLength < maxLength) {
                while(actualLines[0][i] === expectedLines[0][i])i++;
                 // Ignore the first characters.
                if (i > 2) {
                    // Add position indicator for the first mismatch in case it is a
                    // single line and the input length is less than the column length.
                    indicator = "\n  ".concat(repeat(" ", i), "^");
                    i = 0;
                }
            }
        }
    } // Remove all ending lines that match (this optimizes the output for
    // readability by reducing the number of total changed lines).
    var a = actualLines[actualLines.length - 1];
    var b = expectedLines[expectedLines.length - 1];
    while(a === b){
        if (i++ < 2) end = "\n  ".concat(a).concat(end);
        else other = a;
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0) break;
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
    }
    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
    if (maxLines === 0) {
        // We have to get the result again. The lines were all removed before.
        var _actualLines = actualInspected.split("\n"); // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (_actualLines.length > 30) {
            _actualLines[26] = "".concat(blue, "...").concat(white);
            while(_actualLines.length > 27)_actualLines.pop();
        }
        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
    }
    if (i > 3) {
        end = "\n".concat(blue, "...").concat(white).concat(end);
        skipped = true;
    }
    if (other !== "") {
        end = "\n  ".concat(other).concat(end);
        other = "";
    }
    var printedLines = 0;
    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
    for(i = 0; i < maxLines; i++){
        // Only extra expected lines exist
        var cur = i - lastPos;
        if (actualLines.length < i + 1) {
            // If the last diverging line is more than one line above and the
            // current line is at least line three, add some of the former lines and
            // also add dots to indicate skipped entries.
            if (cur > 1 && i > 2) {
                if (cur > 4) {
                    res += "\n".concat(blue, "...").concat(white);
                    skipped = true;
                } else if (cur > 3) {
                    res += "\n  ".concat(expectedLines[i - 2]);
                    printedLines++;
                }
                res += "\n  ".concat(expectedLines[i - 1]);
                printedLines++;
            } // Mark the current line as the last diverging one.
            lastPos = i; // Add the expected line to the cache.
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
            printedLines++; // Only extra actual lines exist
        } else if (expectedLines.length < i + 1) {
            // If the last diverging line is more than one line above and the
            // current line is at least line three, add some of the former lines and
            // also add dots to indicate skipped entries.
            if (cur > 1 && i > 2) {
                if (cur > 4) {
                    res += "\n".concat(blue, "...").concat(white);
                    skipped = true;
                } else if (cur > 3) {
                    res += "\n  ".concat(actualLines[i - 2]);
                    printedLines++;
                }
                res += "\n  ".concat(actualLines[i - 1]);
                printedLines++;
            } // Mark the current line as the last diverging one.
            lastPos = i; // Add the actual line to the result.
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
            printedLines++; // Lines diverge
        } else {
            var expectedLine = expectedLines[i];
            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
            // a trailing comma. In that case it is actually identical and we should
            // mark it as such.
            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
            // add a comma at the end of the actual line. Otherwise the output could
            // look weird as in:
            //
            //   [
            //     1         // No comma at the end!
            // +   2
            //   ]
            //
            if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
                divergingLines = false;
                actualLine += ",";
            }
            if (divergingLines) {
                // If the last diverging line is more than one line above and the
                // current line is at least line three, add some of the former lines and
                // also add dots to indicate skipped entries.
                if (cur > 1 && i > 2) {
                    if (cur > 4) {
                        res += "\n".concat(blue, "...").concat(white);
                        skipped = true;
                    } else if (cur > 3) {
                        res += "\n  ".concat(actualLines[i - 2]);
                        printedLines++;
                    }
                    res += "\n  ".concat(actualLines[i - 1]);
                    printedLines++;
                } // Mark the current line as the last diverging one.
                lastPos = i; // Add the actual line to the result and cache the expected diverging
                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                printedLines += 2; // Lines are identical
            } else {
                // Add all cached information to the result before adding other things
                // and reset the cache.
                res += other;
                other = ""; // If the last diverging line is exactly one line above or if it is the
                // very first line, add the line to the result.
                if (cur === 1 || i === 0) {
                    res += "\n  ".concat(actualLine);
                    printedLines++;
                }
            }
        } // Inspected object to big (Show ~20 rows max)
        if (printedLines > 20 && i < maxLines - 2) return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
    return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError = /*#__PURE__*/ function(_Error) {
    _inherits(AssertionError, _Error);
    function AssertionError(options) {
        var _this;
        _classCallCheck(this, AssertionError);
        if (_typeof(options) !== "object" || options === null) throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
        var actual = options.actual, expected = options.expected;
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        if (message != null) _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
        else {
            if (process.stderr && process.stderr.isTTY) {
                // Reset on each call to make sure we handle dynamically set environment
                // variables correct.
                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                    blue = "\x1b[34m";
                    green = "\x1b[32m";
                    white = "\x1b[39m";
                    red = "\x1b[31m";
                } else {
                    blue = "";
                    green = "";
                    white = "";
                    red = "";
                }
            } // Prevent the error stack from being visible by duplicating the error
            // in a very close way to the original in case both sides are actually
            // instances of Error.
            if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
                actual = copyError(actual);
                expected = copyError(expected);
            }
            if (operator === "deepStrictEqual" || operator === "strictEqual") _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
            else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
                // In case the objects are equal but the operator requires unequal, show
                // the first object and say A equals B
                var base = kReadableOperator[operator];
                var res = inspectValue(actual).split("\n"); // In case "actual" is an object, it should not be reference equal.
                if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) base = kReadableOperator.notStrictEqualObject;
                 // Only remove lines in case it makes sense to collapse those.
                // TODO: Accept env to always show the full error.
                if (res.length > 30) {
                    res[26] = "".concat(blue, "...").concat(white);
                    while(res.length > 27)res.pop();
                } // Only print a single input.
                if (res.length === 1) _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                else _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
            } else {
                var _res = inspectValue(actual);
                var other = "";
                var knownOperators = kReadableOperator[operator];
                if (operator === "notDeepEqual" || operator === "notEqual") {
                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                    if (_res.length > 1024) _res = "".concat(_res.slice(0, 1021), "...");
                } else {
                    other = "".concat(inspectValue(expected));
                    if (_res.length > 512) _res = "".concat(_res.slice(0, 509), "...");
                    if (other.length > 512) other = "".concat(other.slice(0, 509), "...");
                    if (operator === "deepEqual" || operator === "equal") _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                    else other = " ".concat(operator, " ").concat(other);
                }
                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
            }
        }
        Error.stackTraceLimit = limit;
        _this.generatedMessage = !message;
        Object.defineProperty(_assertThisInitialized(_this), "name", {
            value: "AssertionError [ERR_ASSERTION]",
            enumerable: false,
            writable: true,
            configurable: true
        });
        _this.code = "ERR_ASSERTION";
        _this.actual = actual;
        _this.expected = expected;
        _this.operator = operator;
        if (Error.captureStackTrace) // eslint-disable-next-line no-restricted-syntax
        Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
         // Create error message including the error code in the name.
        _this.stack; // Reset the name.
        _this.name = "AssertionError";
        return _possibleConstructorReturn(_this);
    }
    _createClass(AssertionError, [
        {
            key: "toString",
            value: function toString() {
                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
            }
        },
        {
            key: inspect.custom,
            value: function value(recurseTimes, ctx) {
                // This limits the `actual` and `expected` property default inspection to
                // the minimum depth. Otherwise those values would be too verbose compared
                // to the actual error message which contains a combined view of these two
                // input values.
                return inspect(this, _objectSpread({}, ctx, {
                    customInspect: false,
                    depth: 0
                }));
            }
        }
    ]);
    return AssertionError;
}(_wrapNativeSuper(Error));
module.exports = AssertionError;

},{"228da2c254a5e871":"d5jf4","9984e91d63ed614c":"cxohQ","1670766d7c5cef96":"cwQVR"}],"713SE":[function(require,module,exports) {
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ "use strict";
function assign(target, firstSource) {
    if (target === undefined || target === null) throw new TypeError("Cannot convert first argument to object");
    var to = Object(target);
    for(var i = 1; i < arguments.length; i++){
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) continue;
        var keysArray = Object.keys(Object(nextSource));
        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== undefined && desc.enumerable) to[nextKey] = nextSource[nextKey];
        }
    }
    return to;
}
function polyfill() {
    if (!Object.assign) Object.defineProperty(Object, "assign", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: assign
    });
}
module.exports = {
    assign: assign,
    polyfill: polyfill
};

},{}],"k2tpA":[function(require,module,exports) {
"use strict";
var define = require("7a0bb7df335a6af");
var callBind = require("794ce1103c4a65ba");
var implementation = require("f52a71fcf365d3bd");
var getPolyfill = require("59addbaef079e040");
var shim = require("c0e8b0f7342ba484");
var polyfill = callBind(getPolyfill(), Object);
define(polyfill, {
    getPolyfill: getPolyfill,
    implementation: implementation,
    shim: shim
});
module.exports = polyfill;

},{"7a0bb7df335a6af":"6eq5U","794ce1103c4a65ba":"bfo8D","f52a71fcf365d3bd":"WLxcH","59addbaef079e040":"ezjA5","c0e8b0f7342ba484":"9p2yJ"}],"6eq5U":[function(require,module,exports) {
"use strict";
var keys = require("7ff177585d1618f0");
var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction = function(fn) {
    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
};
var hasPropertyDescriptors = require("c52d62086511583f")();
var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
var defineProperty = function(object, name, value, predicate) {
    if (name in object) {
        if (predicate === true) {
            if (object[name] === value) return;
        } else if (!isFunction(predicate) || !predicate()) return;
    }
    if (supportsDescriptors) origDefineProperty(object, name, {
        configurable: true,
        enumerable: false,
        value: value,
        writable: true
    });
    else object[name] = value; // eslint-disable-line no-param-reassign
};
var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys(map);
    if (hasSymbols) props = concat.call(props, Object.getOwnPropertySymbols(map));
    for(var i = 0; i < props.length; i += 1)defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

},{"7ff177585d1618f0":"eNyf4","c52d62086511583f":"esBLZ"}],"eNyf4":[function(require,module,exports) {
"use strict";
var slice = Array.prototype.slice;
var isArgs = require("93e8460f624c96f4");
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
} : require("344bb0d7b2568e03");
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
        var keysWorksWithArguments = function() {
            // Safari 5.0 bug
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) Object.keys = function keys(object) {
            if (isArgs(object)) return originalKeys(slice.call(object));
            return originalKeys(object);
        };
    } else Object.keys = keysShim;
    return Object.keys || keysShim;
};
module.exports = keysShim;

},{"93e8460f624c96f4":"1HhOq","344bb0d7b2568e03":"aV01q"}],"1HhOq":[function(require,module,exports) {
"use strict";
var toStr = Object.prototype.toString;
module.exports = function isArguments(value) {
    var str = toStr.call(value);
    var isArgs = str === "[object Arguments]";
    if (!isArgs) isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    return isArgs;
};

},{}],"aV01q":[function(require,module,exports) {
"use strict";
var keysShim;
if (!Object.keys) {
    // modified from https://github.com/es-shims/es5-shim
    var has = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var isArgs = require("b0d8c8b84be91ffd"); // eslint-disable-line global-require
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({
        toString: null
    }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {}, "prototype");
    var dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
    };
    var hasAutomationEqualityBug = function() {
        /* global window */ if (typeof window === "undefined") return false;
        for(var k in window)try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") try {
                equalsConstructorPrototype(window[k]);
            } catch (e) {
                return true;
            }
        } catch (e) {
            return true;
        }
        return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
        /* global window */ if (typeof window === "undefined" || !hasAutomationEqualityBug) return equalsConstructorPrototype(o);
        try {
            return equalsConstructorPrototype(o);
        } catch (e) {
            return false;
        }
    };
    keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) throw new TypeError("Object.keys called on a non-object");
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) for(var i = 0; i < object.length; ++i)theKeys.push(String(i));
        if (isArguments && object.length > 0) for(var j = 0; j < object.length; ++j)theKeys.push(String(j));
        else {
            for(var name in object)if (!(skipProto && name === "prototype") && has.call(object, name)) theKeys.push(String(name));
        }
        if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for(var k = 0; k < dontEnums.length; ++k)if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) theKeys.push(dontEnums[k]);
        }
        return theKeys;
    };
}
module.exports = keysShim;

},{"b0d8c8b84be91ffd":"1HhOq"}],"esBLZ":[function(require,module,exports) {
"use strict";
var GetIntrinsic = require("b0bf8b8435d3abc");
var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
var hasPropertyDescriptors = function hasPropertyDescriptors() {
    if ($defineProperty) try {
        $defineProperty({}, "a", {
            value: 1
        });
        return true;
    } catch (e) {
        // IE 8 has a broken defineProperty
        return false;
    }
    return false;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    // node v0.6 has a bug where array lengths can be Set but not Defined
    if (!hasPropertyDescriptors()) return null;
    try {
        return $defineProperty([], "length", {
            value: 1
        }).length !== 1;
    } catch (e) {
        // In Firefox 4-22, defining length on an array throws an exception.
        return true;
    }
};
module.exports = hasPropertyDescriptors;

},{"b0bf8b8435d3abc":"dZb05"}],"WLxcH":[function(require,module,exports) {
"use strict";
var numberIsNaN = function(value) {
    return value !== value;
};
module.exports = function is(a, b) {
    if (a === 0 && b === 0) return 1 / a === 1 / b;
    if (a === b) return true;
    if (numberIsNaN(a) && numberIsNaN(b)) return true;
    return false;
};

},{}],"ezjA5":[function(require,module,exports) {
"use strict";
var implementation = require("ff80ab827617d6fd");
module.exports = function getPolyfill() {
    return typeof Object.is === "function" ? Object.is : implementation;
};

},{"ff80ab827617d6fd":"WLxcH"}],"9p2yJ":[function(require,module,exports) {
"use strict";
var getPolyfill = require("f188d636391a5061");
var define = require("155865cffc557cd");
module.exports = function shimObjectIs() {
    var polyfill = getPolyfill();
    define(Object, {
        is: polyfill
    }, {
        is: function testObjectIs() {
            return Object.is !== polyfill;
        }
    });
    return polyfill;
};

},{"f188d636391a5061":"ezjA5","155865cffc557cd":"6eq5U"}],"d5TM9":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
"use strict";
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
    var array = [];
    set.forEach(function(value) {
        return array.push(value);
    });
    return array;
};
var arrayFromMap = function arrayFromMap(map) {
    var array = [];
    map.forEach(function(value, key) {
        return array.push([
            key,
            value
        ]);
    });
    return array;
};
var objectIs = Object.is ? Object.is : require("3addb16fbdd05c1c");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : require("a27e57a3fd2e2e23");
function uncurryThis(f) {
    return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = require("4940125679601087").types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
    if (key.length === 0 || key.length > 10) return true;
    for(var i = 0; i < key.length; i++){
        var code = key.charCodeAt(i);
        if (code < 48 || code > 57) return true;
    } // The maximum size for an array is 2 ** 32 -1.
    return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3; // Check if they have the same source and flags
function areSimilarRegExps(a, b) {
    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
    if (a.byteLength !== b.byteLength) return false;
    for(var offset = 0; offset < a.byteLength; offset++){
        if (a[offset] !== b[offset]) return false;
    }
    return true;
}
function areSimilarTypedArrays(a, b) {
    if (a.byteLength !== b.byteLength) return false;
    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
    if (isNumberObject(val1)) return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
    if (isStringObject(val1)) return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
    if (isBooleanObject(val1)) return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
    if (isBigIntObject(val1)) return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.
function innerDeepEqual(val1, val2, strict, memos) {
    // All identical values are equivalent, as determined by ===.
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? objectIs(val1, val2) : true;
    } // Check more closely if val1 and val2 are equal.
    if (strict) {
        if (_typeof(val1) !== "object") return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
        if (_typeof(val2) !== "object" || val1 === null || val2 === null) return false;
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) return false;
    } else {
        if (val1 === null || _typeof(val1) !== "object") {
            if (val2 === null || _typeof(val2) !== "object") // eslint-disable-next-line eqeqeq
            return val1 == val2;
            return false;
        }
        if (val2 === null || _typeof(val2) !== "object") return false;
    }
    var val1Tag = objectToString(val1);
    var val2Tag = objectToString(val2);
    if (val1Tag !== val2Tag) return false;
    if (Array.isArray(val1)) {
        // Check for sparse arrays and general fast path
        if (val1.length !== val2.length) return false;
        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (keys1.length !== keys2.length) return false;
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
    // wan't to early return out of the rest of the checks. However we can check
    // if the second value is one of these values and the first isn't.
    if (val1Tag === "[object Object]") {
        // return keyCheck(val1, val2, strict, memos, kNoIterator);
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) return false;
    }
    if (isDate(val1)) {
        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) return false;
    } else if (isRegExp(val1)) {
        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) return false;
    } else if (isNativeError(val1) || val1 instanceof Error) {
        // Do not compare the stack as it might differ even though the error itself
        // is otherwise identical.
        if (val1.message !== val2.message || val1.name !== val2.name) return false;
    } else if (isArrayBufferView(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) return false;
        } else if (!areSimilarTypedArrays(val1, val2)) return false;
         // Buffer.compare returns true, so val1.length === val2.length. If they both
        // only contain numeric keys, we don't need to exam further than checking
        // the symbols.
        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (_keys.length !== _keys2.length) return false;
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
    } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) return false;
        return keyCheck(val1, val2, strict, memos, kIsSet);
    } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) return false;
        return keyCheck(val1, val2, strict, memos, kIsMap);
    } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2)) return false;
    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) return false;
    return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
    return keys.filter(function(k) {
        return propertyIsEnumerable(val, k);
    });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
    // For all remaining Object pairs, including Array, objects and Maps,
    // equivalence is determined by having:
    // a) The same number of owned enumerable properties
    // b) The same set of keys/indexes (although not necessarily the same order)
    // c) Equivalent values for every corresponding key/index
    // d) For Sets and Maps, equal contents
    // Note: this accounts for both named and indexed properties on Arrays.
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
        if (aKeys.length !== bKeys.length) return false;
    } // Cheap key test
    var i = 0;
    for(; i < aKeys.length; i++){
        if (!hasOwnProperty(val2, aKeys[i])) return false;
    }
    if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            var count = 0;
            for(i = 0; i < symbolKeysA.length; i++){
                var key = symbolKeysA[i];
                if (propertyIsEnumerable(val1, key)) {
                    if (!propertyIsEnumerable(val2, key)) return false;
                    aKeys.push(key);
                    count++;
                } else if (propertyIsEnumerable(val2, key)) return false;
            }
            var symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) return false;
        } else {
            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) return false;
        }
    }
    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) return true;
     // Use memos to handle cycles.
    if (memos === undefined) memos = {
        val1: new Map(),
        val2: new Map(),
        position: 0
    };
    else {
        // We prevent up to two map.has(x) calls by directly retrieving the value
        // and checking for undefined. The map can only contain numbers, so it is
        // safe to check for undefined only.
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            var val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) return val2MemoA === val2MemoB;
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
    // Go looking.
    var setValues = arrayFromSet(set);
    for(var i = 0; i < setValues.length; i++){
        var val2 = setValues[i];
        if (innerDeepEqual(val1, val2, strict, memo)) {
            // Remove the matching element to make sure we do not check that again.
            set.delete(val2);
            return true;
        }
    }
    return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function findLooseMatchingPrimitives(prim) {
    switch(_typeof(prim)){
        case "undefined":
            return null;
        case "object":
            // Only pass in null as object!
            return undefined;
        case "symbol":
            return false;
        case "string":
            prim = +prim;
        // Loose equal entries exist only if the string is possible to convert to
        // a regular number and not NaN.
        // Fall through
        case "number":
            if (numberIsNaN(prim)) return false;
    }
    return true;
}
function setMightHaveLoosePrim(a, b, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) return altValue;
    return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) return altValue;
    var curB = b.get(altValue);
    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) return false;
    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
    // This is a lazily initiated Set of entries which have to be compared
    // pairwise.
    var set = null;
    var aValues = arrayFromSet(a);
    for(var i = 0; i < aValues.length; i++){
        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
        // heavy sets but it is a minor slow down for primitives. As they are fast
        // to check this improves the worst case scenario instead.
        if (_typeof(val) === "object" && val !== null) {
            if (set === null) set = new Set();
             // If the specified value doesn't exist in the second set its an not null
            // object (or non strict only: a not matching primitive) we'll need to go
            // hunting for something thats deep-(strict-)equal to it. To make this
            // O(n log n) complexity we have to copy these values in a new set first.
            set.add(val);
        } else if (!b.has(val)) {
            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
            if (!setMightHaveLoosePrim(a, b, val)) return false;
            if (set === null) set = new Set();
            set.add(val);
        }
    }
    if (set !== null) {
        var bValues = arrayFromSet(b);
        for(var _i = 0; _i < bValues.length; _i++){
            var _val = bValues[_i]; // We have to check if a primitive value is already
            // matching and only if it's not, go hunting for it.
            if (_typeof(_val) === "object" && _val !== null) {
                if (!setHasEqualElement(set, _val, strict, memo)) return false;
            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) return false;
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
    // To be able to handle cases like:
    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
    // ... we need to consider *all* matching keys, not just the first we find.
    var setValues = arrayFromSet(set);
    for(var i = 0; i < setValues.length; i++){
        var key2 = setValues[i];
        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
function mapEquiv(a, b, strict, memo) {
    var set = null;
    var aEntries = arrayFromMap(a);
    for(var i = 0; i < aEntries.length; i++){
        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof(key) === "object" && key !== null) {
            if (set === null) set = new Set();
            set.add(key);
        } else {
            // By directly retrieving the value we prevent another b.has(key) check in
            // almost all possible cases.
            var item2 = b.get(key);
            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                // keys.
                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                if (set === null) set = new Set();
                set.add(key);
            }
        }
    }
    if (set !== null) {
        var bEntries = arrayFromMap(b);
        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
            if (_typeof(key) === "object" && key !== null) {
                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) return false;
        }
        return set.size === 0;
    }
    return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
    // Sets and maps don't have their entries accessible via normal object
    // properties.
    var i = 0;
    if (iterationType === kIsSet) {
        if (!setEquiv(a, b, strict, memos)) return false;
    } else if (iterationType === kIsMap) {
        if (!mapEquiv(a, b, strict, memos)) return false;
    } else if (iterationType === kIsArray) for(; i < a.length; i++){
        if (hasOwnProperty(a, i)) {
            if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) return false;
        } else if (hasOwnProperty(b, i)) return false;
        else {
            // Array is sparse.
            var keysA = Object.keys(a);
            for(; i < keysA.length; i++){
                var key = keysA[i];
                if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) return false;
            }
            if (keysA.length !== Object.keys(b).length) return false;
            return true;
        }
    }
     // The pair must have equivalent values for every corresponding key.
    // Possibly expensive deep test:
    for(i = 0; i < keys.length; i++){
        var _key = keys[i];
        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) return false;
    }
    return true;
}
function isDeepEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
    isDeepEqual: isDeepEqual,
    isDeepStrictEqual: isDeepStrictEqual
};

},{"3addb16fbdd05c1c":"k2tpA","a27e57a3fd2e2e23":"hY4fH","4940125679601087":"cxohQ"}],"hY4fH":[function(require,module,exports) {
"use strict";
var callBind = require("8bc778ead6edc2b");
var define = require("1e9a111647ec40d6");
var implementation = require("db9e8266e38a0a1c");
var getPolyfill = require("37ae20d268339d21");
var shim = require("9fe13ad91d3d9c68");
var polyfill = callBind(getPolyfill(), Number);
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define(polyfill, {
    getPolyfill: getPolyfill,
    implementation: implementation,
    shim: shim
});
module.exports = polyfill;

},{"8bc778ead6edc2b":"bfo8D","1e9a111647ec40d6":"6eq5U","db9e8266e38a0a1c":"lxsrq","37ae20d268339d21":"h00Nr","9fe13ad91d3d9c68":"cr2es"}],"lxsrq":[function(require,module,exports) {
"use strict";
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module.exports = function isNaN(value) {
    return value !== value;
};

},{}],"h00Nr":[function(require,module,exports) {
"use strict";
var implementation = require("e25466f067cfd8fc");
module.exports = function getPolyfill() {
    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) return Number.isNaN;
    return implementation;
};

},{"e25466f067cfd8fc":"lxsrq"}],"cr2es":[function(require,module,exports) {
"use strict";
var define = require("6e613ddb8bace1c6");
var getPolyfill = require("f2ce5ac0488eb372");
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module.exports = function shimNumberIsNaN() {
    var polyfill = getPolyfill();
    define(Number, {
        isNaN: polyfill
    }, {
        isNaN: function testIsNaN() {
            return Number.isNaN !== polyfill;
        }
    });
    return polyfill;
};

},{"6e613ddb8bace1c6":"6eq5U","f2ce5ac0488eb372":"h00Nr"}],"8v6kX":[function(require,module,exports) {
"use strict";
var acorn = require("c09e047f4d1f8604");
var objectAssign = require("bbfbc13cd26ac6af");
module.exports = isExpression;
var DEFAULT_OPTIONS = {
    throw: false,
    strict: false,
    lineComment: false
};
function isExpression(src, options) {
    options = objectAssign({}, DEFAULT_OPTIONS, options);
    try {
        var parser = new acorn.Parser(options, src, 0);
        if (options.strict) parser.strict = true;
        if (!options.lineComment) parser.skipLineComment = function(startSkip) {
            this.raise(this.pos, "Line comments not allowed in an expression");
        };
        parser.nextToken();
        parser.parseExpression();
        if (parser.type !== acorn.tokTypes.eof) parser.unexpected();
    } catch (ex) {
        if (!options.throw) return false;
        throw ex;
    }
    return true;
}

},{"c09e047f4d1f8604":"h2wbx","bbfbc13cd26ac6af":"7OXxh"}],"h2wbx":[function(require,module,exports) {
// Reserved word lists for various dialects of the language
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Node", ()=>Node);
parcelHelpers.export(exports, "Parser", ()=>Parser);
parcelHelpers.export(exports, "Position", ()=>Position);
parcelHelpers.export(exports, "SourceLocation", ()=>SourceLocation);
parcelHelpers.export(exports, "TokContext", ()=>TokContext);
parcelHelpers.export(exports, "Token", ()=>Token);
parcelHelpers.export(exports, "TokenType", ()=>TokenType);
parcelHelpers.export(exports, "defaultOptions", ()=>defaultOptions);
parcelHelpers.export(exports, "getLineInfo", ()=>getLineInfo);
parcelHelpers.export(exports, "isIdentifierChar", ()=>isIdentifierChar);
parcelHelpers.export(exports, "isIdentifierStart", ()=>isIdentifierStart);
parcelHelpers.export(exports, "isNewLine", ()=>isNewLine);
parcelHelpers.export(exports, "keywordTypes", ()=>keywords$1);
parcelHelpers.export(exports, "lineBreak", ()=>lineBreak);
parcelHelpers.export(exports, "lineBreakG", ()=>lineBreakG);
parcelHelpers.export(exports, "nonASCIIwhitespace", ()=>nonASCIIwhitespace);
parcelHelpers.export(exports, "parse", ()=>parse);
parcelHelpers.export(exports, "parseExpressionAt", ()=>parseExpressionAt);
parcelHelpers.export(exports, "tokContexts", ()=>types$1);
parcelHelpers.export(exports, "tokTypes", ()=>types);
parcelHelpers.export(exports, "tokenizer", ()=>tokenizer);
parcelHelpers.export(exports, "version", ()=>version);
var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
};
// And the keywords
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
// ## Character categories
// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var nonASCIIidentifierChars = "‌‍\xb7̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js
// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    157,
    310,
    10,
    21,
    11,
    7,
    153,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    349,
    41,
    7,
    1,
    79,
    28,
    11,
    0,
    9,
    21,
    107,
    20,
    28,
    22,
    13,
    52,
    76,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    85,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    230,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    35,
    56,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    190,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2749,
    1070,
    4050,
    582,
    8634,
    568,
    8,
    30,
    114,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    689,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    43,
    8,
    8952,
    286,
    50,
    2,
    18,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    2357,
    44,
    11,
    6,
    17,
    0,
    370,
    43,
    1301,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42717,
    35,
    4148,
    12,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
    1507,
    4938
];
// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    370,
    1,
    154,
    10,
    176,
    2,
    54,
    14,
    32,
    9,
    16,
    3,
    46,
    10,
    54,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    161,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    19306,
    9,
    135,
    4,
    60,
    6,
    26,
    9,
    1014,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    5319,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    262,
    6,
    10,
    9,
    419,
    13,
    1495,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
];
// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
    var pos = 0x10000;
    for(var i = 0; i < set.length; i += 2){
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
    }
}
// Test whether a given character code starts an identifier.
function isIdentifierStart(code, astral) {
    if (code < 65) return code === 36;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    if (astral === false) return false;
    return isInAstralSet(code, astralIdentifierStartCodes);
}
// Test whether a given character is part of an identifier.
function isIdentifierChar(code, astral) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    if (astral === false) return false;
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
// ## Token types
// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.
// All token type variables start with an underscore, to make them
// easy to recognize.
// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.
var TokenType = function TokenType(label, conf) {
    if (conf === void 0) conf = {};
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
};
function binop(name, prec) {
    return new TokenType(name, {
        beforeExpr: true,
        binop: prec
    });
}
var beforeExpr = {
    beforeExpr: true
}, startsExpr = {
    startsExpr: true
};
// Map keyword names to token types.
var keywords$1 = {};
// Succinct definitions of keyword token types
function kw(name, options) {
    if (options === void 0) options = {};
    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options);
}
var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),
    // Punctuation token types.
    bracketL: new TokenType("[", {
        beforeExpr: true,
        startsExpr: true
    }),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {
        beforeExpr: true,
        startsExpr: true
    }),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {
        beforeExpr: true,
        startsExpr: true
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {
        beforeExpr: true,
        startsExpr: true
    }),
    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.
    eq: new TokenType("=", {
        beforeExpr: true,
        isAssign: true
    }),
    assign: new TokenType("_=", {
        beforeExpr: true,
        isAssign: true
    }),
    incDec: new TokenType("++/--", {
        prefix: true,
        postfix: true,
        startsExpr: true
    }),
    prefix: new TokenType("!/~", {
        beforeExpr: true,
        prefix: true,
        startsExpr: true
    }),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
        beforeExpr: true,
        binop: 9,
        prefix: true,
        startsExpr: true
    }),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {
        beforeExpr: true
    }),
    coalesce: binop("??", 1),
    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {
        isLoop: true,
        beforeExpr: true
    }),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {
        isLoop: true
    }),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {
        isLoop: true
    }),
    _with: kw("with"),
    _new: kw("new", {
        beforeExpr: true,
        startsExpr: true
    }),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {
        beforeExpr: true,
        binop: 7
    }),
    _instanceof: kw("instanceof", {
        beforeExpr: true,
        binop: 7
    }),
    _typeof: kw("typeof", {
        beforeExpr: true,
        prefix: true,
        startsExpr: true
    }),
    _void: kw("void", {
        beforeExpr: true,
        prefix: true,
        startsExpr: true
    }),
    _delete: kw("delete", {
        beforeExpr: true,
        prefix: true,
        startsExpr: true
    })
};
// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || !ecma2019String && (code === 0x2028 || code === 0x2029);
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
// Checks if an object has a property.
function has(obj, propName) {
    return hasOwnProperty.call(obj, propName);
}
var isArray = Array.isArray || function(obj) {
    return toString.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.
var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
};
Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
};
var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) this.source = p.sourceFile;
};
// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.
function getLineInfo(input, offset) {
    for(var line = 1, cur = 0;;){
        lineBreakG.lastIndex = cur;
        var match = lineBreakG.exec(input);
        if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
        } else return new Position(line, offset - cur);
    }
}
// A second optional argument can be given to further configure
// the parser process. These options are recognized:
var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
    // (2019). This influences support for strict mode, the set of
    // reserved words, and support for new syntax features. The default
    // is 10.
    ecmaVersion: 10,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called
    // when a semicolon is automatically inserted. It will be passed
    // the position of the comma as an offset, and if `locations` is
    // enabled, it is given the location as a `{line, column}` object
    // as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program.
    allowImportExportEverywhere: false,
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: false,
    // When enabled, hashbang directive in the beginning of file
    // is allowed and treated as a line comment.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callback—that will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
};
// Interpret and default an options object
function getOptions(opts) {
    var options = {};
    for(var opt in defaultOptions)options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
    if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;
    if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
    if (isArray(options.onToken)) {
        var tokens = options.onToken;
        options.onToken = function(token) {
            return tokens.push(token);
        };
    }
    if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
    return options;
}
function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start: start,
            end: end
        };
        if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
        if (options.ranges) comment.range = [
            start,
            end
        ];
        array.push(comment);
    };
}
// Each scope gets a bitset that may contain these flags
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128;
function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
// Used in checkLVal and declareName to determine the type of a binding
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function
var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
        for(var v = options.ecmaVersion;; v--){
            if (reserved = reservedWords[v]) break;
        }
        if (options.sourceType === "module") reserved += " await";
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);
    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;
    // Set up token state
    // The current position of the tokenizer in the input.
    if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
    }
    // Properties of the current token:
    // Its type
    this.type = types.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();
    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;
    // Figure out if it's a module code.
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);
    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;
    // Positions to delayed-check that yield/await does not exist in default parameters.
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    // Labels in scope.
    this.labels = [];
    // Thus-far undefined exports.
    this.undefinedExports = {};
    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
    // Scope tracking for duplicate variable names (see scope.js)
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);
    // For RegExp validation
    this.regexpState = null;
};
var prototypeAccessors = {
    inFunction: {
        configurable: true
    },
    inGenerator: {
        configurable: true
    },
    inAsync: {
        configurable: true
    },
    allowSuper: {
        configurable: true
    },
    allowDirectSuper: {
        configurable: true
    },
    treatFunctionsAsVar: {
        configurable: true
    }
};
Parser.prototype.parse = function parse() {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.allowSuper.get = function() {
    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
};
prototypeAccessors.allowDirectSuper.get = function() {
    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
};
// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction() {
    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
};
Parser.extend = function extend() {
    var plugins = [], len = arguments.length;
    while(len--)plugins[len] = arguments[len];
    var cls = this;
    for(var i = 0; i < plugins.length; i++)cls = plugins[i](cls);
    return cls;
};
Parser.parse = function parse(input, options) {
    return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
    return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp = Parser.prototype;
// ## Parser utilities
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp.strictDirective = function(start) {
    for(;;){
        // Try to find string literal.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) return false;
        if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match[0].length;
        // Skip semicolon, if any.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";") start++;
    }
};
// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.
pp.eat = function(type) {
    if (this.type === type) {
        this.next();
        return true;
    } else return false;
};
// Tests whether parsed token is a contextual keyword.
pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc;
};
// Consumes contextual keyword if possible.
pp.eatContextual = function(name) {
    if (!this.isContextual(name)) return false;
    this.next();
    return true;
};
// Asserts that following token is given contextual keyword.
pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) this.unexpected();
};
// Test whether a semicolon can be inserted at the current position.
pp.canInsertSemicolon = function() {
    return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        return true;
    }
};
// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.
pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) this.unexpected();
};
pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
        if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        if (!notNext) this.next();
        return true;
    }
};
// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.
pp.expect = function(type) {
    this.eat(type) || this.unexpected();
};
// Raise an unexpected token error.
pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
};
function DestructuringErrors() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) return;
    if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) this.raiseRecoverable(parens, "Parenthesized pattern");
};
pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) return false;
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
    if (shorthandAssign >= 0) this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
    if (doubleProto >= 0) this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
};
pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, "Yield expression cannot be a default value");
    if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value");
};
pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(expr.expression);
    return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$1 = Parser.prototype;
// ### Statement parsing
// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.
pp$1.parseTopLevel = function(node) {
    var exports = {};
    if (!node.body) node.body = [];
    while(this.type !== types.eof){
        var stmt = this.parseStatement(null, true, exports);
        node.body.push(stmt);
    }
    if (this.inModule) for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){
        var name = list[i];
        this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program");
};
var loopLabel = {
    kind: "loop"
}, switchLabel = {
    kind: "switch"
};
pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    // For ambiguous cases, determine if a LexicalDeclaration (or only a
    // Statement) is allowed here. If context is not empty then only a Statement
    // is allowed. However, `let [` is an explicit negative lookahead for
    // ExpressionStatement, so special-case it first.
    if (nextCh === 91) return true;
     // '['
    if (context) return false;
    if (nextCh === 123) return true;
     // '{'
    if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while(isIdentifierChar(this.input.charCodeAt(pos), true))++pos;
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) return true;
    }
    return false;
};
// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
};
// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.
pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;
    if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
    }
    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.
    switch(starttype){
        case types._break:
        case types._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
        case types._debugger:
            return this.parseDebuggerStatement(node);
        case types._do:
            return this.parseDoStatement(node);
        case types._for:
            return this.parseForStatement(node);
        case types._function:
            // Function as sole body of either an if statement or a labeled statement
            // works, but not when it is part of a labeled statement that is the sole
            // body of an if statement.
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) this.unexpected();
            return this.parseFunctionStatement(node, false, !context);
        case types._class:
            if (context) this.unexpected();
            return this.parseClass(node, true);
        case types._if:
            return this.parseIfStatement(node);
        case types._return:
            return this.parseReturnStatement(node);
        case types._switch:
            return this.parseSwitchStatement(node);
        case types._throw:
            return this.parseThrowStatement(node);
        case types._try:
            return this.parseTryStatement(node);
        case types._const:
        case types._var:
            kind = kind || this.value;
            if (context && kind !== "var") this.unexpected();
            return this.parseVarStatement(node, kind);
        case types._while:
            return this.parseWhileStatement(node);
        case types._with:
            return this.parseWithStatement(node);
        case types.braceL:
            return this.parseBlock(true, node);
        case types.semi:
            return this.parseEmptyStatement(node);
        case types._export:
        case types._import:
            if (this.options.ecmaVersion > 10 && starttype === types._import) {
                skipWhiteSpace.lastIndex = this.pos;
                var skip = skipWhiteSpace.exec(this.input);
                var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
                if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());
            }
            if (!this.options.allowImportExportEverywhere) {
                if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
                if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
            return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);
        // If the statement does not start with a statement keyword or a
        // brace, it's an ExpressionStatement or LabeledStatement. We
        // simply start parsing an expression, and afterwards, if the
        // next token is a colon and the expression was a simple
        // Identifier node, we switch to interpreting it as a label.
        default:
            if (this.isAsyncFunction()) {
                if (context) this.unexpected();
                this.next();
                return this.parseFunctionStatement(node, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);
            else return this.parseExpressionStatement(node, expr);
    }
};
pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) node.label = null;
    else if (this.type !== types.name) this.unexpected();
    else {
        node.label = this.parseIdent();
        this.semicolon();
    }
    // Verify that there is an actual destination to break or
    // continue to.
    var i = 0;
    for(; i < this.labels.length; ++i){
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
            if (node.label && isBreak) break;
        }
    }
    if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement");
};
pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6) this.eat(types.semi);
    else this.semicolon();
    return this.finishNode(node, "DoWhileStatement");
};
// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.
pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
        if (awaitAt > -1) this.unexpected(awaitAt);
        return this.parseFor(node, null);
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
                if (this.type === types._in) {
                    if (awaitAt > -1) this.unexpected(awaitAt);
                } else node.await = awaitAt > -1;
            }
            return this.parseForIn(node, init$1);
        }
        if (awaitAt > -1) this.unexpected(awaitAt);
        return this.parseFor(node, init$1);
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
        if (this.options.ecmaVersion >= 9) {
            if (this.type === types._in) {
                if (awaitAt > -1) this.unexpected(awaitAt);
            } else node.await = awaitAt > -1;
        }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLVal(init);
        return this.parseForIn(node, init);
    } else this.checkExpressionErrors(refDestructuringErrors, true);
    if (awaitAt > -1) this.unexpected(awaitAt);
    return this.parseFor(node, init);
};
pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    // allow function declarations in branches, but only in non-strict mode
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement");
};
pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
    this.next();
    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.
    if (this.eat(types.semi) || this.insertSemicolon()) node.argument = null;
    else {
        node.argument = this.parseExpression();
        this.semicolon();
    }
    return this.finishNode(node, "ReturnStatement");
};
pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);
    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.
    var cur;
    for(var sawDefault = false; this.type !== types.braceR;)if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) this.finishNode(cur, "SwitchCase");
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) cur.test = this.parseExpression();
        else {
            if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            sawDefault = true;
            cur.test = null;
        }
        this.expect(types.colon);
    } else {
        if (!cur) this.unexpected();
        cur.consequent.push(this.parseStatement(null));
    }
    this.exitScope();
    if (cur) this.finishNode(cur, "SwitchCase");
    this.next(); // Closing brace
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement");
};
pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement");
};
// Reused empty array added for node fields that are always empty.
var empty = [];
pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types.parenL)) {
            clause.param = this.parseBindingAtom();
            var simple = clause.param.type === "Identifier";
            this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
            this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
            this.expect(types.parenR);
        } else {
            if (this.options.ecmaVersion < 10) this.unexpected();
            clause.param = null;
            this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
    return this.finishNode(node, "TryStatement");
};
pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration");
};
pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement");
};
pp$1.parseWithStatement = function(node) {
    if (this.strict) this.raise(this.start, "'with' in strict mode");
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement");
};
pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement");
};
pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){
        var label = list[i$1];
        if (label.name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for(var i = this.labels.length - 1; i >= 0; i--){
        var label$1 = this.labels[i];
        if (label$1.statementStart === node.start) {
            // Update information about previous labels on this node
            label$1.statementStart = this.start;
            label$1.kind = kind;
        } else break;
    }
    this.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.start
    });
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement");
};
pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement");
};
// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).
pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
    if (createNewLexicalScope === void 0) createNewLexicalScope = true;
    if (node === void 0) node = this.startNode();
    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) this.enterScope(0);
    while(this.type !== types.braceR){
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
    }
    if (exitStrict) this.strict = false;
    this.next();
    if (createNewLexicalScope) this.exitScope();
    return this.finishNode(node, "BlockStatement");
};
// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.
pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement");
};
// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.
pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();
    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
    else if (init.type === "AssignmentPattern") this.raise(init.start, "Invalid left-hand side in for-loop");
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
// Parse a list of variable declarations.
pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for(;;){
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types.eq)) decl.init = this.parseMaybeAssign(isFor);
        else if (kind === "const" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) this.unexpected();
        else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        else decl.init = null;
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) break;
    }
    return node;
};
pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).
// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types.star && statement & FUNC_HANGING_STATEMENT) this.unexpected();
        node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
    if (statement & FUNC_STATEMENT) {
        node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent();
        if (node.id && !(statement & FUNC_HANGING_STATEMENT)) this.checkLVal(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));
    if (!(statement & FUNC_STATEMENT)) node.id = this.type === types.name ? this.parseIdent() : null;
    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
};
// Parse a class declaration or literal (depending on the
// `isStatement` parameter).
pp$1.parseClass = function(node, isStatement) {
    this.next();
    // ecma-262 14.6 Class Definitions
    // A class definition is always strict mode code.
    var oldStrict = this.strict;
    this.strict = true;
    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while(this.type !== types.braceR){
        var element = this.parseClassElement(node.superClass !== null);
        if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
                if (hadConstructor) this.raise(element.start, "Duplicate constructor in the same class");
                hadConstructor = true;
            }
        }
    }
    this.strict = oldStrict;
    this.next();
    node.body = this.finishNode(classBody, "ClassBody");
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;
    if (this.eat(types.semi)) return null;
    var method = this.startNode();
    var tryContextual = function(k, noLineBreak) {
        if (noLineBreak === void 0) noLineBreak = false;
        var start = this$1.start, startLoc = this$1.startLoc;
        if (!this$1.eatContextual(k)) return false;
        if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) return true;
        if (method.key) this$1.unexpected();
        method.computed = false;
        method.key = this$1.startNodeAt(start, startLoc);
        method.key.name = k;
        this$1.finishNode(method.key, "Identifier");
        return false;
    };
    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
        if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        } else if (tryContextual("get")) method.kind = "get";
        else if (tryContextual("set")) method.kind = "set";
    }
    if (!method.key) this.parsePropertyName(method);
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (method.kind !== "method") this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        if (isAsync) this.raise(key.start, "Constructor can't be an async method");
        method.kind = "constructor";
        allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") this.raise(key.start, "Classes may not have a static property named prototype");
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0) this.raiseRecoverable(method.value.start, "getter should have no params");
    if (method.kind === "set" && method.value.params.length !== 1) this.raiseRecoverable(method.value.start, "setter should have exactly one param");
    if (method.kind === "set" && method.value.params[0].type === "RestElement") this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
    return method;
};
pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition");
};
pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
        node.id = this.parseIdent();
        if (isStatement) this.checkLVal(node.id, BIND_LEXICAL, false);
    } else {
        if (isStatement === true) this.unexpected();
        node.id = null;
    }
};
pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};
// Parses module export declaration.
pp$1.parseExport = function(node, exports) {
    this.next();
    // export * from '...'
    if (this.eat(types.star)) {
        if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
                node.exported = this.parseIdent(true);
                this.checkExport(exports, node.exported.name, this.lastTokStart);
            } else node.exported = null;
        }
        this.expectContextual("from");
        if (this.type !== types.string) this.unexpected();
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
    }
    if (this.eat(types._default)) {
        this.checkExport(exports, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) this.next();
            node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types._class) {
            var cNode = this.startNode();
            node.declaration = this.parseClass(cNode, "nullableID");
        } else {
            node.declaration = this.parseMaybeAssign();
            this.semicolon();
        }
        return this.finishNode(node, "ExportDefaultDeclaration");
    }
    // export var|const|let|function|class ...
    if (this.shouldParseExportStatement()) {
        node.declaration = this.parseStatement(null);
        if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports, node.declaration.declarations);
        else this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
        node.specifiers = [];
        node.source = null;
    } else {
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports);
        if (this.eatContextual("from")) {
            if (this.type !== types.string) this.unexpected();
            node.source = this.parseExprAtom();
        } else {
            for(var i = 0, list = node.specifiers; i < list.length; i += 1){
                // check for keywords used as local names
                var spec = list[i];
                this.checkUnreserved(spec.local);
                // check if export is defined
                this.checkLocalExport(spec.local);
            }
            node.source = null;
        }
        this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration");
};
pp$1.checkExport = function(exports, name, pos) {
    if (!exports) return;
    if (has(exports, name)) this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
    exports[name] = true;
};
pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier") this.checkExport(exports, pat.name, pat.start);
    else if (type === "ObjectPattern") for(var i = 0, list = pat.properties; i < list.length; i += 1){
        var prop = list[i];
        this.checkPatternExport(exports, prop);
    }
    else if (type === "ArrayPattern") for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){
        var elt = list$1[i$1];
        if (elt) this.checkPatternExport(exports, elt);
    }
    else if (type === "Property") this.checkPatternExport(exports, pat.value);
    else if (type === "AssignmentPattern") this.checkPatternExport(exports, pat.left);
    else if (type === "RestElement") this.checkPatternExport(exports, pat.argument);
    else if (type === "ParenthesizedExpression") this.checkPatternExport(exports, pat.expression);
};
pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) return;
    for(var i = 0, list = decls; i < list.length; i += 1){
        var decl = list[i];
        this.checkPatternExport(exports, decl.id);
    }
};
pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
// Parses a comma-separated list of module exports.
pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from '...']
    this.expect(types.braceL);
    while(!this.eat(types.braceR)){
        if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) break;
        } else first = false;
        var node = this.startNode();
        node.local = this.parseIdent(true);
        node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
        this.checkExport(exports, node.exported.name, node.exported.start);
        nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes;
};
// Parses import declaration.
pp$1.parseImport = function(node) {
    this.next();
    // import '...'
    if (this.type === types.string) {
        node.specifiers = empty;
        node.source = this.parseExprAtom();
    } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
};
// Parses a comma-separated list of module imports.
pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
        // import defaultObj, { x, y as z } from '...'
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLVal(node.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
        if (!this.eat(types.comma)) return nodes;
    }
    if (this.type === types.star) {
        var node$1 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$1.local = this.parseIdent();
        this.checkLVal(node$1.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
        return nodes;
    }
    this.expect(types.braceL);
    while(!this.eat(types.braceR)){
        if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) break;
        } else first = false;
        var node$2 = this.startNode();
        node$2.imported = this.parseIdent(true);
        if (this.eatContextual("as")) node$2.local = this.parseIdent();
        else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
        }
        this.checkLVal(node$2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes;
};
// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
    for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i)statements[i].directive = statements[i].expression.raw.slice(1, -1);
};
pp$1.isDirectiveCandidate = function(statement) {
    return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
    (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$2 = Parser.prototype;
// Convert existing expression atom to assignable pattern
// if possible.
pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) switch(node.type){
        case "Identifier":
            if (this.inAsync && node.name === "await") this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
            break;
        case "ObjectPattern":
        case "ArrayPattern":
        case "RestElement":
            break;
        case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
            for(var i = 0, list = node.properties; i < list.length; i += 1){
                var prop = list[i];
                this.toAssignable(prop, isBinding);
                // Early error:
                //   AssignmentRestProperty[Yield, Await] :
                //     `...` DestructuringAssignmentTarget[Yield, Await]
                //
                //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) this.raise(prop.argument.start, "Unexpected token");
            }
            break;
        case "Property":
            // AssignmentProperty has type === "Property"
            if (node.kind !== "init") this.raise(node.key.start, "Object pattern can't contain getter or setter");
            this.toAssignable(node.value, isBinding);
            break;
        case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
            this.toAssignableList(node.elements, isBinding);
            break;
        case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern") this.raise(node.argument.start, "Rest elements cannot have a default value");
            break;
        case "AssignmentExpression":
            if (node.operator !== "=") this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
        // falls through to AssignmentPattern
        case "AssignmentPattern":
            break;
        case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break;
        case "ChainExpression":
            this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
            break;
        case "MemberExpression":
            if (!isBinding) break;
        default:
            this.raise(node.start, "Assigning to rvalue");
    }
    else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
    return node;
};
// Convert list of expression atoms to binding list.
pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for(var i = 0; i < end; i++){
        var elt = exprList[i];
        if (elt) this.toAssignable(elt, isBinding);
    }
    if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
    }
    return exprList;
};
// Parses spread element.
pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement");
};
pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();
    // RestElement inside of a function parameter must be an identifier
    if (this.options.ecmaVersion === 6 && this.type !== types.name) this.unexpected();
    node.argument = this.parseBindingAtom();
    return this.finishNode(node, "RestElement");
};
// Parses lvalue (assignable) atom.
pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) switch(this.type){
        case types.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");
        case types.braceL:
            return this.parseObj(true);
    }
    return this.parseIdent();
};
pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while(!this.eat(close)){
        if (first) first = false;
        else this.expect(types.comma);
        if (allowEmpty && this.type === types.comma) elts.push(null);
        else if (allowTrailingComma && this.afterTrailingComma(close)) break;
        else if (this.type === types.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types.comma) this.raise(this.start, "Comma is not permitted after the rest element");
            this.expect(close);
            break;
        } else {
            var elem = this.parseMaybeDefault(this.start, this.startLoc);
            this.parseBindingListItem(elem);
            elts.push(elem);
        }
    }
    return elts;
};
pp$2.parseBindingListItem = function(param) {
    return param;
};
// Parses assignment pattern around given atom if possible.
pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) return left;
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern");
};
// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references
pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0) bindingType = BIND_NONE;
    switch(expr.type){
        case "Identifier":
            if (bindingType === BIND_LEXICAL && expr.name === "let") this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            if (checkClashes) {
                if (has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
                checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) this.declareName(expr.name, bindingType, expr.start);
            break;
        case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
        case "MemberExpression":
            if (bindingType) this.raiseRecoverable(expr.start, "Binding member expression");
            break;
        case "ObjectPattern":
            for(var i = 0, list = expr.properties; i < list.length; i += 1){
                var prop = list[i];
                this.checkLVal(prop, bindingType, checkClashes);
            }
            break;
        case "Property":
            // AssignmentProperty has type === "Property"
            this.checkLVal(expr.value, bindingType, checkClashes);
            break;
        case "ArrayPattern":
            for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){
                var elem = list$1[i$1];
                if (elem) this.checkLVal(elem, bindingType, checkClashes);
            }
            break;
        case "AssignmentPattern":
            this.checkLVal(expr.left, bindingType, checkClashes);
            break;
        case "RestElement":
            this.checkLVal(expr.argument, bindingType, checkClashes);
            break;
        case "ParenthesizedExpression":
            this.checkLVal(expr.expression, bindingType, checkClashes);
            break;
        default:
            this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
};
// A recursive descent parser operates by defining functions for all
var pp$3 = Parser.prototype;
// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.
pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") return;
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
    var key = prop.key;
    var name;
    switch(key.type){
        case "Identifier":
            name = key.name;
            break;
        case "Literal":
            name = String(key.value);
            break;
        default:
            return;
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
                if (refDestructuringErrors) {
                    if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;
                } else this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
            propHash.proto = true;
        }
        return;
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
        var redefinition;
        if (kind === "init") redefinition = this.strict && other.init || other.get || other.set;
        else redefinition = other.init || other[kind];
        if (redefinition) this.raiseRecoverable(key.start, "Redefinition of property");
    } else other = propHash[name] = {
        init: false,
        get: false,
        set: false
    };
    other[kind] = true;
};
// ### Expression parsing
// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).
pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [
            expr
        ];
        while(this.eat(types.comma))node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
        return this.finishNode(node, "SequenceExpression");
    }
    return expr;
};
// Parse an assignment expression. This includes applications of
// operators like `+=`.
pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
        if (this.inGenerator) return this.parseYield(noIn);
        else this.exprAllowed = false;
    }
    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
    if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
        refDestructuringErrors = new DestructuringErrors;
        ownDestructuringErrors = true;
    }
    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name) this.potentialArrowAt = this.start;
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
    if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
        if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        if (refDestructuringErrors.shorthandAssign >= node.left.start) refDestructuringErrors.shorthandAssign = -1;
         // reset because shorthand default was used correctly
        this.checkLVal(left);
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression");
    } else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
    if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
    if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
    return left;
};
// Parse a ternary conditional (`?:`) operator.
pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
    if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression");
    }
    return expr;
};
// Start the precedence parser.
pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};
// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
        if (prec > minPrec) {
            var logical = this.type === types.logicalOR || this.type === types.logicalAND;
            var coalesce = this.type === types.coalesce;
            if (coalesce) // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
            // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
            prec = types.logicalAND.binop;
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types.coalesce || coalesce && (this.type === types.logicalOR || this.type === types.logicalAND)) this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
    }
    return left;
};
pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
// Parse unary operators, both prefix and postfix.
pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
        expr = this.parseAwait();
        sawUnary = true;
    } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) this.checkLVal(node.argument);
        else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
        else sawUnary = true;
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
        expr = this.parseExprSubscripts(refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
        while(this.type.postfix && !this.canInsertSemicolon()){
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLVal(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
        }
    }
    if (!sawUnary && this.eat(types.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
    else return expr;
};
// Parse call, dot, and `[]`-subscript expressions.
pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return expr;
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
        if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
    }
    return result;
};
pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
    var optionalChained = false;
    while(true){
        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
        if (element.optional) optionalChained = true;
        if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
                var chainNode = this.startNodeAt(startPos, startLoc);
                chainNode.expression = element;
                element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
        }
        base = element;
    }
};
pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types.questionDot);
    if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
    var computed = this.eat(types.bracketL);
    if (computed || optional && this.type !== types.parenL && this.type !== types.backQuote || this.eat(types.dot)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
        node.computed = !!computed;
        if (computed) this.expect(types.bracketR);
        if (optionalSupported) node.optional = optional;
        base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.callee = base;
        node$1.arguments = exprList;
        if (optionalSupported) node$1.optional = optional;
        base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
        if (optional || optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base;
        node$2.quasi = this.parseTemplate({
            isTagged: true
        });
        base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base;
};
// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.
pp$3.parseExprAtom = function(refDestructuringErrors) {
    // If a division operator appears in an expression position, the
    // tokenizer got confused, and we force it to read a regexp instead.
    if (this.type === types.slash) this.readRegexp();
    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch(this.type){
        case types._super:
            if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
            node = this.startNode();
            this.next();
            if (this.type === types.parenL && !this.allowDirectSuper) this.raise(node.start, "super() call outside constructor of a subclass");
            // The `super` keyword can appear at below:
            // SuperProperty:
            //     super [ Expression ]
            //     super . IdentifierName
            // SuperCall:
            //     super ( Arguments )
            if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) this.unexpected();
            return this.finishNode(node, "Super");
        case types._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
        case types.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);
            if (canBeArrow && !this.canInsertSemicolon()) {
                if (this.eat(types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
                    id
                ], false);
                if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
                    id = this.parseIdent(false);
                    if (this.canInsertSemicolon() || !this.eat(types.arrow)) this.unexpected();
                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
                        id
                    ], true);
                }
            }
            return id;
        case types.regexp:
            var value = this.value;
            node = this.parseLiteral(value.value);
            node.regex = {
                pattern: value.pattern,
                flags: value.flags
            };
            return node;
        case types.num:
        case types.string:
            return this.parseLiteral(this.value);
        case types._null:
        case types._true:
        case types._false:
            node = this.startNode();
            node.value = this.type === types._null ? null : this.type === types._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
        case types.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
            if (refDestructuringErrors) {
                if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;
                if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;
            }
            return expr;
        case types.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
        case types.braceL:
            return this.parseObj(false, refDestructuringErrors);
        case types._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
        case types._class:
            return this.parseClass(this.startNode(), false);
        case types._new:
            return this.parseNew();
        case types.backQuote:
            return this.parseTemplate();
        case types._import:
            if (this.options.ecmaVersion >= 11) return this.parseExprImport();
            else return this.unexpected();
        default:
            this.unexpected();
    }
};
pp$3.parseExprImport = function() {
    var node = this.startNode();
    // Consume `import` as an identifier for `import.meta`.
    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
    if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
    var meta = this.parseIdent(true);
    switch(this.type){
        case types.parenL:
            return this.parseDynamicImport(node);
        case types.dot:
            node.meta = meta;
            return this.parseImportMeta(node);
        default:
            this.unexpected();
    }
};
pp$3.parseDynamicImport = function(node) {
    this.next(); // skip `(`
    // Parse node.source.
    node.source = this.parseMaybeAssign();
    // Verify ending.
    if (!this.eat(types.parenR)) {
        var errorPos = this.start;
        if (this.eat(types.comma) && this.eat(types.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        else this.unexpected(errorPos);
    }
    return this.finishNode(node, "ImportExpression");
};
pp$3.parseImportMeta = function(node) {
    this.next(); // skip `.`
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "meta") this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
    if (containsEsc) this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
    if (this.options.sourceType !== "module") this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
    return this.finishNode(node, "MetaProperty");
};
pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
    this.next();
    return this.finishNode(node, "Literal");
};
pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val;
};
pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        // Do not save awaitIdentPos to allow checking awaits nested in parameters
        while(this.type !== types.parenR){
            first ? first = false : this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
                lastIsComma = true;
                break;
            } else if (this.type === types.ellipsis) {
                spreadStart = this.start;
                exprList.push(this.parseParenItem(this.parseRestBinding()));
                if (this.type === types.comma) this.raise(this.start, "Comma is not permitted after the rest element");
                break;
            } else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
        var innerEndPos = this.start, innerEndLoc = this.startLoc;
        this.expect(types.parenR);
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList);
        }
        if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
        if (spreadStart) this.unexpected(spreadStart);
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else val = exprList[0];
    } else val = this.parseParenExpression();
    if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
    } else return val;
};
pp$3.parseParenItem = function(item) {
    return item;
};
pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};
// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
var empty$1 = [];
pp$3.parseNew = function() {
    if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
        node.meta = meta;
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
        if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
        if (!this.inNonArrowFunction()) this.raiseRecoverable(node.start, "'new.target' can only be used in functions");
        return this.finishNode(node, "MetaProperty");
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (isImport && node.callee.type === "ImportExpression") this.raise(startPos, "Cannot use new with import()");
    if (this.eat(types.parenL)) node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
    else node.arguments = empty$1;
    return this.finishNode(node, "NewExpression");
};
// Parse template expression.
pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;
    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
        if (!isTagged) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        elem.value = {
            raw: this.value,
            cooked: null
        };
    } else elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
    };
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement");
};
pp$3.parseTemplate = function(ref) {
    if (ref === void 0) ref = {};
    var isTagged = ref.isTagged;
    if (isTagged === void 0) isTagged = false;
    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({
        isTagged: isTagged
    });
    node.quasis = [
        curElt
    ];
    while(!curElt.tail){
        if (this.type === types.eof) this.raise(this.pos, "Unterminated template literal");
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement({
            isTagged: isTagged
        }));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral");
};
pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
// Parse an object literal or binding pattern.
pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while(!this.eat(types.braceR)){
        if (!first) {
            this.expect(types.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) break;
        } else first = false;
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);
        node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
        if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types.comma) this.raise(this.start, "Comma is not permitted after the rest element");
            return this.finishNode(prop, "RestElement");
        }
        // To disallow parenthesized identifier via `this.toAssignable()`.
        if (this.type === types.parenL && refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0) refDestructuringErrors.parenthesizedAssign = this.start;
            if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = this.start;
        }
        // Parse argument.
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        // To disallow trailing comma via `this.toAssignable()`.
        if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
        // Finish
        return this.finishNode(prop, "SpreadElement");
    }
    if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
        }
        if (!isPattern) isGenerator = this.eat(types.star);
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        this.parsePropertyName(prop, refDestructuringErrors);
    } else isAsync = false;
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property");
};
pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon) this.unexpected();
    if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
        if (isPattern) this.unexpected();
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq) {
        if (isGenerator || isAsync) this.unexpected();
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
            else this.raiseRecoverable(start, "setter should have exactly one param");
        } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) this.unexpected();
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = startPos;
        prop.kind = "init";
        if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        else if (this.type === types.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;
            prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else prop.value = prop.key;
        prop.shorthand = true;
    } else this.unexpected();
};
pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
        if (this.eat(types.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types.bracketR);
            return prop.key;
        } else prop.computed = false;
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
// Initialize empty function node.
pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;
    if (this.options.ecmaVersion >= 8) node.async = false;
};
// Parse object or class method.
pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.initFunction(node);
    if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression");
};
// Parse arrow function expression with given parameters.
pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression");
};
// Parse function body and check parameters.
pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;
    if (isExpression) {
        node.body = this.parseMaybeAssign();
        node.expression = true;
        this.checkParams(node, false);
    } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            // If this is a strict mode function, verify that argument names
            // are not repeated, and it does not try to bind the words `eval`
            // or `arguments`.
            if (useStrict && nonSimple) this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
        }
        // Start a new scope with regard to labels and the `inFunction`
        // flag (restore them to their old value afterwards).
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) this.strict = true;
        // Add the params to varDeclaredNames to ensure that an error is thrown
        // if a let/const declaration in the function clashes with one of the params.
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
        // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
        if (this.strict && node.id) this.checkLVal(node.id, BIND_OUTSIDE);
        node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
        node.expression = false;
        this.adaptDirectivePrologue(node.body.body);
        this.labels = oldLabels;
    }
    this.exitScope();
};
pp$3.isSimpleParamList = function(params) {
    for(var i = 0, list = params; i < list.length; i += 1){
        var param = list[i];
        if (param.type !== "Identifier") return false;
    }
    return true;
};
// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.
pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {};
    for(var i = 0, list = node.params; i < list.length; i += 1){
        var param = list[i];
        this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
};
// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).
pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while(!this.eat(close)){
        if (!first) {
            this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) break;
        } else first = false;
        var elt = void 0;
        if (allowEmpty && this.type === types.comma) elt = null;
        else if (this.type === types.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
        } else elt = this.parseMaybeAssign(false, refDestructuringErrors);
        elts.push(elt);
    }
    return elts;
};
pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;
    if (this.inGenerator && name === "yield") this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
    if (this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
    if (this.keywords.test(name)) this.raise(start, "Unexpected keyword '" + name + "'");
    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) return;
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
        if (!this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
    }
};
// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.
pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) node.name = this.value;
    else if (this.type.keyword) {
        node.name = this.type.keyword;
        // To fix https://github.com/acornjs/acorn/issues/575
        // `class` and `function` keywords push new context into this.context.
        // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
        // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
        if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();
    } else this.unexpected();
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
        this.checkUnreserved(node);
        if (node.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = node.start;
    }
    return node;
};
// Parses yield expression inside generator.
pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) this.yieldPos = this.start;
    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
    } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression");
};
pp$3.parseAwait = function() {
    if (!this.awaitPos) this.awaitPos = this.start;
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, false);
    return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.
pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos;
    err.loc = loc;
    err.raisedAt = this.pos;
    throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
    if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
};
var pp$5 = Parser.prototype;
var Scope = function Scope(flags) {
    this.flags = flags;
    // A list of var-declared names in the current lexical scope
    this.var = [];
    // A list of lexically-declared names in the current lexical scope
    this.lexical = [];
    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
    this.functions = [];
};
// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.
pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
};
pp$5.exitScope = function() {
    this.scopeStack.pop();
};
// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$5.treatFunctionsAsVarInScope = function(scope) {
    return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && scope.flags & SCOPE_TOP) delete this.undefinedExports[name];
    } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;
        else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
        scope$2.functions.push(name);
    } else for(var i = this.scopeStack.length - 1; i >= 0; --i){
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break;
        }
        scope$3.var.push(name);
        if (this.inModule && scope$3.flags & SCOPE_TOP) delete this.undefinedExports[name];
        if (scope$3.flags & SCOPE_VAR) break;
    }
    if (redeclared) this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
};
pp$5.checkLocalExport = function(id) {
    // scope.functions must be empty as Module code is always strict.
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;
};
pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1];
};
pp$5.currentVarScope = function() {
    for(var i = this.scopeStack.length - 1;; i--){
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR) return scope;
    }
};
// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$5.currentThisScope = function() {
    for(var i = this.scopeStack.length - 1;; i--){
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) return scope;
    }
};
var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations) this.loc = new SourceLocation(parser, loc);
    if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
    if (parser.options.ranges) this.range = [
        pos,
        0
    ];
};
// Start an AST node, attaching a start offset.
var pp$6 = Parser.prototype;
pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc);
};
pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc);
};
// Finish an AST node, adding `type` and `end` properties.
function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations) node.loc.end = loc;
    if (this.options.ranges) node.range[1] = pos;
    return node;
}
pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
// Finish node at given position
pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc);
};
// The algorithm used to determine whether a regexp can appear at a
var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
};
var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function(p) {
        return p.tryReadTemplateToken();
    }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
};
var pp$7 = Parser.prototype;
pp$7.initialContext = function() {
    return [
        types$1.b_stat
    ];
};
pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat) return true;
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) return !parent.isExpr;
    // The check for `tt.name && exprAllowed` detects whether we are
    // after a `yield` or `of` construct. See the `updateContext` for
    // `tt.name`.
    if (prevType === types._return || prevType === types.name && this.exprAllowed) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) return true;
    if (prevType === types.braceL) return parent === types$1.b_stat;
    if (prevType === types._var || prevType === types._const || prevType === types.name) return false;
    return !this.exprAllowed;
};
pp$7.inGeneratorContext = function() {
    for(var i = this.context.length - 1; i >= 1; i--){
        var context = this.context[i];
        if (context.token === "function") return context.generator;
    }
    return false;
};
pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot) this.exprAllowed = false;
    else if (update = type.updateContext) update.call(this, prevType);
    else this.exprAllowed = type.beforeExpr;
};
// Token-specific context update code
types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") out = this.context.pop();
    this.exprAllowed = !out.isExpr;
};
types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
};
types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
};
types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
};
types.incDec.updateContext = function() {
// tokExprAllowed stays unchanged
};
types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) this.context.push(types$1.f_expr);
    else this.context.push(types$1.f_stat);
    this.exprAllowed = false;
};
types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl) this.context.pop();
    else this.context.push(types$1.q_tmpl);
    this.exprAllowed = false;
};
types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types$1.f_expr) this.context[index] = types$1.f_expr_gen;
        else this.context[index] = types$1.f_gen;
    }
    this.exprAllowed = true;
};
types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) allowed = true;
    }
    this.exprAllowed = allowed;
};
// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)
// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
};
// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
        nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
        }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;
    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
buildUnicodeData(9);
buildUnicodeData(10);
buildUnicodeData(11);
var pp$8 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};
RegExpValidationState.prototype.raise = function raise(message) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at(i, forceU) {
    if (forceU === void 0) forceU = false;
    var s = this.source;
    var l = s.length;
    if (i >= l) return -1;
    var c = s.charCodeAt(i);
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) return c;
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
    if (forceU === void 0) forceU = false;
    var s = this.source;
    var l = s.length;
    if (i >= l) return l;
    var c = s.charCodeAt(i), next;
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) return i + 1;
    return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
    if (forceU === void 0) forceU = false;
    return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
    if (forceU === void 0) forceU = false;
    return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
    if (forceU === void 0) forceU = false;
    this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
    if (forceU === void 0) forceU = false;
    if (this.current(forceU) === ch) {
        this.advance(forceU);
        return true;
    }
    return false;
};
function codePointToString(ch) {
    if (ch <= 0xFFFF) return String.fromCharCode(ch);
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00);
}
/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */ pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;
    for(var i = 0; i < flags.length; i++){
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) this.raise(state.start, "Invalid regular expression flag");
        if (flags.indexOf(flag, i + 1) > -1) this.raise(state.start, "Duplicate regular expression flag");
    }
};
/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */ pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);
    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
    // parsing contains a |GroupName|, reparse with the goal symbol
    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
    // exception if _P_ did not conform to the grammar, if any elements of _P_
    // were not matched by the parse, or if any Early Error conditions exist.
    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
    }
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;
    this.regexp_disjunction(state);
    if (state.pos !== state.source.length) {
        // Make the same messages as V8.
        if (state.eat(0x29 /* ) */ )) state.raise("Unmatched ')'");
        if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) state.raise("Lone quantifier brackets");
    }
    if (state.maxBackReference > state.numCapturingParens) state.raise("Invalid escape");
    for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){
        var name = list[i];
        if (state.groupNames.indexOf(name) === -1) state.raise("Invalid named capture referenced");
    }
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while(state.eat(0x7C /* | */ ))this.regexp_alternative(state);
    // Make the same message as V8.
    if (this.regexp_eatQuantifier(state, true)) state.raise("Nothing to repeat");
    if (state.eat(0x7B /* { */ )) state.raise("Lone quantifier brackets");
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
    while(state.pos < state.source.length && this.regexp_eatTerm(state));
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
        // Handle `QuantifiableAssertion Quantifier` alternative.
        // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
        // is a QuantifiableAssertion.
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) // Make the same message as V8.
        {
            if (state.switchU) state.raise("Invalid quantifier");
        }
        return true;
    }
    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;
    // ^, $
    if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) return true;
    // \b \B
    if (state.eat(0x5C /* \ */ )) {
        if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) return true;
        state.pos = start;
    }
    // Lookahead / Lookbehind
    if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) lookbehind = state.eat(0x3C /* < */ );
        if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {
            this.regexp_disjunction(state);
            if (!state.eat(0x29 /* ) */ )) state.raise("Unterminated group");
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
        }
    }
    state.pos = start;
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
    if (noError === void 0) noError = false;
    if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(0x3F /* ? */ );
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B /* { */ )) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;
            if (state.eat(0x7D /* } */ )) {
                // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
                if (max !== -1 && max < min && !noError) state.raise("numbers out of order in {} quantifier");
                return true;
            }
        }
        if (state.switchU && !noError) state.raise("Incomplete quantifier");
        state.pos = start;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
    return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C /* \ */ )) {
        if (this.regexp_eatAtomEscape(state)) return true;
        state.pos = start;
    }
    return false;
};
pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 /* ( */ )) {
        if (state.eat(0x3F /* ? */ ) && state.eat(0x3A /* : */ )) {
            this.regexp_disjunction(state);
            if (state.eat(0x29 /* ) */ )) return true;
            state.raise("Unterminated group");
        }
        state.pos = start;
    }
    return false;
};
pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 /* ( */ )) {
        if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);
        else if (state.current() === 0x3F /* ? */ ) state.raise("Invalid group");
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */ )) {
            state.numCapturingParens += 1;
            return true;
        }
        state.raise("Unterminated group");
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$8.regexp_eatExtendedAtom = function(state) {
    return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) state.raise("Nothing to repeat");
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
    }
    return false;
};
function isSyntaxCharacter(ch) {
    return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch))state.advance();
    return state.pos !== start;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {
        state.advance();
        return true;
    }
    return false;
};
// GroupSpecifier ::
//   [empty]
//   `?` GroupName
pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F /* ? */ )) {
        if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) state.raise("Duplicate capture group name");
            state.groupNames.push(state.lastStringValue);
            return;
        }
        state.raise("Invalid group");
    }
};
// GroupName ::
//   `<` RegExpIdentifierName `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C /* < */ )) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) return true;
        state.raise("Invalid capture group name");
    }
    return false;
};
// RegExpIdentifierName ::
//   RegExpIdentifierStart
//   RegExpIdentifierName RegExpIdentifierPart
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
        while(this.regexp_eatRegExpIdentifierPart(state))state.lastStringValue += codePointToString(state.lastIntValue);
        return true;
    }
    return false;
};
// RegExpIdentifierStart ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);
    if (ch === 0x5C /* \ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
    if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true;
    }
    state.pos = start;
    return false;
};
function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;
}
// RegExpIdentifierPart ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
//   <ZWNJ>
//   <ZWJ>
pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);
    if (ch === 0x5C /* \ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
    if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true;
    }
    state.pos = start;
    return false;
};
function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;
    if (state.switchU) {
        // Make the same message as V8.
        if (state.current() === 0x63 /* c */ ) state.raise("Invalid unicode escape");
        state.raise("Invalid escape");
    }
    return false;
};
pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
        var n = state.lastIntValue;
        if (state.switchU) {
            // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
            if (n > state.maxBackReference) state.maxBackReference = n;
            return true;
        }
        if (n <= state.numCapturingParens) return true;
        state.pos = start;
    }
    return false;
};
pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B /* k */ )) {
        if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
        }
        state.raise("Invalid named reference");
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 /* c */ )) {
        if (this.regexp_eatControlLetter(state)) return true;
        state.pos = start;
    }
    return false;
};
pp$8.regexp_eatZero = function(state) {
    if (state.current() === 0x30 /* 0 */  && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 /* t */ ) {
        state.lastIntValue = 0x09; /* \t */ 
        state.advance();
        return true;
    }
    if (ch === 0x6E /* n */ ) {
        state.lastIntValue = 0x0A; /* \n */ 
        state.advance();
        return true;
    }
    if (ch === 0x76 /* v */ ) {
        state.lastIntValue = 0x0B; /* \v */ 
        state.advance();
        return true;
    }
    if (ch === 0x66 /* f */ ) {
        state.lastIntValue = 0x0C; /* \f */ 
        state.advance();
        return true;
    }
    if (ch === 0x72 /* r */ ) {
        state.lastIntValue = 0x0D; /* \r */ 
        state.advance();
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
        state.lastIntValue = ch % 0x20;
        state.advance();
        return true;
    }
    return false;
};
function isControlLetter(ch) {
    return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if (forceU === void 0) forceU = false;
    var start = state.pos;
    var switchU = forceU || state.switchU;
    if (state.eat(0x75 /* u */ )) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
                var leadSurrogateEnd = state.pos;
                if (state.eat(0x5C /* \ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {
                    var trail = state.lastIntValue;
                    if (trail >= 0xDC00 && trail <= 0xDFFF) {
                        state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                        return true;
                    }
                }
                state.pos = leadSurrogateEnd;
                state.lastIntValue = lead;
            }
            return true;
        }
        if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && isValidUnicode(state.lastIntValue)) return true;
        if (switchU) state.raise("Invalid unicode escape");
        state.pos = start;
    }
    return false;
};
function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) return true;
        if (state.eat(0x2F /* / */ )) {
            state.lastIntValue = 0x2F; /* / */ 
            return true;
        }
        return false;
    }
    var ch = state.current();
    if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {
        state.lastIntValue = ch;
        state.advance();
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {
        do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );
            state.advance();
        }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();
    if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return true;
    }
    if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 0x50 /* P */  || ch === 0x70 /* p */ )) {
        state.lastIntValue = -1;
        state.advance();
        if (state.eat(0x7B /* { */ ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(0x7D /* } */ )) return true;
        state.raise("Invalid property name");
    }
    return false;
};
function isCharacterClassEscape(ch) {
    return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;
}
// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;
    // UnicodePropertyName `=` UnicodePropertyValue
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
            return true;
        }
    }
    state.pos = start;
    // LoneUnicodePropertyNameOrValue
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true;
    }
    return false;
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name)) state.raise("Invalid property name");
    if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise("Invalid property value");
};
pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue)) state.raise("Invalid property name");
};
// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while(isUnicodePropertyNameCharacter(ch = state.current())){
        state.lastStringValue += codePointToString(ch);
        state.advance();
    }
    return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F /* _ */ ;
}
// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while(isUnicodePropertyValueCharacter(ch = state.current())){
        state.lastStringValue += codePointToString(ch);
        state.advance();
    }
    return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state);
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B /* [ */ )) {
        state.eat(0x5E /* ^ */ );
        this.regexp_classRanges(state);
        if (state.eat(0x5D /* ] */ )) return true;
        // Unreachable since it threw "unterminated regular expression" error before.
        state.raise("Unterminated character class");
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
    while(this.regexp_eatClassAtom(state)){
        var left = state.lastIntValue;
        if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) state.raise("Invalid character class");
            if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
        }
    }
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;
    if (state.eat(0x5C /* \ */ )) {
        if (this.regexp_eatClassEscape(state)) return true;
        if (state.switchU) {
            // Make the same message as V8.
            var ch$1 = state.current();
            if (ch$1 === 0x63 /* c */  || isOctalDigit(ch$1)) state.raise("Invalid class escape");
            state.raise("Invalid escape");
        }
        state.pos = start;
    }
    var ch = state.current();
    if (ch !== 0x5D /* ] */ ) {
        state.lastIntValue = ch;
        state.advance();
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x62 /* b */ )) {
        state.lastIntValue = 0x08; /* <BS> */ 
        return true;
    }
    if (state.switchU && state.eat(0x2D /* - */ )) {
        state.lastIntValue = 0x2D; /* - */ 
        return true;
    }
    if (!state.switchU && state.eat(0x63 /* c */ )) {
        if (this.regexp_eatClassControlLetter(state)) return true;
        state.pos = start;
    }
    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {
        state.lastIntValue = ch % 0x20;
        state.advance();
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 /* x */ )) {
        if (this.regexp_eatFixedHexDigits(state, 2)) return true;
        if (state.switchU) state.raise("Invalid escape");
        state.pos = start;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while(isDecimalDigit(ch = state.current())){
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );
        state.advance();
    }
    return state.pos !== start;
};
function isDecimalDigit(ch) {
    return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while(isHexDigit(ch = state.current())){
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
    }
    return state.pos !== start;
};
function isHexDigit(ch) {
    return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;
}
function hexToInt(ch) {
    if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) return 10 + (ch - 0x41 /* A */ );
    if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) return 10 + (ch - 0x61 /* a */ );
    return ch - 0x30 /* 0 */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            else state.lastIntValue = n1 * 8 + n2;
        } else state.lastIntValue = n1;
        return true;
    }
    return false;
};
// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 0x30; /* 0 */ 
        state.advance();
        return true;
    }
    state.lastIntValue = 0;
    return false;
};
function isOctalDigit(ch) {
    return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;
}
// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for(var i = 0; i < length; ++i){
        var ch = state.current();
        if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
    }
    return true;
};
// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.
var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
    if (p.options.ranges) this.range = [
        p.start,
        p.end
    ];
};
// ## Tokenizer
var pp$9 = Parser.prototype;
// Move to the next token
pp$9.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
    if (this.options.onToken) this.options.onToken(new Token(this));
    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
};
pp$9.getToken = function() {
    this.next();
    return new Token(this);
};
// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined") pp$9[Symbol.iterator] = function() {
    var this$1 = this;
    return {
        next: function() {
            var token = this$1.getToken();
            return {
                done: token.type === types.eof,
                value: token
            };
        }
    };
};
// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).
pp$9.curContext = function() {
    return this.context[this.context.length - 1];
};
// Read a single token, updating the parser object's token-related
// properties.
pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) this.skipSpace();
    this.start = this.pos;
    if (this.options.locations) this.startLoc = this.curPosition();
    if (this.pos >= this.input.length) return this.finishToken(types.eof);
    if (curContext.override) return curContext.override(this);
    else this.readToken(this.fullCharCodeAtPos());
};
pp$9.readToken = function(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */ ) return this.readWord();
    return this.getTokenFromCode(code);
};
pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) return code;
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00;
};
pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
    this.pos = end + 2;
    if (this.options.locations) {
        lineBreakG.lastIndex = start;
        var match;
        while((match = lineBreakG.exec(this.input)) && match.index < this.pos){
            ++this.curLine;
            this.lineStart = match.index + match[0].length;
        }
    }
    if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};
pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while(this.pos < this.input.length && !isNewLine(ch))ch = this.input.charCodeAt(++this.pos);
    if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};
// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.
pp$9.skipSpace = function() {
    loop: while(this.pos < this.input.length){
        var ch = this.input.charCodeAt(this.pos);
        switch(ch){
            case 32:
            case 160:
                ++this.pos;
                break;
            case 13:
                if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
            case 10:
            case 8232:
            case 8233:
                ++this.pos;
                if (this.options.locations) {
                    ++this.curLine;
                    this.lineStart = this.pos;
                }
                break;
            case 47:
                switch(this.input.charCodeAt(this.pos + 1)){
                    case 42:
                        this.skipBlockComment();
                        break;
                    case 47:
                        this.skipLineComment(2);
                        break;
                    default:
                        break loop;
                }
                break;
            default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++this.pos;
                else break loop;
        }
    }
};
// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.
pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) this.endLoc = this.curPosition();
    var prevType = this.type;
    this.type = type;
    this.value = val;
    this.updateContext(prevType);
};
// ### Token reading
// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) return this.readNumber(true);
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        this.pos += 3;
        return this.finishToken(types.ellipsis);
    } else {
        ++this.pos;
        return this.finishToken(types.dot);
    }
};
pp$9.readToken_slash = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
    }
    if (next === 61) return this.finishOp(types.assign, 2);
    return this.finishOp(types.slash, 1);
};
pp$9.readToken_mult_modulo_exp = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;
    // exponentiation operator ** and **=
    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types.starstar;
        next = this.input.charCodeAt(this.pos + 2);
    }
    if (next === 61) return this.finishOp(types.assign, size + 1);
    return this.finishOp(tokentype, size);
};
pp$9.readToken_pipe_amp = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
        if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) return this.finishOp(types.assign, 3);
        }
        return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
    }
    if (next === 61) return this.finishOp(types.assign, 2);
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
};
pp$9.readToken_caret = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) return this.finishOp(types.assign, 2);
    return this.finishOp(types.bitwiseXOR, 1);
};
pp$9.readToken_plus_min = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            // A `-->` line comment
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
        }
        return this.finishOp(types.incDec, 2);
    }
    if (next === 61) return this.finishOp(types.assign, 2);
    return this.finishOp(types.plusMin, 1);
};
pp$9.readToken_lt_gt = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(types.assign, size + 1);
        return this.finishOp(types.bitShift, size);
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        // `<!--`, an XML-style comment that should be interpreted as a line comment
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
    }
    if (next === 61) size = 2;
    return this.finishOp(types.relational, size);
};
pp$9.readToken_eq_excl = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types.arrow);
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
};
pp$9.readToken_question = function() {
    var ecmaVersion = this.options.ecmaVersion;
    if (ecmaVersion >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) return this.finishOp(types.questionDot, 2);
        }
        if (next === 63) {
            if (ecmaVersion >= 12) {
                var next2$1 = this.input.charCodeAt(this.pos + 2);
                if (next2$1 === 61) return this.finishOp(types.assign, 3);
            }
            return this.finishOp(types.coalesce, 2);
        }
    }
    return this.finishOp(types.question, 1);
};
pp$9.getTokenFromCode = function(code) {
    switch(code){
        // The interpretation of a dot depends on whether it is followed
        // by a digit or another two dots.
        case 46:
            return this.readToken_dot();
        // Punctuation tokens.
        case 40:
            ++this.pos;
            return this.finishToken(types.parenL);
        case 41:
            ++this.pos;
            return this.finishToken(types.parenR);
        case 59:
            ++this.pos;
            return this.finishToken(types.semi);
        case 44:
            ++this.pos;
            return this.finishToken(types.comma);
        case 91:
            ++this.pos;
            return this.finishToken(types.bracketL);
        case 93:
            ++this.pos;
            return this.finishToken(types.bracketR);
        case 123:
            ++this.pos;
            return this.finishToken(types.braceL);
        case 125:
            ++this.pos;
            return this.finishToken(types.braceR);
        case 58:
            ++this.pos;
            return this.finishToken(types.colon);
        case 96:
            if (this.options.ecmaVersion < 6) break;
            ++this.pos;
            return this.finishToken(types.backQuote);
        case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) return this.readRadixNumber(16);
             // '0x', '0X' - hex number
            if (this.options.ecmaVersion >= 6) {
                if (next === 111 || next === 79) return this.readRadixNumber(8);
                 // '0o', '0O' - octal number
                if (next === 98 || next === 66) return this.readRadixNumber(2);
                 // '0b', '0B' - binary number
            }
        // Anything else beginning with a digit is an integer, octal
        // number, or float.
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
            return this.readNumber(false);
        // Quotes produce strings.
        case 34:
        case 39:
            return this.readString(code);
        // Operators are parsed inline in tiny state machines. '=' (61) is
        // often referred to. `finishOp` simply skips the amount of
        // characters it is given as second argument, and returns a token
        // of the type given by its first argument.
        case 47:
            return this.readToken_slash();
        case 37:
        case 42:
            return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
            return this.readToken_pipe_amp(code);
        case 94:
            return this.readToken_caret();
        case 43:
        case 45:
            return this.readToken_plus_min(code);
        case 60:
        case 62:
            return this.readToken_lt_gt(code);
        case 61:
        case 33:
            return this.readToken_eq_excl(code);
        case 63:
            return this.readToken_question();
        case 126:
            return this.finishOp(types.prefix, 1);
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
};
pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str);
};
pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for(;;){
        if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
        if (!escaped) {
            if (ch === "[") inClass = true;
            else if (ch === "]" && inClass) inClass = false;
            else if (ch === "/" && !inClass) break;
            escaped = ch === "\\";
        } else escaped = false;
        ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) this.unexpected(flagsStart);
    // Validate pattern
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);
    // Create Literal#value property value.
    var value = null;
    try {
        value = new RegExp(pattern, flags);
    } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
    }
    return this.finishToken(types.regexp, {
        pattern: pattern,
        flags: flags,
        value: value
    });
};
// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.
pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    // `len` is used for character escape sequences. In that case, disallow separators.
    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
    // and isn't fraction part nor exponent part. In that case, if the first digit
    // is zero then disallow separators.
    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
    var start = this.pos, total = 0, lastCode = 0;
    for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){
        var code = this.input.charCodeAt(this.pos), val = void 0;
        if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            if (lastCode === 95) this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            if (i === 0) this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            lastCode = code;
            continue;
        }
        if (code >= 97) val = code - 97 + 10;
        else if (code >= 65) val = code - 65 + 10;
        else if (code >= 48 && code <= 57) val = code - 48;
        else val = Infinity;
        if (val >= radix) break;
        lastCode = code;
        total = total * radix + val;
    }
    if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
    if (this.pos === start || len != null && this.pos - start !== len) return null;
    return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) return parseInt(str, 8);
    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
    return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
    if (typeof BigInt !== "function") return null;
    // `BigInt(value)` throws syntax error if the string contains numeric separators.
    return BigInt(str.replace(/_/g, ""));
}
pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
    return this.finishToken(types.num, val);
};
// Read an integer, octal integer, or floating-point number.
pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, undefined, true) === null) this.raise(start, "Invalid number");
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) this.raise(start, "Invalid number");
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
        return this.finishToken(types.num, val$1);
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;
    if (next === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) ++this.pos;
         // '+-'
        if (this.readInt(10) === null) this.raise(start, "Invalid number");
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types.num, val);
};
// Read a string value, interpreting backslash-escapes.
pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;
    if (ch === 123) {
        if (this.options.ecmaVersion < 6) this.unexpected();
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 0x10FFFF) this.invalidStringToken(codePos, "Code point out of bounds");
    } else code = this.readHexChar(4);
    return code;
};
function codePointToString$1(code) {
    // UTF-16 Decoding
    if (code <= 0xFFFF) return String.fromCharCode(code);
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}
pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for(;;){
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) break;
        if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
        } else {
            if (isNewLine(ch, this.options.ecmaVersion >= 10)) this.raise(this.start, "Unterminated string constant");
            ++this.pos;
        }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out);
};
// Reads template string tokens.
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
        this.readTmplToken();
    } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();
        else throw err;
    }
    this.inTemplateElement = false;
};
pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
    else this.raise(position, message);
};
pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for(;;){
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
                if (ch === 36) {
                    this.pos += 2;
                    return this.finishToken(types.dollarBraceL);
                } else {
                    ++this.pos;
                    return this.finishToken(types.backQuote);
                }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types.template, out);
        }
        if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
        } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch(ch){
                case 13:
                    if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
                case 10:
                    out += "\n";
                    break;
                default:
                    out += String.fromCharCode(ch);
                    break;
            }
            if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
            }
            chunkStart = this.pos;
        } else ++this.pos;
    }
};
// Reads a template token to search for the end, without validating any escape sequences
pp$9.readInvalidTemplateToken = function() {
    for(; this.pos < this.input.length; this.pos++)switch(this.input[this.pos]){
        case "\\":
            ++this.pos;
            break;
        case "$":
            if (this.input[this.pos + 1] !== "{") break;
        // falls through
        case "`":
            return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));
    }
    this.raise(this.start, "Unterminated template");
};
// Used to read escaped characters
pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch(ch){
        case 110:
            return "\n" // 'n' -> '\n'
            ;
        case 114:
            return "\r" // 'r' -> '\r'
            ;
        case 120:
            return String.fromCharCode(this.readHexChar(2)) // 'x'
            ;
        case 117:
            return codePointToString$1(this.readCodePoint()) // 'u'
            ;
        case 116:
            return "	" // 't' -> '\t'
            ;
        case 98:
            return "\b" // 'b' -> '\b'
            ;
        case 118:
            return "\v" // 'v' -> '\u000b'
            ;
        case 102:
            return "\f" // 'f' -> '\f'
            ;
        case 13:
            if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
             // '\r\n'
        case 10:
            if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
            }
            return "";
        case 56:
        case 57:
            if (inTemplate) {
                var codePos = this.pos - 1;
                this.invalidStringToken(codePos, "Invalid escape sequence in template string");
                return null;
            }
        default:
            if (ch >= 48 && ch <= 55) {
                var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                var octal = parseInt(octalStr, 8);
                if (octal > 255) {
                    octalStr = octalStr.slice(0, -1);
                    octal = parseInt(octalStr, 8);
                }
                this.pos += octalStr.length - 1;
                ch = this.input.charCodeAt(this.pos);
                if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
                return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) // Unicode new line characters after \ get removed from output in both
            // template literals and strings
            return "";
            return String.fromCharCode(ch);
    }
};
// Used to read character escape sequences ('\x', '\u', '\U').
pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) this.invalidStringToken(codePos, "Bad character escape sequence");
    return n;
};
// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.
pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while(this.pos < this.input.length){
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) this.pos += ch <= 0xffff ? 1 : 2;
        else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.invalidStringToken(escStart, "Invalid Unicode escape");
            word += codePointToString$1(esc);
            chunkStart = this.pos;
        } else break;
        first = false;
    }
    return word + this.input.slice(chunkStart, this.pos);
};
// Read an identifier or keyword token. Will check for reserved
// words when necessary.
pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) type = keywords$1[word];
    return this.finishToken(type, word);
};
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
var version = "7.4.1";
Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
};
// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
function parse(input, options) {
    return Parser.parse(input, options);
}
// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.
function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options);
}
// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.
function tokenizer(input, options) {
    return Parser.tokenizer(input, options);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7OXxh":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ "use strict";
/* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === undefined) throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) return false;
        // Detect buggy property enumeration order in older V8 versions.
        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = new String("abc"); // eslint-disable-line no-new-wrappers
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {};
        for(var i = 0; i < 10; i++)test2["_" + String.fromCharCode(i)] = i;
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join("") !== "0123456789") return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
        return true;
    } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
    }
}
module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from)if (hasOwnProperty.call(from, key)) to[key] = from[key];
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i = 0; i < symbols.length; i++)if (propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
        }
    }
    return to;
};

},{}],"4nNrL":[function(require,module,exports) {
"use strict";
var objIsRegex = require("f56d3e232f78a100");
exports = module.exports = parse;
var TOKEN_TYPES = exports.TOKEN_TYPES = {
    LINE_COMMENT: "//",
    BLOCK_COMMENT: "/**/",
    SINGLE_QUOTE: "'",
    DOUBLE_QUOTE: '"',
    TEMPLATE_QUOTE: "`",
    REGEXP: "//g"
};
var BRACKETS = exports.BRACKETS = {
    "(": ")",
    "{": "}",
    "[": "]"
};
var BRACKETS_REVERSED = {
    ")": "(",
    "}": "{",
    "]": "["
};
exports.parse = parse;
function parse(src, state, options) {
    options = options || {};
    state = state || exports.defaultState();
    var start = options.start || 0;
    var end = options.end || src.length;
    var index = start;
    while(index < end){
        try {
            parseChar(src[index], state);
        } catch (ex) {
            ex.index = index;
            throw ex;
        }
        index++;
    }
    return state;
}
exports.parseUntil = parseUntil;
function parseUntil(src, delimiter, options) {
    options = options || {};
    var start = options.start || 0;
    var index = start;
    var state = exports.defaultState();
    while(index < src.length){
        if ((options.ignoreNesting || !state.isNesting(options)) && matches(src, delimiter, index)) {
            var end = index;
            return {
                start: start,
                end: end,
                src: src.substring(start, end)
            };
        }
        try {
            parseChar(src[index], state);
        } catch (ex) {
            ex.index = index;
            throw ex;
        }
        index++;
    }
    var err = new Error("The end of the string was reached with no closing bracket found.");
    err.code = "CHARACTER_PARSER:END_OF_STRING_REACHED";
    err.index = index;
    throw err;
}
exports.parseChar = parseChar;
function parseChar(character, state) {
    if (character.length !== 1) {
        var err = new Error("Character must be a string of length 1");
        err.name = "InvalidArgumentError";
        err.code = "CHARACTER_PARSER:CHAR_LENGTH_NOT_ONE";
        throw err;
    }
    state = state || exports.defaultState();
    state.src += character;
    var wasComment = state.isComment();
    var lastChar = state.history ? state.history[0] : "";
    if (state.regexpStart) {
        if (character === "/" || character == "*") state.stack.pop();
        state.regexpStart = false;
    }
    switch(state.current()){
        case TOKEN_TYPES.LINE_COMMENT:
            if (character === "\n") state.stack.pop();
            break;
        case TOKEN_TYPES.BLOCK_COMMENT:
            if (state.lastChar === "*" && character === "/") state.stack.pop();
            break;
        case TOKEN_TYPES.SINGLE_QUOTE:
            if (character === "'" && !state.escaped) state.stack.pop();
            else if (character === "\\" && !state.escaped) state.escaped = true;
            else state.escaped = false;
            break;
        case TOKEN_TYPES.DOUBLE_QUOTE:
            if (character === '"' && !state.escaped) state.stack.pop();
            else if (character === "\\" && !state.escaped) state.escaped = true;
            else state.escaped = false;
            break;
        case TOKEN_TYPES.TEMPLATE_QUOTE:
            if (character === "`" && !state.escaped) {
                state.stack.pop();
                state.hasDollar = false;
            } else if (character === "\\" && !state.escaped) {
                state.escaped = true;
                state.hasDollar = false;
            } else if (character === "$" && !state.escaped) state.hasDollar = true;
            else if (character === "{" && state.hasDollar) state.stack.push(BRACKETS[character]);
            else {
                state.escaped = false;
                state.hasDollar = false;
            }
            break;
        case TOKEN_TYPES.REGEXP:
            if (character === "/" && !state.escaped) state.stack.pop();
            else if (character === "\\" && !state.escaped) state.escaped = true;
            else state.escaped = false;
            break;
        default:
            if (character in BRACKETS) state.stack.push(BRACKETS[character]);
            else if (character in BRACKETS_REVERSED) {
                if (state.current() !== character) {
                    var err = new SyntaxError("Mismatched Bracket: " + character);
                    err.code = "CHARACTER_PARSER:MISMATCHED_BRACKET";
                    throw err;
                }
                state.stack.pop();
            } else if (lastChar === "/" && character === "/") {
                // Don't include comments in history
                state.history = state.history.substr(1);
                state.stack.push(TOKEN_TYPES.LINE_COMMENT);
            } else if (lastChar === "/" && character === "*") {
                // Don't include comment in history
                state.history = state.history.substr(1);
                state.stack.push(TOKEN_TYPES.BLOCK_COMMENT);
            } else if (character === "/" && isRegexp(state.history)) {
                state.stack.push(TOKEN_TYPES.REGEXP);
                // N.B. if the next character turns out to be a `*` or a `/`
                //      then this isn't actually a regexp
                state.regexpStart = true;
            } else if (character === "'") state.stack.push(TOKEN_TYPES.SINGLE_QUOTE);
            else if (character === '"') state.stack.push(TOKEN_TYPES.DOUBLE_QUOTE);
            else if (character === "`") state.stack.push(TOKEN_TYPES.TEMPLATE_QUOTE);
            break;
    }
    if (!state.isComment() && !wasComment) state.history = character + state.history;
    state.lastChar = character; // store last character for ending block comments
    return state;
}
exports.defaultState = function() {
    return new State();
};
function State() {
    this.stack = [];
    this.regexpStart = false;
    this.escaped = false;
    this.hasDollar = false;
    this.src = "";
    this.history = "";
    this.lastChar = "";
}
State.prototype.current = function() {
    return this.stack[this.stack.length - 1];
};
State.prototype.isString = function() {
    return this.current() === TOKEN_TYPES.SINGLE_QUOTE || this.current() === TOKEN_TYPES.DOUBLE_QUOTE || this.current() === TOKEN_TYPES.TEMPLATE_QUOTE;
};
State.prototype.isComment = function() {
    return this.current() === TOKEN_TYPES.LINE_COMMENT || this.current() === TOKEN_TYPES.BLOCK_COMMENT;
};
State.prototype.isNesting = function(opts) {
    if (opts && opts.ignoreLineComment && this.stack.length === 1 && this.stack[0] === TOKEN_TYPES.LINE_COMMENT) // if we are only inside a line comment, and line comments are ignored
    // don't count it as nesting
    return false;
    return !!this.stack.length;
};
function matches(str, matcher, i) {
    if (objIsRegex(matcher)) return matcher.test(str.substr(i || 0));
    else return str.substr(i || 0, matcher.length) === matcher;
}
exports.isPunctuator = isPunctuator;
function isPunctuator(c) {
    if (!c) return true; // the start of a string is a punctuator
    var code = c.charCodeAt(0);
    switch(code){
        case 46:
        case 40:
        case 41:
        case 59:
        case 44:
        case 123:
        case 125:
        case 91:
        case 93:
        case 58:
        case 63:
        case 126:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 47:
        case 60:
        case 62:
        case 94:
        case 124:
        case 33:
        case 61:
            return true;
        default:
            return false;
    }
}
exports.isKeyword = isKeyword;
function isKeyword(id) {
    return id === "if" || id === "in" || id === "do" || id === "var" || id === "for" || id === "new" || id === "try" || id === "let" || id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum" || id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super" || id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import" || id === "default" || id === "finally" || id === "extends" || id === "function" || id === "continue" || id === "debugger" || id === "package" || id === "private" || id === "interface" || id === "instanceof" || id === "implements" || id === "protected" || id === "public" || id === "static";
}
function isRegexp(history) {
    //could be start of regexp or divide sign
    history = history.replace(/^\s*/, "");
    //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide
    if (history[0] === ")") return false;
    //unless it's a function expression, it's a regexp, so we assume it's a regexp
    if (history[0] === "}") return true;
    //any punctuation means it's a regexp
    if (isPunctuator(history[0])) return true;
    //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`)
    if (/^\w+\b/.test(history) && isKeyword(/^\w+\b/.exec(history)[0].split("").reverse().join(""))) return true;
    return false;
}

},{"f56d3e232f78a100":"cBe8p"}],"cBe8p":[function(require,module,exports) {
"use strict";
var callBound = require("5d96af94ba428cfc");
var hasToStringTag = require("a5e890a505b039e5")();
var has;
var $exec;
var isRegexMarker;
var badStringifier;
if (hasToStringTag) {
    has = callBound("Object.prototype.hasOwnProperty");
    $exec = callBound("RegExp.prototype.exec");
    isRegexMarker = {};
    var throwRegexMarker = function() {
        throw isRegexMarker;
    };
    badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") badStringifier[Symbol.toPrimitive] = throwRegexMarker;
}
var $toString = callBound("Object.prototype.toString");
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
module.exports = hasToStringTag ? function isRegex(value) {
    if (!value || typeof value !== "object") return false;
    var descriptor = gOPD(value, "lastIndex");
    var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
    if (!hasLastIndexDataProperty) return false;
    try {
        $exec(value, badStringifier);
    } catch (e) {
        return e === isRegexMarker;
    }
} : function isRegex(value) {
    // In older browsers, typeof regex incorrectly returns 'function'
    if (!value || typeof value !== "object" && typeof value !== "function") return false;
    return $toString(value) === regexClass;
};

},{"5d96af94ba428cfc":"5yYiF","a5e890a505b039e5":"9LdQ9"}],"khglH":[function(require,module,exports) {
"use strict";
module.exports = makeError;
function makeError(code, message, options) {
    var line = options.line;
    var column = options.column;
    var filename = options.filename;
    var src = options.src;
    var fullMessage;
    var location = line + (column ? ":" + column : "");
    if (src && line >= 1 && line <= src.split("\n").length) {
        var lines = src.split("\n");
        var start = Math.max(line - 3, 0);
        var end = Math.min(lines.length, line + 3);
        // Error context
        var context = lines.slice(start, end).map(function(text, i) {
            var curr = i + start + 1;
            var preamble = (curr == line ? "  > " : "    ") + curr + "| ";
            var out = preamble + text;
            if (curr === line && column > 0) {
                out += "\n";
                out += Array(preamble.length + column).join("-") + "^";
            }
            return out;
        }).join("\n");
        fullMessage = (filename || "Pug") + ":" + location + "\n" + context + "\n\n" + message;
    } else fullMessage = (filename || "Pug") + ":" + location + "\n\n" + message;
    var err = new Error(fullMessage);
    err.code = "PUG:" + code;
    err.msg = message;
    err.line = line;
    err.column = column;
    err.filename = filename;
    err.src = src;
    err.toJSON = function() {
        return {
            code: this.code,
            msg: this.msg,
            line: this.line,
            column: this.column,
            filename: this.filename
        };
    };
    return err;
}

},{}],"lywdA":[function(require,module,exports) {
"use strict";
var error = require("b32541d2acf6311b");
module.exports = stripComments;
function unexpectedToken(type, occasion, filename, line) {
    var msg = "`" + type + "` encountered when " + occasion;
    throw error("UNEXPECTED_TOKEN", msg, {
        filename: filename,
        line: line
    });
}
function stripComments(input, options) {
    options = options || {};
    // Default: strip unbuffered comments and leave buffered ones alone
    var stripUnbuffered = options.stripUnbuffered !== false;
    var stripBuffered = options.stripBuffered === true;
    var filename = options.filename;
    var out = [];
    // If we have encountered a comment token and are not sure if we have gotten
    // out of the comment or not
    var inComment = false;
    // If we are sure that we are in a block comment and all tokens except
    // `end-pipeless-text` should be ignored
    var inPipelessText = false;
    return input.filter(function(tok) {
        switch(tok.type){
            case "comment":
                if (inComment) unexpectedToken("comment", "already in a comment", filename, tok.line);
                else {
                    inComment = tok.buffer ? stripBuffered : stripUnbuffered;
                    return !inComment;
                }
            case "start-pipeless-text":
                if (!inComment) return true;
                if (inPipelessText) unexpectedToken("start-pipeless-text", "already in pipeless text mode", filename, tok.line);
                inPipelessText = true;
                return false;
            case "end-pipeless-text":
                if (!inComment) return true;
                if (!inPipelessText) unexpectedToken("end-pipeless-text", "not in pipeless text mode", filename, tok.line);
                inPipelessText = false;
                inComment = false;
                return false;
            // There might be a `text` right after `comment` but before
            // `start-pipeless-text`. Treat it accordingly.
            case "text":
                return !inComment;
            default:
                if (inPipelessText) return false;
                inComment = false;
                return true;
        }
    });
}

},{"b32541d2acf6311b":"khglH"}],"bqIvf":[function(require,module,exports) {
"use strict";
var assert = require("46ec3a9563898448");
var TokenStream = require("e71c59fd8affbb0d");
var error = require("5b83cd1647ab71d2");
var inlineTags = require("29d73b1a58b82ffd");
module.exports = parse;
module.exports.Parser = Parser;
function parse(tokens, options) {
    var parser = new Parser(tokens, options);
    var ast = parser.parse();
    return JSON.parse(JSON.stringify(ast));
}
/**
 * Initialize `Parser` with the given input `str` and `filename`.
 *
 * @param {String} str
 * @param {String} filename
 * @param {Object} options
 * @api public
 */ function Parser(tokens, options) {
    options = options || {};
    if (!Array.isArray(tokens)) throw new Error('Expected tokens to be an Array but got "' + typeof tokens + '"');
    if (typeof options !== "object") throw new Error('Expected "options" to be an object but got "' + typeof options + '"');
    this.tokens = new TokenStream(tokens);
    this.filename = options.filename;
    this.src = options.src;
    this.inMixin = 0;
    this.plugins = options.plugins || [];
}
/**
 * Parser prototype.
 */ Parser.prototype = {
    /**
   * Save original constructor
   */ constructor: Parser,
    error: function(code, message, token) {
        var err = error(code, message, {
            line: token.loc.start.line,
            column: token.loc.start.column,
            filename: this.filename,
            src: this.src
        });
        throw err;
    },
    /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */ advance: function() {
        return this.tokens.advance();
    },
    /**
   * Single token lookahead.
   *
   * @return {Object}
   * @api private
   */ peek: function() {
        return this.tokens.peek();
    },
    /**
   * `n` token lookahead.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */ lookahead: function(n) {
        return this.tokens.lookahead(n);
    },
    /**
   * Parse input returning a string of js for evaluation.
   *
   * @return {String}
   * @api public
   */ parse: function() {
        var block = this.emptyBlock(0);
        while("eos" != this.peek().type){
            if ("newline" == this.peek().type) this.advance();
            else if ("text-html" == this.peek().type) block.nodes = block.nodes.concat(this.parseTextHtml());
            else {
                var expr = this.parseExpr();
                if (expr) {
                    if (expr.type === "Block") block.nodes = block.nodes.concat(expr.nodes);
                    else block.nodes.push(expr);
                }
            }
        }
        return block;
    },
    /**
   * Expect the given type, or throw an exception.
   *
   * @param {String} type
   * @api private
   */ expect: function(type) {
        if (this.peek().type === type) return this.advance();
        else this.error("INVALID_TOKEN", 'expected "' + type + '", but got "' + this.peek().type + '"', this.peek());
    },
    /**
   * Accept the given `type`.
   *
   * @param {String} type
   * @api private
   */ accept: function(type) {
        if (this.peek().type === type) return this.advance();
    },
    initBlock: function(line, nodes) {
        /* istanbul ignore if */ if ((line | 0) !== line) throw new Error("`line` is not an integer");
        /* istanbul ignore if */ if (!Array.isArray(nodes)) throw new Error("`nodes` is not an array");
        return {
            type: "Block",
            nodes: nodes,
            line: line,
            filename: this.filename
        };
    },
    emptyBlock: function(line) {
        return this.initBlock(line, []);
    },
    runPlugin: function(context, tok) {
        var rest = [
            this
        ];
        for(var i = 2; i < arguments.length; i++)rest.push(arguments[i]);
        var pluginContext;
        for(var i = 0; i < this.plugins.length; i++){
            var plugin = this.plugins[i];
            if (plugin[context] && plugin[context][tok.type]) {
                if (pluginContext) throw new Error("Multiple plugin handlers found for context " + JSON.stringify(context) + ", token type " + JSON.stringify(tok.type));
                pluginContext = plugin[context];
            }
        }
        if (pluginContext) return pluginContext[tok.type].apply(pluginContext, rest);
    },
    /**
   *   tag
   * | doctype
   * | mixin
   * | include
   * | filter
   * | comment
   * | text
   * | text-html
   * | dot
   * | each
   * | code
   * | yield
   * | id
   * | class
   * | interpolation
   */ parseExpr: function() {
        switch(this.peek().type){
            case "tag":
                return this.parseTag();
            case "mixin":
                return this.parseMixin();
            case "block":
                return this.parseBlock();
            case "mixin-block":
                return this.parseMixinBlock();
            case "case":
                return this.parseCase();
            case "extends":
                return this.parseExtends();
            case "include":
                return this.parseInclude();
            case "doctype":
                return this.parseDoctype();
            case "filter":
                return this.parseFilter();
            case "comment":
                return this.parseComment();
            case "text":
            case "interpolated-code":
            case "start-pug-interpolation":
                return this.parseText({
                    block: true
                });
            case "text-html":
                return this.initBlock(this.peek().loc.start.line, this.parseTextHtml());
            case "dot":
                return this.parseDot();
            case "each":
                return this.parseEach();
            case "eachOf":
                return this.parseEachOf();
            case "code":
                return this.parseCode();
            case "blockcode":
                return this.parseBlockCode();
            case "if":
                return this.parseConditional();
            case "while":
                return this.parseWhile();
            case "call":
                return this.parseCall();
            case "interpolation":
                return this.parseInterpolation();
            case "yield":
                return this.parseYield();
            case "id":
            case "class":
                if (!this.peek().loc.start) debugger;
                this.tokens.defer({
                    type: "tag",
                    val: "div",
                    loc: this.peek().loc,
                    filename: this.filename
                });
                return this.parseExpr();
            default:
                var pluginResult = this.runPlugin("expressionTokens", this.peek());
                if (pluginResult) return pluginResult;
                this.error("INVALID_TOKEN", 'unexpected token "' + this.peek().type + '"', this.peek());
        }
    },
    parseDot: function() {
        this.advance();
        return this.parseTextBlock();
    },
    /**
   * Text
   */ parseText: function(options) {
        var tags = [];
        var lineno = this.peek().loc.start.line;
        var nextTok = this.peek();
        loop: while(true){
            switch(nextTok.type){
                case "text":
                    var tok = this.advance();
                    tags.push({
                        type: "Text",
                        val: tok.val,
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                case "interpolated-code":
                    var tok = this.advance();
                    tags.push({
                        type: "Code",
                        val: tok.val,
                        buffer: tok.buffer,
                        mustEscape: tok.mustEscape !== false,
                        isInline: true,
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                case "newline":
                    if (!options || !options.block) break loop;
                    var tok = this.advance();
                    var nextType = this.peek().type;
                    if (nextType === "text" || nextType === "interpolated-code") tags.push({
                        type: "Text",
                        val: "\n",
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                case "start-pug-interpolation":
                    this.advance();
                    tags.push(this.parseExpr());
                    this.expect("end-pug-interpolation");
                    break;
                default:
                    var pluginResult = this.runPlugin("textTokens", nextTok, tags);
                    if (pluginResult) break;
                    break loop;
            }
            nextTok = this.peek();
        }
        if (tags.length === 1) return tags[0];
        else return this.initBlock(lineno, tags);
    },
    parseTextHtml: function() {
        var nodes = [];
        var currentNode = null;
        loop: while(true)switch(this.peek().type){
            case "text-html":
                var text = this.advance();
                if (!currentNode) {
                    currentNode = {
                        type: "Text",
                        val: text.val,
                        filename: this.filename,
                        line: text.loc.start.line,
                        column: text.loc.start.column,
                        isHtml: true
                    };
                    nodes.push(currentNode);
                } else currentNode.val += "\n" + text.val;
                break;
            case "indent":
                var block = this.block();
                block.nodes.forEach(function(node) {
                    if (node.isHtml) {
                        if (!currentNode) {
                            currentNode = node;
                            nodes.push(currentNode);
                        } else currentNode.val += "\n" + node.val;
                    } else {
                        currentNode = null;
                        nodes.push(node);
                    }
                });
                break;
            case "code":
                currentNode = null;
                nodes.push(this.parseCode(true));
                break;
            case "newline":
                this.advance();
                break;
            default:
                break loop;
        }
        return nodes;
    },
    /**
   *   ':' expr
   * | block
   */ parseBlockExpansion: function() {
        var tok = this.accept(":");
        if (tok) {
            var expr = this.parseExpr();
            return expr.type === "Block" ? expr : this.initBlock(tok.loc.start.line, [
                expr
            ]);
        } else return this.block();
    },
    /**
   * case
   */ parseCase: function() {
        var tok = this.expect("case");
        var node = {
            type: "Case",
            expr: tok.val,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        var block = this.emptyBlock(tok.loc.start.line + 1);
        this.expect("indent");
        while("outdent" != this.peek().type)switch(this.peek().type){
            case "comment":
            case "newline":
                this.advance();
                break;
            case "when":
                block.nodes.push(this.parseWhen());
                break;
            case "default":
                block.nodes.push(this.parseDefault());
                break;
            default:
                var pluginResult = this.runPlugin("caseTokens", this.peek(), block);
                if (pluginResult) break;
                this.error("INVALID_TOKEN", 'Unexpected token "' + this.peek().type + '", expected "when", "default" or "newline"', this.peek());
        }
        this.expect("outdent");
        node.block = block;
        return node;
    },
    /**
   * when
   */ parseWhen: function() {
        var tok = this.expect("when");
        if (this.peek().type !== "newline") return {
            type: "When",
            expr: tok.val,
            block: this.parseBlockExpansion(),
            debug: false,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        else return {
            type: "When",
            expr: tok.val,
            debug: false,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * default
   */ parseDefault: function() {
        var tok = this.expect("default");
        return {
            type: "When",
            expr: "default",
            block: this.parseBlockExpansion(),
            debug: false,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * code
   */ parseCode: function(noBlock) {
        var tok = this.expect("code");
        assert(typeof tok.mustEscape === "boolean", "Please update to the newest version of pug-lexer.");
        var node = {
            type: "Code",
            val: tok.val,
            buffer: tok.buffer,
            mustEscape: tok.mustEscape !== false,
            isInline: !!noBlock,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        // todo: why is this here?  It seems like a hacky workaround
        if (node.val.match(/^ *else/)) node.debug = false;
        if (noBlock) return node;
        var block;
        // handle block
        block = "indent" == this.peek().type;
        if (block) {
            if (tok.buffer) this.error("BLOCK_IN_BUFFERED_CODE", "Buffered code cannot have a block attached to it", this.peek());
            node.block = this.block();
        }
        return node;
    },
    parseConditional: function() {
        var tok = this.expect("if");
        var node = {
            type: "Conditional",
            test: tok.val,
            consequent: this.emptyBlock(tok.loc.start.line),
            alternate: null,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        // handle block
        if ("indent" == this.peek().type) node.consequent = this.block();
        var currentNode = node;
        while(true){
            if (this.peek().type === "newline") this.expect("newline");
            else if (this.peek().type === "else-if") {
                tok = this.expect("else-if");
                currentNode = currentNode.alternate = {
                    type: "Conditional",
                    test: tok.val,
                    consequent: this.emptyBlock(tok.loc.start.line),
                    alternate: null,
                    line: tok.loc.start.line,
                    column: tok.loc.start.column,
                    filename: this.filename
                };
                if ("indent" == this.peek().type) currentNode.consequent = this.block();
            } else if (this.peek().type === "else") {
                this.expect("else");
                if (this.peek().type === "indent") currentNode.alternate = this.block();
                break;
            } else break;
        }
        return node;
    },
    parseWhile: function() {
        var tok = this.expect("while");
        var node = {
            type: "While",
            test: tok.val,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        // handle block
        if ("indent" == this.peek().type) node.block = this.block();
        else node.block = this.emptyBlock(tok.loc.start.line);
        return node;
    },
    /**
   * block code
   */ parseBlockCode: function() {
        var tok = this.expect("blockcode");
        var line = tok.loc.start.line;
        var column = tok.loc.start.column;
        var body = this.peek();
        var text = "";
        if (body.type === "start-pipeless-text") {
            this.advance();
            while(this.peek().type !== "end-pipeless-text"){
                tok = this.advance();
                switch(tok.type){
                    case "text":
                        text += tok.val;
                        break;
                    case "newline":
                        text += "\n";
                        break;
                    default:
                        var pluginResult = this.runPlugin("blockCodeTokens", tok, tok);
                        if (pluginResult) {
                            text += pluginResult;
                            break;
                        }
                        this.error("INVALID_TOKEN", "Unexpected token type: " + tok.type, tok);
                }
            }
            this.advance();
        }
        return {
            type: "Code",
            val: text,
            buffer: false,
            mustEscape: false,
            isInline: false,
            line: line,
            column: column,
            filename: this.filename
        };
    },
    /**
   * comment
   */ parseComment: function() {
        var tok = this.expect("comment");
        var block;
        if (block = this.parseTextBlock()) return {
            type: "BlockComment",
            val: tok.val,
            block: block,
            buffer: tok.buffer,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        else return {
            type: "Comment",
            val: tok.val,
            buffer: tok.buffer,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * doctype
   */ parseDoctype: function() {
        var tok = this.expect("doctype");
        return {
            type: "Doctype",
            val: tok.val,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    parseIncludeFilter: function() {
        var tok = this.expect("filter");
        var attrs = [];
        if (this.peek().type === "start-attributes") attrs = this.attrs();
        return {
            type: "IncludeFilter",
            name: tok.val,
            attrs: attrs,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * filter attrs? text-block
   */ parseFilter: function() {
        var tok = this.expect("filter");
        var block, attrs = [];
        if (this.peek().type === "start-attributes") attrs = this.attrs();
        if (this.peek().type === "text") {
            var textToken = this.advance();
            block = this.initBlock(textToken.loc.start.line, [
                {
                    type: "Text",
                    val: textToken.val,
                    line: textToken.loc.start.line,
                    column: textToken.loc.start.column,
                    filename: this.filename
                }
            ]);
        } else if (this.peek().type === "filter") block = this.initBlock(tok.loc.start.line, [
            this.parseFilter()
        ]);
        else block = this.parseTextBlock() || this.emptyBlock(tok.loc.start.line);
        return {
            type: "Filter",
            name: tok.val,
            block: block,
            attrs: attrs,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * each block
   */ parseEach: function() {
        var tok = this.expect("each");
        var node = {
            type: "Each",
            obj: tok.code,
            val: tok.val,
            key: tok.key,
            block: this.block(),
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        if (this.peek().type == "else") {
            this.advance();
            node.alternate = this.block();
        }
        return node;
    },
    parseEachOf: function() {
        var tok = this.expect("eachOf");
        var node = {
            type: "EachOf",
            obj: tok.code,
            val: tok.val,
            block: this.block(),
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        return node;
    },
    /**
   * 'extends' name
   */ parseExtends: function() {
        var tok = this.expect("extends");
        var path = this.expect("path");
        return {
            type: "Extends",
            file: {
                type: "FileReference",
                path: path.val.trim(),
                line: path.loc.start.line,
                column: path.loc.start.column,
                filename: this.filename
            },
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * 'block' name block
   */ parseBlock: function() {
        var tok = this.expect("block");
        var node = "indent" == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);
        node.type = "NamedBlock";
        node.name = tok.val.trim();
        node.mode = tok.mode;
        node.line = tok.loc.start.line;
        node.column = tok.loc.start.column;
        return node;
    },
    parseMixinBlock: function() {
        var tok = this.expect("mixin-block");
        if (!this.inMixin) this.error("BLOCK_OUTISDE_MIXIN", "Anonymous blocks are not allowed unless they are part of a mixin.", tok);
        return {
            type: "MixinBlock",
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    parseYield: function() {
        var tok = this.expect("yield");
        return {
            type: "YieldBlock",
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
    },
    /**
   * include block?
   */ parseInclude: function() {
        var tok = this.expect("include");
        var node = {
            type: "Include",
            file: {
                type: "FileReference",
                filename: this.filename
            },
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        var filters = [];
        while(this.peek().type === "filter")filters.push(this.parseIncludeFilter());
        var path = this.expect("path");
        node.file.path = path.val.trim();
        node.file.line = path.loc.start.line;
        node.file.column = path.loc.start.column;
        if ((/\.jade$/.test(node.file.path) || /\.pug$/.test(node.file.path)) && !filters.length) {
            node.block = "indent" == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);
            if (/\.jade$/.test(node.file.path)) console.warn(this.filename + ", line " + tok.loc.start.line + ':\nThe .jade extension is deprecated, use .pug for "' + node.file.path + '".');
        } else {
            node.type = "RawInclude";
            node.filters = filters;
            if (this.peek().type === "indent") this.error("RAW_INCLUDE_BLOCK", "Raw inclusion cannot contain a block", this.peek());
        }
        return node;
    },
    /**
   * call ident block
   */ parseCall: function() {
        var tok = this.expect("call");
        var name = tok.val;
        var args = tok.args;
        var mixin = {
            type: "Mixin",
            name: name,
            args: args,
            block: this.emptyBlock(tok.loc.start.line),
            call: true,
            attrs: [],
            attributeBlocks: [],
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        this.tag(mixin);
        if (mixin.code) {
            mixin.block.nodes.push(mixin.code);
            delete mixin.code;
        }
        if (mixin.block.nodes.length === 0) mixin.block = null;
        return mixin;
    },
    /**
   * mixin block
   */ parseMixin: function() {
        var tok = this.expect("mixin");
        var name = tok.val;
        var args = tok.args;
        if ("indent" == this.peek().type) {
            this.inMixin++;
            var mixin = {
                type: "Mixin",
                name: name,
                args: args,
                block: this.block(),
                call: false,
                line: tok.loc.start.line,
                column: tok.loc.start.column,
                filename: this.filename
            };
            this.inMixin--;
            return mixin;
        } else this.error("MIXIN_WITHOUT_BODY", "Mixin " + name + " declared without body", tok);
    },
    /**
   * indent (text | newline)* outdent
   */ parseTextBlock: function() {
        var tok = this.accept("start-pipeless-text");
        if (!tok) return;
        var block = this.emptyBlock(tok.loc.start.line);
        while(this.peek().type !== "end-pipeless-text"){
            var tok = this.advance();
            switch(tok.type){
                case "text":
                    block.nodes.push({
                        type: "Text",
                        val: tok.val,
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                case "newline":
                    block.nodes.push({
                        type: "Text",
                        val: "\n",
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                case "start-pug-interpolation":
                    block.nodes.push(this.parseExpr());
                    this.expect("end-pug-interpolation");
                    break;
                case "interpolated-code":
                    block.nodes.push({
                        type: "Code",
                        val: tok.val,
                        buffer: tok.buffer,
                        mustEscape: tok.mustEscape !== false,
                        isInline: true,
                        line: tok.loc.start.line,
                        column: tok.loc.start.column,
                        filename: this.filename
                    });
                    break;
                default:
                    var pluginResult = this.runPlugin("textBlockTokens", tok, block, tok);
                    if (pluginResult) break;
                    this.error("INVALID_TOKEN", "Unexpected token type: " + tok.type, tok);
            }
        }
        this.advance();
        return block;
    },
    /**
   * indent expr* outdent
   */ block: function() {
        var tok = this.expect("indent");
        var block = this.emptyBlock(tok.loc.start.line);
        while("outdent" != this.peek().type){
            if ("newline" == this.peek().type) this.advance();
            else if ("text-html" == this.peek().type) block.nodes = block.nodes.concat(this.parseTextHtml());
            else {
                var expr = this.parseExpr();
                if (expr.type === "Block") block.nodes = block.nodes.concat(expr.nodes);
                else block.nodes.push(expr);
            }
        }
        this.expect("outdent");
        return block;
    },
    /**
   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
   */ parseInterpolation: function() {
        var tok = this.advance();
        var tag = {
            type: "InterpolatedTag",
            expr: tok.val,
            selfClosing: false,
            block: this.emptyBlock(tok.loc.start.line),
            attrs: [],
            attributeBlocks: [],
            isInline: false,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        return this.tag(tag, {
            selfClosingAllowed: true
        });
    },
    /**
   * tag (attrs | class | id)* (text | code | ':')? newline* block?
   */ parseTag: function() {
        var tok = this.advance();
        var tag = {
            type: "Tag",
            name: tok.val,
            selfClosing: false,
            block: this.emptyBlock(tok.loc.start.line),
            attrs: [],
            attributeBlocks: [],
            isInline: inlineTags.indexOf(tok.val) !== -1,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename
        };
        return this.tag(tag, {
            selfClosingAllowed: true
        });
    },
    /**
   * Parse tag.
   */ tag: function(tag, options) {
        var seenAttrs = false;
        var attributeNames = [];
        var selfClosingAllowed = options && options.selfClosingAllowed;
        // (attrs | class | id)*
        out: while(true)switch(this.peek().type){
            case "id":
            case "class":
                var tok = this.advance();
                if (tok.type === "id") {
                    if (attributeNames.indexOf("id") !== -1) this.error("DUPLICATE_ID", 'Duplicate attribute "id" is not allowed.', tok);
                    attributeNames.push("id");
                }
                tag.attrs.push({
                    name: tok.type,
                    val: "'" + tok.val + "'",
                    line: tok.loc.start.line,
                    column: tok.loc.start.column,
                    filename: this.filename,
                    mustEscape: false
                });
                continue;
            case "start-attributes":
                if (seenAttrs) console.warn(this.filename + ", line " + this.peek().loc.start.line + ":\nYou should not have pug tags with multiple attributes.");
                seenAttrs = true;
                tag.attrs = tag.attrs.concat(this.attrs(attributeNames));
                continue;
            case "&attributes":
                var tok = this.advance();
                tag.attributeBlocks.push({
                    type: "AttributeBlock",
                    val: tok.val,
                    line: tok.loc.start.line,
                    column: tok.loc.start.column,
                    filename: this.filename
                });
                break;
            default:
                var pluginResult = this.runPlugin("tagAttributeTokens", this.peek(), tag, attributeNames);
                if (pluginResult) break;
                break out;
        }
        // check immediate '.'
        if ("dot" == this.peek().type) {
            tag.textOnly = true;
            this.advance();
        }
        // (text | code | ':')?
        switch(this.peek().type){
            case "text":
            case "interpolated-code":
                var text = this.parseText();
                if (text.type === "Block") tag.block.nodes.push.apply(tag.block.nodes, text.nodes);
                else tag.block.nodes.push(text);
                break;
            case "code":
                tag.block.nodes.push(this.parseCode(true));
                break;
            case ":":
                this.advance();
                var expr = this.parseExpr();
                tag.block = expr.type === "Block" ? expr : this.initBlock(tag.line, [
                    expr
                ]);
                break;
            case "newline":
            case "indent":
            case "outdent":
            case "eos":
            case "start-pipeless-text":
            case "end-pug-interpolation":
                break;
            case "slash":
                if (selfClosingAllowed) {
                    this.advance();
                    tag.selfClosing = true;
                    break;
                }
            default:
                var pluginResult = this.runPlugin("tagTokens", this.peek(), tag, options);
                if (pluginResult) break;
                this.error("INVALID_TOKEN", "Unexpected token `" + this.peek().type + "` expected `text`, `interpolated-code`, `code`, `:`" + (selfClosingAllowed ? ", `slash`" : "") + ", `newline` or `eos`", this.peek());
        }
        // newline*
        while("newline" == this.peek().type)this.advance();
        // block?
        if (tag.textOnly) tag.block = this.parseTextBlock() || this.emptyBlock(tag.line);
        else if ("indent" == this.peek().type) {
            var block = this.block();
            for(var i = 0, len = block.nodes.length; i < len; ++i)tag.block.nodes.push(block.nodes[i]);
        }
        return tag;
    },
    attrs: function(attributeNames) {
        this.expect("start-attributes");
        var attrs = [];
        var tok = this.advance();
        while(tok.type === "attribute"){
            if (tok.name !== "class" && attributeNames) {
                if (attributeNames.indexOf(tok.name) !== -1) this.error("DUPLICATE_ATTRIBUTE", 'Duplicate attribute "' + tok.name + '" is not allowed.', tok);
                attributeNames.push(tok.name);
            }
            attrs.push({
                name: tok.name,
                val: tok.val,
                line: tok.loc.start.line,
                column: tok.loc.start.column,
                filename: this.filename,
                mustEscape: tok.mustEscape !== false
            });
            tok = this.advance();
        }
        this.tokens.defer(tok);
        this.expect("end-attributes");
        return attrs;
    }
};

},{"46ec3a9563898448":"f3tT4","e71c59fd8affbb0d":"kMpyL","5b83cd1647ab71d2":"khglH","29d73b1a58b82ffd":"hrA3T"}],"kMpyL":[function(require,module,exports) {
"use strict";
module.exports = TokenStream;
function TokenStream(tokens) {
    if (!Array.isArray(tokens)) throw new TypeError("tokens must be passed to TokenStream as an array.");
    this._tokens = tokens;
}
TokenStream.prototype.lookahead = function(index) {
    if (this._tokens.length <= index) throw new Error("Cannot read past the end of a stream");
    return this._tokens[index];
};
TokenStream.prototype.peek = function() {
    if (this._tokens.length === 0) throw new Error("Cannot read past the end of a stream");
    return this._tokens[0];
};
TokenStream.prototype.advance = function() {
    if (this._tokens.length === 0) throw new Error("Cannot read past the end of a stream");
    return this._tokens.shift();
};
TokenStream.prototype.defer = function(token) {
    this._tokens.unshift(token);
};

},{}],"hrA3T":[function(require,module,exports) {
"use strict";
module.exports = [
    "a",
    "abbr",
    "acronym",
    "b",
    "br",
    "code",
    "em",
    "font",
    "i",
    "img",
    "ins",
    "kbd",
    "map",
    "samp",
    "small",
    "span",
    "strong",
    "sub",
    "sup"
];

},{}],"orJQ9":[function(require,module,exports) {
"use strict";
var fs = require("8d30043d3b11093f");
var path = require("5e633efce1df8e59");
var walk = require("cba07b329f014079");
var assign = require("45897319aa4594f2");
module.exports = load;
function load(ast, options) {
    options = getOptions(options);
    // clone the ast
    ast = JSON.parse(JSON.stringify(ast));
    return walk(ast, function(node) {
        if (node.str === undefined) {
            if (node.type === "Include" || node.type === "RawInclude" || node.type === "Extends") {
                var file = node.file;
                if (file.type !== "FileReference") throw new Error('Expected file.type to be "FileReference"');
                var path, str, raw;
                try {
                    path = options.resolve(file.path, file.filename, options);
                    file.fullPath = path;
                    raw = options.read(path, options);
                    str = raw.toString("utf8");
                } catch (ex) {
                    ex.message += "\n    at " + node.filename + " line " + node.line;
                    throw ex;
                }
                file.str = str;
                file.raw = raw;
                if (node.type === "Extends" || node.type === "Include") file.ast = load.string(str, assign({}, options, {
                    filename: path
                }));
            }
        }
    });
}
load.string = function loadString(src, options) {
    options = assign(getOptions(options), {
        src: src
    });
    var tokens = options.lex(src, options);
    var ast = options.parse(tokens, options);
    return load(ast, options);
};
load.file = function loadFile(filename, options) {
    options = assign(getOptions(options), {
        filename: filename
    });
    var str = options.read(filename).toString("utf8");
    return load.string(str, options);
};
load.resolve = function resolve(filename, source, options) {
    filename = filename.trim();
    if (filename[0] !== "/" && !source) throw new Error('the "filename" option is required to use includes and extends with "relative" paths');
    if (filename[0] === "/" && !options.basedir) throw new Error('the "basedir" option is required to use includes and extends with "absolute" paths');
    filename = path.join(filename[0] === "/" ? options.basedir : path.dirname(source.trim()), filename);
    return filename;
};
load.read = function read(filename, options) {
    return fs.readFileSync(filename);
};
load.validateOptions = function validateOptions(options) {
    /* istanbul ignore if */ if (typeof options !== "object") throw new TypeError("options must be an object");
    /* istanbul ignore if */ if (typeof options.lex !== "function") throw new TypeError("options.lex must be a function");
    /* istanbul ignore if */ if (typeof options.parse !== "function") throw new TypeError("options.parse must be a function");
    /* istanbul ignore if */ if (options.resolve && typeof options.resolve !== "function") throw new TypeError("options.resolve must be a function");
    /* istanbul ignore if */ if (options.read && typeof options.read !== "function") throw new TypeError("options.read must be a function");
};
function getOptions(options) {
    load.validateOptions(options);
    return assign({
        resolve: load.resolve,
        read: load.read
    }, options);
}

},{"8d30043d3b11093f":"jhUEF","5e633efce1df8e59":"loE3o","cba07b329f014079":"kOecN","45897319aa4594f2":"7OXxh"}],"kOecN":[function(require,module,exports) {
"use strict";
module.exports = walkAST;
function walkAST(ast, before, after, options) {
    if (after && typeof after === "object" && typeof options === "undefined") {
        options = after;
        after = null;
    }
    options = options || {
        includeDependencies: false
    };
    var parents = options.parents = options.parents || [];
    var replace = function replace(replacement) {
        if (Array.isArray(replacement) && !replace.arrayAllowed) throw new Error("replace() can only be called with an array if the last parent is a Block or NamedBlock");
        ast = replacement;
    };
    replace.arrayAllowed = parents[0] && (/^(Named)?Block$/.test(parents[0].type) || parents[0].type === "RawInclude" && ast.type === "IncludeFilter");
    if (before) {
        var result = before(ast, replace);
        if (result === false) return ast;
        else if (Array.isArray(ast)) // return right here to skip after() call on array
        return walkAndMergeNodes(ast);
    }
    parents.unshift(ast);
    switch(ast.type){
        case "NamedBlock":
        case "Block":
            ast.nodes = walkAndMergeNodes(ast.nodes);
            break;
        case "Case":
        case "Filter":
        case "Mixin":
        case "Tag":
        case "InterpolatedTag":
        case "When":
        case "Code":
        case "While":
            if (ast.block) ast.block = walkAST(ast.block, before, after, options);
            break;
        case "Each":
            if (ast.block) ast.block = walkAST(ast.block, before, after, options);
            if (ast.alternate) ast.alternate = walkAST(ast.alternate, before, after, options);
            break;
        case "EachOf":
            if (ast.block) ast.block = walkAST(ast.block, before, after, options);
            break;
        case "Conditional":
            if (ast.consequent) ast.consequent = walkAST(ast.consequent, before, after, options);
            if (ast.alternate) ast.alternate = walkAST(ast.alternate, before, after, options);
            break;
        case "Include":
            walkAST(ast.block, before, after, options);
            walkAST(ast.file, before, after, options);
            break;
        case "Extends":
            walkAST(ast.file, before, after, options);
            break;
        case "RawInclude":
            ast.filters = walkAndMergeNodes(ast.filters);
            walkAST(ast.file, before, after, options);
            break;
        case "Attrs":
        case "BlockComment":
        case "Comment":
        case "Doctype":
        case "IncludeFilter":
        case "MixinBlock":
        case "YieldBlock":
        case "Text":
            break;
        case "FileReference":
            if (options.includeDependencies && ast.ast) walkAST(ast.ast, before, after, options);
            break;
        default:
            throw new Error("Unexpected node type " + ast.type);
    }
    parents.shift();
    after && after(ast, replace);
    return ast;
    function walkAndMergeNodes(nodes) {
        return nodes.reduce(function(nodes, node) {
            var result = walkAST(node, before, after, options);
            if (Array.isArray(result)) return nodes.concat(result);
            else return nodes.concat([
                result
            ]);
        }, []);
    }
}

},{}],"4Tb6B":[function(require,module,exports) {
"use strict";
exports.runFilter = require("11ce3b1b11299c7b");
exports.handleFilters = require("a120c6bc62f36dee");

},{"11ce3b1b11299c7b":"2y7kz","a120c6bc62f36dee":"kXQEE"}],"2y7kz":[function(require,module,exports) {
var process = require("92c7c5fc0e59f8");
"use strict";
var jstransformer = require("425f651e3c1a9261");
var resolve = require("52d57585a4f1b56d");
module.exports = filter;
function getMinifyTransformerName(outputFormat) {
    switch(outputFormat){
        case "js":
            return "uglify-js";
        case "css":
            return "clean-css";
    }
}
function filter(name, str, options, currentDirectory, funcName) {
    funcName = funcName || "render";
    var trPath;
    try {
        try {
            trPath = resolve.sync("jstransformer-" + name, {
                basedir: currentDirectory || process.cwd()
            });
        } catch (ex) {
            trPath = undefined("jstransformer-" + name);
        }
    } catch (ex) {
        var err = new Error('unknown filter ":' + name + '"');
        err.code = "UNKNOWN_FILTER";
        throw err;
    }
    var tr = jstransformer(require(trPath));
    // TODO: we may want to add a way for people to separately specify "locals"
    var result = tr[funcName](str, options, options).body;
    if (options && options.minify) {
        var minifyTranformer = getMinifyTransformerName(tr.outputFormat);
        if (minifyTranformer) try {
            result = filter(minifyTranformer, result, null, currentDirectory);
        } catch (ex) {
        // better to fail to minify than output nothing
        }
    }
    return result;
}

},{"92c7c5fc0e59f8":"d5jf4","425f651e3c1a9261":"5XEsN","52d57585a4f1b56d":"c6mMC"}],"5XEsN":[function(require,module,exports) {
"use strict";
var fs = require("d34fee3fed546a07");
var assert = require("d7fb9f7b7ba0d172");
var Promise = require("f0192dc56ba57021");
var isPromise = require("f2b77d0d3457d7a4");
var tr = module.exports = function(transformer) {
    return new Transformer(transformer);
};
tr.Transformer = Transformer;
tr.normalizeFn = normalizeFn;
tr.normalizeFnAsync = normalizeFnAsync;
tr.normalize = normalize;
tr.normalizeAsync = normalizeAsync;
if (fs.readFile) {
    tr.readFile = Promise.denodeify(fs.readFile);
    tr.readFileSync = fs.readFileSync;
} else {
    tr.readFile = function() {
        throw new Error("fs.readFile unsupported");
    };
    tr.readFileSync = function() {
        throw new Error("fs.readFileSync unsupported");
    };
}
function normalizeFn(result) {
    if (typeof result === "function") return {
        fn: result,
        dependencies: []
    };
    else if (result && typeof result === "object" && typeof result.fn === "function") {
        if ("dependencies" in result) {
            if (!Array.isArray(result.dependencies)) throw new Error("Result should have a dependencies property that is an array");
        } else result.dependencies = [];
        return result;
    } else throw new Error("Invalid result object from transform.");
}
function normalizeFnAsync(result, cb) {
    return Promise.resolve(result).then(function(result) {
        if (result && isPromise(result.fn)) return result.fn.then(function(fn) {
            result.fn = fn;
            return result;
        });
        return result;
    }).then(tr.normalizeFn).nodeify(cb);
}
function normalize(result) {
    if (typeof result === "string") return {
        body: result,
        dependencies: []
    };
    else if (result && typeof result === "object" && typeof result.body === "string") {
        if ("dependencies" in result) {
            if (!Array.isArray(result.dependencies)) throw new Error("Result should have a dependencies property that is an array");
        } else result.dependencies = [];
        return result;
    } else throw new Error("Invalid result object from transform.");
}
function normalizeAsync(result, cb) {
    return Promise.resolve(result).then(function(result) {
        if (result && isPromise(result.body)) return result.body.then(function(body) {
            result.body = body;
            return result;
        });
        return result;
    }).then(tr.normalize).nodeify(cb);
}
function Transformer(tr) {
    assert(tr, "Transformer must be an object");
    assert(typeof tr.name === "string", "Transformer must have a name");
    assert(typeof tr.outputFormat === "string", "Transformer must have an output format");
    assert([
        "compile",
        "compileAsync",
        "compileFile",
        "compileFileAsync",
        "compileClient",
        "compileClientAsync",
        "compileFileClient",
        "compileFileClientAsync",
        "render",
        "renderAsync",
        "renderFile",
        "renderFileAsync"
    ].some(function(method) {
        return typeof tr[method] === "function";
    }), "Transformer must implement at least one of the potential methods.");
    this._tr = tr;
    this.name = this._tr.name;
    this.outputFormat = this._tr.outputFormat;
    this.inputFormats = this._tr.inputFormats || [
        this.name
    ];
}
var fallbacks = {
    compile: [
        "compile",
        "render"
    ],
    compileAsync: [
        "compileAsync",
        "compile",
        "render"
    ],
    compileFile: [
        "compileFile",
        "compile",
        "renderFile",
        "render"
    ],
    compileFileAsync: [
        "compileFileAsync",
        "compileFile",
        "compileAsync",
        "compile",
        "renderFile",
        "render"
    ],
    compileClient: [
        "compileClient"
    ],
    compileClientAsync: [
        "compileClientAsync",
        "compileClient"
    ],
    compileFileClient: [
        "compileFileClient",
        "compileClient"
    ],
    compileFileClientAsync: [
        "compileFileClientAsync",
        "compileFileClient",
        "compileClientAsync",
        "compileClient"
    ],
    render: [
        "render",
        "compile"
    ],
    renderAsync: [
        "renderAsync",
        "render",
        "compileAsync",
        "compile"
    ],
    renderFile: [
        "renderFile",
        "render",
        "compileFile",
        "compile"
    ],
    renderFileAsync: [
        "renderFileAsync",
        "renderFile",
        "renderAsync",
        "render",
        "compileFileAsync",
        "compileFile",
        "compileAsync",
        "compile"
    ]
};
Transformer.prototype._hasMethod = function(method) {
    return typeof this._tr[method] === "function";
};
Transformer.prototype.can = function(method) {
    return fallbacks[method].some((function(method) {
        return this._hasMethod(method);
    }).bind(this));
};
/* COMPILE */ Transformer.prototype.compile = function(str, options) {
    if (!this._hasMethod("compile")) {
        if (this.can("render")) {
            var _this = this;
            return {
                fn: function(locals) {
                    return tr.normalize(_this._tr.render(str, options, locals)).body;
                },
                dependencies: []
            };
        }
        if (this.can("compileAsync")) throw new Error('The Transform "' + this.name + '" does not support synchronous compilation');
        else if (this.can("compileFileAsync")) throw new Error('The Transform "' + this.name + '" does not support compiling plain strings');
        else throw new Error('The Transform "' + this.name + '" does not support compilation');
    }
    return tr.normalizeFn(this._tr.compile(str, options));
};
Transformer.prototype.compileAsync = function(str, options, cb) {
    if (!this.can("compileAsync")) return Promise.reject(new Error('The Transform "' + this.name + '" does not support compiling plain strings')).nodeify(cb);
    if (this._hasMethod("compileAsync")) return tr.normalizeFnAsync(this._tr.compileAsync(str, options), cb);
    else return tr.normalizeFnAsync(this.compile(str, options), cb);
};
Transformer.prototype.compileFile = function(filename, options) {
    if (!this.can("compileFile")) throw new Error('The Transform "' + this.name + '" does not support synchronous compilation');
    if (this._hasMethod("compileFile")) return tr.normalizeFn(this._tr.compileFile(filename, options));
    else if (this._hasMethod("renderFile")) return tr.normalizeFn((function(locals) {
        return tr.normalize(this._tr.renderFile(filename, options, locals)).body;
    }).bind(this));
    else {
        if (!options) options = {};
        if (options.filename === undefined) options.filename = filename;
        return this.compile(tr.readFileSync(filename, "utf8"), options);
    }
};
Transformer.prototype.compileFileAsync = function(filename, options, cb) {
    if (!this.can("compileFileAsync")) return Promise.reject(new Error('The Transform "' + this.name + '" does not support compilation'));
    if (this._hasMethod("compileFileAsync")) return tr.normalizeFnAsync(this._tr.compileFileAsync(filename, options), cb);
    else if (this._hasMethod("compileFile") || this._hasMethod("renderFile")) return tr.normalizeFnAsync(this.compileFile(filename, options), cb);
    else {
        if (!options) options = {};
        if (options.filename === undefined) options.filename = filename;
        return tr.normalizeFnAsync(tr.readFile(filename, "utf8").then((function(str) {
            if (this._hasMethod("compileAsync")) return this._tr.compileAsync(str, options);
            else return this.compile(str, options);
        }).bind(this)), cb);
    }
};
/* COMPILE CLIENT */ Transformer.prototype.compileClient = function(str, options) {
    if (!this.can("compileClient")) {
        if (this.can("compileClientAsync")) throw new Error('The Transform "' + this.name + '" does not support compiling for the client synchronously.');
        else if (this.can("compileFileClientAsync")) throw new Error('The Transform "' + this.name + '" does not support compiling for the client from a string.');
        else throw new Error('The Transform "' + this.name + '" does not support compiling for the client');
    }
    return tr.normalize(this._tr.compileClient(str, options));
};
Transformer.prototype.compileClientAsync = function(str, options, cb) {
    if (!this.can("compileClientAsync")) {
        if (this.can("compileFileClientAsync")) return Promise.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client from a string.')).nodeify(cb);
        else return Promise.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client')).nodeify(cb);
    }
    if (this._hasMethod("compileClientAsync")) return tr.normalizeAsync(this._tr.compileClientAsync(str, options), cb);
    else return tr.normalizeAsync(this._tr.compileClient(str, options), cb);
};
Transformer.prototype.compileFileClient = function(filename, options) {
    if (!this.can("compileFileClient")) {
        if (this.can("compileFileClientAsync")) throw new Error('The Transform "' + this.name + '" does not support compiling for the client synchronously.');
        else throw new Error('The Transform "' + this.name + '" does not support compiling for the client');
    }
    if (this._hasMethod("compileFileClient")) return tr.normalize(this._tr.compileFileClient(filename, options));
    else {
        if (!options) options = {};
        if (options.filename === undefined) options.filename = filename;
        return tr.normalize(this._tr.compileClient(tr.readFileSync(filename, "utf8"), options));
    }
};
Transformer.prototype.compileFileClientAsync = function(filename, options, cb) {
    if (!this.can("compileFileClientAsync")) return Promise.reject(new Error('The Transform "' + this.name + '" does not support compiling for the client')).nodeify(cb);
    if (this._hasMethod("compileFileClientAsync")) return tr.normalizeAsync(this._tr.compileFileClientAsync(filename, options), cb);
    else if (this._hasMethod("compileFileClient")) return tr.normalizeAsync(this._tr.compileFileClient(filename, options), cb);
    else {
        if (!options) options = {};
        if (options.filename === undefined) options.filename = filename;
        return tr.normalizeAsync(tr.readFile(filename, "utf8").then((function(str) {
            if (this._hasMethod("compileClientAsync")) return this._tr.compileClientAsync(str, options);
            else return this._tr.compileClient(str, options);
        }).bind(this)), cb);
    }
};
/* RENDER */ Transformer.prototype.render = function(str, options, locals) {
    if (!this.can("render")) {
        if (this.can("renderAsync")) throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
        else if (this.can("renderFileAsync")) throw new Error('The Transform "' + this.name + '" does not support rendering from a string.');
        else throw new Error('The Transform "' + this.name + '" does not support rendering');
    }
    if (this._hasMethod("render")) return tr.normalize(this._tr.render(str, options, locals));
    else {
        var compiled = tr.normalizeFn(this._tr.compile(str, options));
        var body = compiled.fn(locals || options);
        if (typeof body !== "string") throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
        return tr.normalize({
            body: body,
            dependencies: compiled.dependencies
        });
    }
};
Transformer.prototype.renderAsync = function(str, options, locals, cb) {
    if (typeof locals === "function") {
        cb = locals;
        locals = options;
    }
    if (!this.can("renderAsync")) {
        if (this.can("renderFileAsync")) return Promise.reject(new Error('The Transform "' + this.name + '" does not support rendering from a string.')).nodeify(cb);
        else return Promise.reject(new Error('The Transform "' + this.name + '" does not support rendering')).nodeify(cb);
    }
    if (this._hasMethod("renderAsync")) return tr.normalizeAsync(this._tr.renderAsync(str, options, locals), cb);
    else if (this._hasMethod("render")) return tr.normalizeAsync(this._tr.render(str, options, locals), cb);
    else return tr.normalizeAsync(this.compileAsync(str, options).then(function(compiled) {
        return {
            body: compiled.fn(locals || options),
            dependencies: compiled.dependencies
        };
    }), cb);
};
Transformer.prototype.renderFile = function(filename, options, locals) {
    if (!this.can("renderFile")) throw new Error('The Transform "' + this.name + '" does not support rendering synchronously.');
    if (this._hasMethod("renderFile")) return tr.normalize(this._tr.renderFile(filename, options, locals));
    else if (this._hasMethod("render")) {
        if (!options) options = {};
        if (options.filename === undefined) options.filename = filename;
        return tr.normalize(this._tr.render(tr.readFileSync(filename, "utf8"), options, locals));
    } else {
        var compiled = this.compileFile(filename, options);
        return tr.normalize({
            body: compiled.fn(locals || options),
            dependencies: compiled.dependencies
        });
    }
};
Transformer.prototype.renderFileAsync = function(filename, options, locals, cb) {
    if (!this.can("renderFileAsync")) throw new Error('The Transform "' + this.name + '" does not support rendering.');
    if (typeof locals === "function") {
        cb = locals;
        locals = options;
    }
    if (this._hasMethod("renderFileAsync")) return tr.normalizeAsync(this._tr.renderFileAsync(filename, options, locals), cb);
    else if (this._hasMethod("renderFile")) return tr.normalizeAsync(this._tr.renderFile(filename, options, locals), cb);
    else if (this._hasMethod("compile") || this._hasMethod("compileAsync") || this._hasMethod("compileFile") || this._hasMethod("compileFileAsync")) return tr.normalizeAsync(this.compileFileAsync(filename, options).then(function(compiled) {
        return {
            body: compiled.fn(locals || options),
            dependencies: compiled.dependencies
        };
    }), cb);
    else {
        if (!options) options = {};
        if (options.filename === undefined) options.filename = filename;
        return tr.normalizeAsync(tr.readFile(filename, "utf8").then((function(str) {
            return this.renderAsync(str, options, locals);
        }).bind(this)), cb);
    }
};

},{"d34fee3fed546a07":"jhUEF","d7fb9f7b7ba0d172":"f3tT4","f0192dc56ba57021":"1wol3","f2b77d0d3457d7a4":"hrWMv"}],"1wol3":[function(require,module,exports) {
"use strict";
module.exports = require("c168b9e5bc29aed0");

},{"c168b9e5bc29aed0":"cqzoM"}],"cqzoM":[function(require,module,exports) {
"use strict";
module.exports = require("7d3739c3cbb2b288");
require("ba154db7576b9393");
require("aaa90c909592baaa");
require("7437d89979c6cc77");
require("459519e48b40e024");
require("6a772a21d87eeca6");

},{"7d3739c3cbb2b288":"3Ytq6","ba154db7576b9393":"jgV1b","aaa90c909592baaa":"haCY5","7437d89979c6cc77":"hzlcL","459519e48b40e024":"8LfHK","6a772a21d87eeca6":"lXbR9"}],"3Ytq6":[function(require,module,exports) {
"use strict";
var asap = require("65c37b13cf8aab4d");
function noop() {}
// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable
// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.
// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};
function getThen(obj) {
    try {
        return obj.then;
    } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}
function tryCallOne(fn, a) {
    try {
        return fn(a);
    } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}
function tryCallTwo(fn, a, b) {
    try {
        fn(a, b);
    } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
    }
}
module.exports = Promise;
function Promise(fn) {
    if (typeof this !== "object") throw new TypeError("Promises must be constructed via new");
    if (typeof fn !== "function") throw new TypeError("Promise constructor's argument is not a function");
    this._40 = 0;
    this._65 = 0;
    this._55 = null;
    this._72 = null;
    if (fn === noop) return;
    doResolve(fn, this);
}
Promise._37 = null;
Promise._87 = null;
Promise._61 = noop;
Promise.prototype.then = function(onFulfilled, onRejected) {
    if (this.constructor !== Promise) return safeThen(this, onFulfilled, onRejected);
    var res = new Promise(noop);
    handle(this, new Handler(onFulfilled, onRejected, res));
    return res;
};
function safeThen(self, onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
        var res = new Promise(noop);
        res.then(resolve, reject);
        handle(self, new Handler(onFulfilled, onRejected, res));
    });
}
function handle(self, deferred) {
    while(self._65 === 3)self = self._55;
    if (Promise._37) Promise._37(self);
    if (self._65 === 0) {
        if (self._40 === 0) {
            self._40 = 1;
            self._72 = deferred;
            return;
        }
        if (self._40 === 1) {
            self._40 = 2;
            self._72 = [
                self._72,
                deferred
            ];
            return;
        }
        self._72.push(deferred);
        return;
    }
    handleResolved(self, deferred);
}
function handleResolved(self, deferred) {
    asap(function() {
        var cb = self._65 === 1 ? deferred.onFulfilled : deferred.onRejected;
        if (cb === null) {
            if (self._65 === 1) resolve(deferred.promise, self._55);
            else reject(deferred.promise, self._55);
            return;
        }
        var ret = tryCallOne(cb, self._55);
        if (ret === IS_ERROR) reject(deferred.promise, LAST_ERROR);
        else resolve(deferred.promise, ret);
    });
}
function resolve(self, newValue) {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) return reject(self, new TypeError("A promise cannot be resolved with itself."));
    if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
        var then = getThen(newValue);
        if (then === IS_ERROR) return reject(self, LAST_ERROR);
        if (then === self.then && newValue instanceof Promise) {
            self._65 = 3;
            self._55 = newValue;
            finale(self);
            return;
        } else if (typeof then === "function") {
            doResolve(then.bind(newValue), self);
            return;
        }
    }
    self._65 = 1;
    self._55 = newValue;
    finale(self);
}
function reject(self, newValue) {
    self._65 = 2;
    self._55 = newValue;
    if (Promise._87) Promise._87(self, newValue);
    finale(self);
}
function finale(self) {
    if (self._40 === 1) {
        handle(self, self._72);
        self._72 = null;
    }
    if (self._40 === 2) {
        for(var i = 0; i < self._72.length; i++)handle(self, self._72[i]);
        self._72 = null;
    }
}
function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
    this.onRejected = typeof onRejected === "function" ? onRejected : null;
    this.promise = promise;
}
/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */ function doResolve(fn, promise) {
    var done = false;
    var res = tryCallTwo(fn, function(value) {
        if (done) return;
        done = true;
        resolve(promise, value);
    }, function(reason) {
        if (done) return;
        done = true;
        reject(promise, reason);
    });
    if (!done && res === IS_ERROR) {
        done = true;
        reject(promise, LAST_ERROR);
    }
}

},{"65c37b13cf8aab4d":"9iMrj"}],"9iMrj":[function(require,module,exports) {
var global = arguments[3];
"use strict";
// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}
var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;
// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while(index < queue.length){
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for(var scan = 0, newLength = queue.length - index; scan < newLength; scan++)queue[scan] = queue[scan + index];
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}
// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
/* globals self */ var scope = typeof global !== "undefined" ? global : self;
var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") requestFlush = makeRequestCallFromMutationObserver(flush);
else requestFlush = makeRequestCallFromTimer(flush);
// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.js’s
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;
// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {
        characterData: true
    });
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}
// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html
// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.
// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }
// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.
// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }
// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.
// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.
function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}
// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer; // ASAP was originally a nextTick shim included in Q. This was factored out
 // into this ASAP package. It was later adapted to RSVP which made further
 // amendments. These decisions, particularly to marginalize MessageChannel and
 // to capture the MutationObserver implementation in a closure, were integrated
 // back into ASAP proper.
 // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

},{}],"jgV1b":[function(require,module,exports) {
"use strict";
var Promise = require("9acaad39d0f3e83a");
module.exports = Promise;
Promise.prototype.done = function(onFulfilled, onRejected) {
    var self = arguments.length ? this.then.apply(this, arguments) : this;
    self.then(null, function(err) {
        setTimeout(function() {
            throw err;
        }, 0);
    });
};

},{"9acaad39d0f3e83a":"3Ytq6"}],"haCY5":[function(require,module,exports) {
"use strict";
var Promise = require("28e05bec0c67476f");
module.exports = Promise;
Promise.prototype["finally"] = function(f) {
    return this.then(function(value) {
        return Promise.resolve(f()).then(function() {
            return value;
        });
    }, function(err) {
        return Promise.resolve(f()).then(function() {
            throw err;
        });
    });
};

},{"28e05bec0c67476f":"3Ytq6"}],"hzlcL":[function(require,module,exports) {
"use strict";
//This file contains the ES6 extensions to the core Promises/A+ API
var Promise = require("5ca23266422c4473");
module.exports = Promise;
/* Static Functions */ var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise("");
function valuePromise(value) {
    var p = new Promise(Promise._61);
    p._65 = 1;
    p._55 = value;
    return p;
}
Promise.resolve = function(value) {
    if (value instanceof Promise) return value;
    if (value === null) return NULL;
    if (value === undefined) return UNDEFINED;
    if (value === true) return TRUE;
    if (value === false) return FALSE;
    if (value === 0) return ZERO;
    if (value === "") return EMPTYSTRING;
    if (typeof value === "object" || typeof value === "function") try {
        var then = value.then;
        if (typeof then === "function") return new Promise(then.bind(value));
    } catch (ex) {
        return new Promise(function(resolve, reject) {
            reject(ex);
        });
    }
    return valuePromise(value);
};
Promise.all = function(arr) {
    var args = Array.prototype.slice.call(arr);
    return new Promise(function(resolve, reject) {
        if (args.length === 0) return resolve([]);
        var remaining = args.length;
        function res(i, val) {
            if (val && (typeof val === "object" || typeof val === "function")) {
                if (val instanceof Promise && val.then === Promise.prototype.then) {
                    while(val._65 === 3)val = val._55;
                    if (val._65 === 1) return res(i, val._55);
                    if (val._65 === 2) reject(val._55);
                    val.then(function(val) {
                        res(i, val);
                    }, reject);
                    return;
                } else {
                    var then = val.then;
                    if (typeof then === "function") {
                        var p = new Promise(then.bind(val));
                        p.then(function(val) {
                            res(i, val);
                        }, reject);
                        return;
                    }
                }
            }
            args[i] = val;
            if (--remaining === 0) resolve(args);
        }
        for(var i = 0; i < args.length; i++)res(i, args[i]);
    });
};
Promise.reject = function(value) {
    return new Promise(function(resolve, reject) {
        reject(value);
    });
};
Promise.race = function(values) {
    return new Promise(function(resolve, reject) {
        values.forEach(function(value) {
            Promise.resolve(value).then(resolve, reject);
        });
    });
};
/* Prototype Methods */ Promise.prototype["catch"] = function(onRejected) {
    return this.then(null, onRejected);
};

},{"5ca23266422c4473":"3Ytq6"}],"8LfHK":[function(require,module,exports) {
"use strict";
// This file contains then/promise specific extensions that are only useful
// for node.js interop
var Promise = require("866a87f3062826f8");
var asap = require("d53e249cb4ff08e4");
module.exports = Promise;
/* Static Functions */ Promise.denodeify = function(fn, argumentCount) {
    if (typeof argumentCount === "number" && argumentCount !== Infinity) return denodeifyWithCount(fn, argumentCount);
    else return denodeifyWithoutCount(fn);
};
var callbackFn = "function (err, res) {if (err) { rj(err); } else { rs(res); }}";
function denodeifyWithCount(fn, argumentCount) {
    var args = [];
    for(var i = 0; i < argumentCount; i++)args.push("a" + i);
    var body = [
        "return function (" + args.join(",") + ") {",
        "var self = this;",
        "return new Promise(function (rs, rj) {",
        "var res = fn.call(",
        [
            "self"
        ].concat(args).concat([
            callbackFn
        ]).join(","),
        ");",
        "if (res &&",
        '(typeof res === "object" || typeof res === "function") &&',
        'typeof res.then === "function"',
        ") {rs(res);}",
        "});",
        "};"
    ].join("");
    return Function([
        "Promise",
        "fn"
    ], body)(Promise, fn);
}
function denodeifyWithoutCount(fn) {
    var fnLength = Math.max(fn.length - 1, 3);
    var args = [];
    for(var i = 0; i < fnLength; i++)args.push("a" + i);
    var body = [
        "return function (" + args.join(",") + ") {",
        "var self = this;",
        "var args;",
        "var argLength = arguments.length;",
        "if (arguments.length > " + fnLength + ") {",
        "args = new Array(arguments.length + 1);",
        "for (var i = 0; i < arguments.length; i++) {",
        "args[i] = arguments[i];",
        "}",
        "}",
        "return new Promise(function (rs, rj) {",
        "var cb = " + callbackFn + ";",
        "var res;",
        "switch (argLength) {",
        args.concat([
            "extra"
        ]).map(function(_, index) {
            return "case " + index + ":" + "res = fn.call(" + [
                "self"
            ].concat(args.slice(0, index)).concat("cb").join(",") + ");" + "break;";
        }).join(""),
        "default:",
        "args[argLength] = cb;",
        "res = fn.apply(self, args);",
        "}",
        "if (res &&",
        '(typeof res === "object" || typeof res === "function") &&',
        'typeof res.then === "function"',
        ") {rs(res);}",
        "});",
        "};"
    ].join("");
    return Function([
        "Promise",
        "fn"
    ], body)(Promise, fn);
}
Promise.nodeify = function(fn) {
    return function() {
        var args = Array.prototype.slice.call(arguments);
        var callback = typeof args[args.length - 1] === "function" ? args.pop() : null;
        var ctx = this;
        try {
            return fn.apply(this, arguments).nodeify(callback, ctx);
        } catch (ex) {
            if (callback === null || typeof callback == "undefined") return new Promise(function(resolve, reject) {
                reject(ex);
            });
            else asap(function() {
                callback.call(ctx, ex);
            });
        }
    };
};
Promise.prototype.nodeify = function(callback, ctx) {
    if (typeof callback != "function") return this;
    this.then(function(value) {
        asap(function() {
            callback.call(ctx, null, value);
        });
    }, function(err) {
        asap(function() {
            callback.call(ctx, err);
        });
    });
};

},{"866a87f3062826f8":"3Ytq6","d53e249cb4ff08e4":"8kCUC"}],"8kCUC":[function(require,module,exports) {
"use strict";
// rawAsap provides everything we need except exception management.
var rawAsap = require("f2d0a4216b139c85");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
function throwFirstError() {
    if (pendingErrors.length) throw pendingErrors.shift();
}
/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */ module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) rawTask = freeTasks.pop();
    else rawTask = new RawTask();
    rawTask.task = task;
    rawAsap(rawTask);
}
// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}
// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function() {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) // This hook exists purely for testing purposes.
        // Its name will be periodically randomized to break any code that
        // depends on its existence.
        asap.onerror(error);
        else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally{
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"f2d0a4216b139c85":"9iMrj"}],"lXbR9":[function(require,module,exports) {
"use strict";
var Promise = require("bea74fd4863f96db");
module.exports = Promise;
Promise.enableSynchronous = function() {
    Promise.prototype.isPending = function() {
        return this.getState() == 0;
    };
    Promise.prototype.isFulfilled = function() {
        return this.getState() == 1;
    };
    Promise.prototype.isRejected = function() {
        return this.getState() == 2;
    };
    Promise.prototype.getValue = function() {
        if (this._65 === 3) return this._55.getValue();
        if (!this.isFulfilled()) throw new Error("Cannot get a value of an unfulfilled promise.");
        return this._55;
    };
    Promise.prototype.getReason = function() {
        if (this._65 === 3) return this._55.getReason();
        if (!this.isRejected()) throw new Error("Cannot get a rejection reason of a non-rejected promise.");
        return this._55;
    };
    Promise.prototype.getState = function() {
        if (this._65 === 3) return this._55.getState();
        if (this._65 === -1 || this._65 === -2) return 0;
        return this._65;
    };
};
Promise.disableSynchronous = function() {
    Promise.prototype.isPending = undefined;
    Promise.prototype.isFulfilled = undefined;
    Promise.prototype.isRejected = undefined;
    Promise.prototype.getValue = undefined;
    Promise.prototype.getReason = undefined;
    Promise.prototype.getState = undefined;
};

},{"bea74fd4863f96db":"3Ytq6"}],"hrWMv":[function(require,module,exports) {
module.exports = isPromise;
module.exports.default = isPromise;
function isPromise(obj) {
    return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
}

},{}],"c6mMC":[function(require,module,exports) {
var async = require("fab65eb61bd949bd");
async.core = require("1a2e623061b2dbfe");
async.isCore = require("9f187846f4b8e7dd");
async.sync = require("aa218790397376f3");
module.exports = async;

},{"fab65eb61bd949bd":"58oB2","1a2e623061b2dbfe":"e7V36","9f187846f4b8e7dd":"a5KvZ","aa218790397376f3":"8YavR"}],"58oB2":[function(require,module,exports) {
var process = require("aac27d935f6cf35f");
var fs = require("f307dad56bb9274c");
var getHomedir = require("b6e96f0883e0c49d");
var path = require("9111f981b29aee08");
var caller = require("c185e0f65296dbfe");
var nodeModulesPaths = require("a2d38bbba27f5d1");
var normalizeOptions = require("e7811cbb496279d0");
var isCore = require("b3337667c491229d");
var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
var homedir = getHomedir();
var defaultPaths = function() {
    return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
    ];
};
var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function(err, stat) {
        if (!err) return cb(null, stat.isFile() || stat.isFIFO());
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
    });
};
var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function(err, stat) {
        if (!err) return cb(null, stat.isDirectory());
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
    });
};
var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT") cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};
var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) realpath(x, cb);
    else cb(null, x);
};
var defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {
    readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr) cb(readFileErr);
        else try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
        } catch (jsonErr) {
            cb(null);
        }
    });
};
var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for(var i = 0; i < dirs.length; i++)dirs[i] = path.join(dirs[i], x);
    return dirs;
};
module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === "function") {
        cb = opts;
        opts = {};
    }
    if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
            cb(err);
        });
    }
    opts = normalizeOptions(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
            cb(conflictErr);
        });
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [
        ".js"
    ];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err, realStart) {
        if (err) cb(err);
        else init(realStart);
    });
    var res;
    function init(basedir) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
            res = path.resolve(basedir, x);
            if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
            if (/\/$/.test(x) && res === basedir) loadAsDirectory(res, opts.package, onfile);
            else loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) return cb(null, x);
        else loadNodeModules(x, basedir, function(err, n, pkg) {
            if (err) cb(err);
            else if (n) return maybeRealpath(realpath, n, opts, function(err, realN) {
                if (err) cb(err);
                else cb(null, realN, pkg);
            });
            else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = "MODULE_NOT_FOUND";
                cb(moduleError);
            }
        });
    }
    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function(err, d, pkg) {
            if (err) cb(err);
            else if (d) maybeRealpath(realpath, d, opts, function(err, realD) {
                if (err) cb(err);
                else cb(null, realD, pkg);
            });
            else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = "MODULE_NOT_FOUND";
                cb(moduleError);
            }
        });
    }
    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === "function") {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }
        var exts = [
            ""
        ].concat(extensions);
        load(exts, x, loadAsFilePackage);
        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];
            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);
            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load([
                        ""
                    ].concat(extensions.slice()), path.resolve(dir, r), pkg);
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }
    function loadpkg(dir, cb) {
        if (dir === "" || dir === "/") return cb(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) return cb(null);
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return cb(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, "package.json");
            isFile(pkgfile, function(err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);
                readPackage(readFile, pkgfile, function(err, pkgParam) {
                    if (err) cb(err);
                    var pkg = pkgParam;
                    if (pkg && opts.packageFilter) pkg = opts.packageFilter(pkg, pkgfile);
                    cb(null, pkg, dir);
                });
            });
        });
    }
    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
            cb = fpkg;
            fpkg = opts.package;
        }
        maybeRealpath(realpath, x, opts, function(unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, "package.json");
            isFile(pkgfile, function(err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, "index"), fpkg, cb);
                readPackage(readFile, pkgfile, function(err, pkgParam) {
                    if (err) return cb(err);
                    var pkg = pkgParam;
                    if (pkg && opts.packageFilter) pkg = opts.packageFilter(pkg, pkgfile);
                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== "string") {
                            var mainError = new TypeError("package “" + pkg.name + "” `main` must be a string");
                            mainError.code = "INVALID_PACKAGE_MAIN";
                            return cb(mainError);
                        }
                        if (pkg.main === "." || pkg.main === "./") pkg.main = "index";
                        loadAsFile(path.resolve(x, pkg.main), pkg, function(err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, "index"), pkg, cb);
                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function(err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, "index"), pkg, cb);
                            });
                        });
                        return;
                    }
                    loadAsFile(path.join(x, "/index"), pkg, cb);
                });
            });
        });
    }
    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir);
        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }
        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function() {
            return getPackageCandidates(x, start, opts);
        };
        processDirs(cb, packageIterator ? packageIterator(x, start, thunk, opts) : thunk());
    }
};

},{"aac27d935f6cf35f":"d5jf4","f307dad56bb9274c":"jhUEF","b6e96f0883e0c49d":"9qZf1","9111f981b29aee08":"loE3o","c185e0f65296dbfe":"bT3Zz","a2d38bbba27f5d1":"jIcdT","e7811cbb496279d0":"jB6cN","b3337667c491229d":"ijxJe"}],"9qZf1":[function(require,module,exports) {
var process = require("25401517b462e41b");
"use strict";
var os = require("2ed3bf597f4dfacb");
// adapted from https://github.com/sindresorhus/os-homedir/blob/11e089f4754db38bb535e5a8416320c4446e8cfd/index.js
module.exports = os.homedir || function homedir() {
    var home = undefined;
    var user = undefined;
    if (process.platform === "win32") return home || null;
    if (process.platform === "darwin") return home || (user ? "/Users/" + user : null);
    if (process.platform === "linux") return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null); // eslint-disable-line no-extra-parens
    return home || null;
};

},{"25401517b462e41b":"d5jf4","2ed3bf597f4dfacb":"6yyXu"}],"6yyXu":[function(require,module,exports) {
exports.endianness = function() {
    return "LE";
};
exports.hostname = function() {
    if (typeof location !== "undefined") return location.hostname;
    else return "";
};
exports.loadavg = function() {
    return [];
};
exports.uptime = function() {
    return 0;
};
exports.freemem = function() {
    return Number.MAX_VALUE;
};
exports.totalmem = function() {
    return Number.MAX_VALUE;
};
exports.cpus = function() {
    return [];
};
exports.type = function() {
    return "Browser";
};
exports.release = function() {
    if (typeof navigator !== "undefined") return navigator.appVersion;
    return "";
};
exports.networkInterfaces = exports.getNetworkInterfaces = function() {
    return {};
};
exports.arch = function() {
    return "javascript";
};
exports.platform = function() {
    return "browser";
};
exports.tmpdir = exports.tmpDir = function() {
    return "/tmp";
};
exports.EOL = "\n";
exports.homedir = function() {
    return "/";
};

},{}],"bT3Zz":[function(require,module,exports) {
module.exports = function() {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack) {
        return stack;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};

},{}],"jIcdT":[function(require,module,exports) {
var path = require("855693930f7b9022");
var parse = path.parse || require("a13b7f8567c5b4a0"); // eslint-disable-line global-require
var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) prefix = "";
    else if (/^\\\\/.test(absoluteStart)) prefix = "\\\\";
    var paths = [
        absoluteStart
    ];
    var parsed = parse(absoluteStart);
    while(parsed.dir !== paths[paths.length - 1]){
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};
module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : [
        "node_modules"
    ];
    if (opts && typeof opts.paths === "function") return opts.paths(request, start, function() {
        return getNodeModulesDirs(start, modules);
    }, opts);
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};

},{"855693930f7b9022":"loE3o","a13b7f8567c5b4a0":"6XRQQ"}],"6XRQQ":[function(require,module,exports) {
var process = require("fd0ad6f1a47ae");
"use strict";
var isWindows = process.platform === "win32";
// Regex to split a windows path into into [dir, root, basename, name, ext]
var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
var win32 = {};
function win32SplitPath(filename) {
    return splitWindowsRe.exec(filename).slice(1);
}
win32.parse = function(pathString) {
    if (typeof pathString !== "string") throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 5) throw new TypeError("Invalid path '" + pathString + "'");
    return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
    };
};
// Split a filename into [dir, root, basename, name, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
var posix = {};
function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
}
posix.parse = function(pathString) {
    if (typeof pathString !== "string") throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 5) throw new TypeError("Invalid path '" + pathString + "'");
    return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
    };
};
if (isWindows) module.exports = win32.parse;
else /* posix */ module.exports = posix.parse;
module.exports.posix = posix.parse;
module.exports.win32 = win32.parse;

},{"fd0ad6f1a47ae":"d5jf4"}],"jB6cN":[function(require,module,exports) {
module.exports = function(x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */ return opts || {};
};

},{}],"ijxJe":[function(require,module,exports) {
var process = require("9bf4491a17cc3827");
"use strict";
var has = require("b98f87ea46958d2b");
function specifierIncluded(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for(var i = 0; i < 3; ++i){
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) continue; // eslint-disable-line no-restricted-syntax, no-continue
        if (op === "<") return cur < ver;
        if (op === ">=") return cur >= ver;
        return false;
    }
    return op === ">=";
}
function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) return false;
    for(var i = 0; i < specifiers.length; ++i){
        if (!specifierIncluded(current, specifiers[i])) return false;
    }
    return true;
}
function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") return specifierValue;
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
    if (typeof current !== "string") throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    if (specifierValue && typeof specifierValue === "object") {
        for(var i = 0; i < specifierValue.length; ++i){
            if (matchesRange(current, specifierValue[i])) return true;
        }
        return false;
    }
    return matchesRange(current, specifierValue);
}
var data = require("64c7ac0654e8809");
module.exports = function isCore(x, nodeVersion) {
    return has(data, x) && versionIncluded(nodeVersion, data[x]);
};

},{"9bf4491a17cc3827":"d5jf4","b98f87ea46958d2b":"ksyoO","64c7ac0654e8809":"1hTpT"}],"1hTpT":[function(require,module,exports) {
module.exports = JSON.parse('{"assert":true,"node:assert":[">= 14.18 && < 15",">= 16"],"assert/strict":">= 15","node:assert/strict":">= 16","async_hooks":">= 8","node:async_hooks":[">= 14.18 && < 15",">= 16"],"buffer_ieee754":">= 0.5 && < 0.9.7","buffer":true,"node:buffer":[">= 14.18 && < 15",">= 16"],"child_process":true,"node:child_process":[">= 14.18 && < 15",">= 16"],"cluster":">= 0.5","node:cluster":[">= 14.18 && < 15",">= 16"],"console":true,"node:console":[">= 14.18 && < 15",">= 16"],"constants":true,"node:constants":[">= 14.18 && < 15",">= 16"],"crypto":true,"node:crypto":[">= 14.18 && < 15",">= 16"],"_debug_agent":">= 1 && < 8","_debugger":"< 8","dgram":true,"node:dgram":[">= 14.18 && < 15",">= 16"],"diagnostics_channel":[">= 14.17 && < 15",">= 15.1"],"node:diagnostics_channel":[">= 14.18 && < 15",">= 16"],"dns":true,"node:dns":[">= 14.18 && < 15",">= 16"],"dns/promises":">= 15","node:dns/promises":">= 16","domain":">= 0.7.12","node:domain":[">= 14.18 && < 15",">= 16"],"events":true,"node:events":[">= 14.18 && < 15",">= 16"],"freelist":"< 6","fs":true,"node:fs":[">= 14.18 && < 15",">= 16"],"fs/promises":[">= 10 && < 10.1",">= 14"],"node:fs/promises":[">= 14.18 && < 15",">= 16"],"_http_agent":">= 0.11.1","node:_http_agent":[">= 14.18 && < 15",">= 16"],"_http_client":">= 0.11.1","node:_http_client":[">= 14.18 && < 15",">= 16"],"_http_common":">= 0.11.1","node:_http_common":[">= 14.18 && < 15",">= 16"],"_http_incoming":">= 0.11.1","node:_http_incoming":[">= 14.18 && < 15",">= 16"],"_http_outgoing":">= 0.11.1","node:_http_outgoing":[">= 14.18 && < 15",">= 16"],"_http_server":">= 0.11.1","node:_http_server":[">= 14.18 && < 15",">= 16"],"http":true,"node:http":[">= 14.18 && < 15",">= 16"],"http2":">= 8.8","node:http2":[">= 14.18 && < 15",">= 16"],"https":true,"node:https":[">= 14.18 && < 15",">= 16"],"inspector":">= 8","node:inspector":[">= 14.18 && < 15",">= 16"],"inspector/promises":[">= 19"],"node:inspector/promises":[">= 19"],"_linklist":"< 8","module":true,"node:module":[">= 14.18 && < 15",">= 16"],"net":true,"node:net":[">= 14.18 && < 15",">= 16"],"node-inspect/lib/_inspect":">= 7.6 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6 && < 12","os":true,"node:os":[">= 14.18 && < 15",">= 16"],"path":true,"node:path":[">= 14.18 && < 15",">= 16"],"path/posix":">= 15.3","node:path/posix":">= 16","path/win32":">= 15.3","node:path/win32":">= 16","perf_hooks":">= 8.5","node:perf_hooks":[">= 14.18 && < 15",">= 16"],"process":">= 1","node:process":[">= 14.18 && < 15",">= 16"],"punycode":">= 0.5","node:punycode":[">= 14.18 && < 15",">= 16"],"querystring":true,"node:querystring":[">= 14.18 && < 15",">= 16"],"readline":true,"node:readline":[">= 14.18 && < 15",">= 16"],"readline/promises":">= 17","node:readline/promises":">= 17","repl":true,"node:repl":[">= 14.18 && < 15",">= 16"],"smalloc":">= 0.11.5 && < 3","_stream_duplex":">= 0.9.4","node:_stream_duplex":[">= 14.18 && < 15",">= 16"],"_stream_transform":">= 0.9.4","node:_stream_transform":[">= 14.18 && < 15",">= 16"],"_stream_wrap":">= 1.4.1","node:_stream_wrap":[">= 14.18 && < 15",">= 16"],"_stream_passthrough":">= 0.9.4","node:_stream_passthrough":[">= 14.18 && < 15",">= 16"],"_stream_readable":">= 0.9.4","node:_stream_readable":[">= 14.18 && < 15",">= 16"],"_stream_writable":">= 0.9.4","node:_stream_writable":[">= 14.18 && < 15",">= 16"],"stream":true,"node:stream":[">= 14.18 && < 15",">= 16"],"stream/consumers":">= 16.7","node:stream/consumers":">= 16.7","stream/promises":">= 15","node:stream/promises":">= 16","stream/web":">= 16.5","node:stream/web":">= 16.5","string_decoder":true,"node:string_decoder":[">= 14.18 && < 15",">= 16"],"sys":[">= 0.4 && < 0.7",">= 0.8"],"node:sys":[">= 14.18 && < 15",">= 16"],"test/reporters":">= 19.9 && < 20.2","node:test/reporters":[">= 19.9",">= 20"],"node:test":[">= 16.17 && < 17",">= 18"],"timers":true,"node:timers":[">= 14.18 && < 15",">= 16"],"timers/promises":">= 15","node:timers/promises":">= 16","_tls_common":">= 0.11.13","node:_tls_common":[">= 14.18 && < 15",">= 16"],"_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","node:_tls_wrap":[">= 14.18 && < 15",">= 16"],"tls":true,"node:tls":[">= 14.18 && < 15",">= 16"],"trace_events":">= 10","node:trace_events":[">= 14.18 && < 15",">= 16"],"tty":true,"node:tty":[">= 14.18 && < 15",">= 16"],"url":true,"node:url":[">= 14.18 && < 15",">= 16"],"util":true,"node:util":[">= 14.18 && < 15",">= 16"],"util/types":">= 15.3","node:util/types":">= 16","v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/consarray":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/csvparser":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/logreader":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/profile_view":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/splaytree":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8":">= 1","node:v8":[">= 14.18 && < 15",">= 16"],"vm":true,"node:vm":[">= 14.18 && < 15",">= 16"],"wasi":[">= 13.4 && < 13.5",">= 20"],"node:wasi":">= 20","worker_threads":">= 11.7","node:worker_threads":[">= 14.18 && < 15",">= 16"],"zlib":">= 0.5","node:zlib":[">= 14.18 && < 15",">= 16"]}');

},{}],"e7V36":[function(require,module,exports) {
"use strict";
var isCoreModule = require("3e9936faf252d157");
var data = require("b83dec0552af5070");
var core = {};
for(var mod in data)if (Object.prototype.hasOwnProperty.call(data, mod)) core[mod] = isCoreModule(mod);
module.exports = core;

},{"3e9936faf252d157":"ijxJe","b83dec0552af5070":"5rcQt"}],"5rcQt":[function(require,module,exports) {
module.exports = JSON.parse('{"assert":true,"node:assert":[">= 14.18 && < 15",">= 16"],"assert/strict":">= 15","node:assert/strict":">= 16","async_hooks":">= 8","node:async_hooks":[">= 14.18 && < 15",">= 16"],"buffer_ieee754":">= 0.5 && < 0.9.7","buffer":true,"node:buffer":[">= 14.18 && < 15",">= 16"],"child_process":true,"node:child_process":[">= 14.18 && < 15",">= 16"],"cluster":">= 0.5","node:cluster":[">= 14.18 && < 15",">= 16"],"console":true,"node:console":[">= 14.18 && < 15",">= 16"],"constants":true,"node:constants":[">= 14.18 && < 15",">= 16"],"crypto":true,"node:crypto":[">= 14.18 && < 15",">= 16"],"_debug_agent":">= 1 && < 8","_debugger":"< 8","dgram":true,"node:dgram":[">= 14.18 && < 15",">= 16"],"diagnostics_channel":[">= 14.17 && < 15",">= 15.1"],"node:diagnostics_channel":[">= 14.18 && < 15",">= 16"],"dns":true,"node:dns":[">= 14.18 && < 15",">= 16"],"dns/promises":">= 15","node:dns/promises":">= 16","domain":">= 0.7.12","node:domain":[">= 14.18 && < 15",">= 16"],"events":true,"node:events":[">= 14.18 && < 15",">= 16"],"freelist":"< 6","fs":true,"node:fs":[">= 14.18 && < 15",">= 16"],"fs/promises":[">= 10 && < 10.1",">= 14"],"node:fs/promises":[">= 14.18 && < 15",">= 16"],"_http_agent":">= 0.11.1","node:_http_agent":[">= 14.18 && < 15",">= 16"],"_http_client":">= 0.11.1","node:_http_client":[">= 14.18 && < 15",">= 16"],"_http_common":">= 0.11.1","node:_http_common":[">= 14.18 && < 15",">= 16"],"_http_incoming":">= 0.11.1","node:_http_incoming":[">= 14.18 && < 15",">= 16"],"_http_outgoing":">= 0.11.1","node:_http_outgoing":[">= 14.18 && < 15",">= 16"],"_http_server":">= 0.11.1","node:_http_server":[">= 14.18 && < 15",">= 16"],"http":true,"node:http":[">= 14.18 && < 15",">= 16"],"http2":">= 8.8","node:http2":[">= 14.18 && < 15",">= 16"],"https":true,"node:https":[">= 14.18 && < 15",">= 16"],"inspector":">= 8","node:inspector":[">= 14.18 && < 15",">= 16"],"inspector/promises":[">= 19"],"node:inspector/promises":[">= 19"],"_linklist":"< 8","module":true,"node:module":[">= 14.18 && < 15",">= 16"],"net":true,"node:net":[">= 14.18 && < 15",">= 16"],"node-inspect/lib/_inspect":">= 7.6 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6 && < 12","os":true,"node:os":[">= 14.18 && < 15",">= 16"],"path":true,"node:path":[">= 14.18 && < 15",">= 16"],"path/posix":">= 15.3","node:path/posix":">= 16","path/win32":">= 15.3","node:path/win32":">= 16","perf_hooks":">= 8.5","node:perf_hooks":[">= 14.18 && < 15",">= 16"],"process":">= 1","node:process":[">= 14.18 && < 15",">= 16"],"punycode":">= 0.5","node:punycode":[">= 14.18 && < 15",">= 16"],"querystring":true,"node:querystring":[">= 14.18 && < 15",">= 16"],"readline":true,"node:readline":[">= 14.18 && < 15",">= 16"],"readline/promises":">= 17","node:readline/promises":">= 17","repl":true,"node:repl":[">= 14.18 && < 15",">= 16"],"smalloc":">= 0.11.5 && < 3","_stream_duplex":">= 0.9.4","node:_stream_duplex":[">= 14.18 && < 15",">= 16"],"_stream_transform":">= 0.9.4","node:_stream_transform":[">= 14.18 && < 15",">= 16"],"_stream_wrap":">= 1.4.1","node:_stream_wrap":[">= 14.18 && < 15",">= 16"],"_stream_passthrough":">= 0.9.4","node:_stream_passthrough":[">= 14.18 && < 15",">= 16"],"_stream_readable":">= 0.9.4","node:_stream_readable":[">= 14.18 && < 15",">= 16"],"_stream_writable":">= 0.9.4","node:_stream_writable":[">= 14.18 && < 15",">= 16"],"stream":true,"node:stream":[">= 14.18 && < 15",">= 16"],"stream/consumers":">= 16.7","node:stream/consumers":">= 16.7","stream/promises":">= 15","node:stream/promises":">= 16","stream/web":">= 16.5","node:stream/web":">= 16.5","string_decoder":true,"node:string_decoder":[">= 14.18 && < 15",">= 16"],"sys":[">= 0.4 && < 0.7",">= 0.8"],"node:sys":[">= 14.18 && < 15",">= 16"],"node:test":[">= 16.17 && < 17",">= 18"],"timers":true,"node:timers":[">= 14.18 && < 15",">= 16"],"timers/promises":">= 15","node:timers/promises":">= 16","_tls_common":">= 0.11.13","node:_tls_common":[">= 14.18 && < 15",">= 16"],"_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","node:_tls_wrap":[">= 14.18 && < 15",">= 16"],"tls":true,"node:tls":[">= 14.18 && < 15",">= 16"],"trace_events":">= 10","node:trace_events":[">= 14.18 && < 15",">= 16"],"tty":true,"node:tty":[">= 14.18 && < 15",">= 16"],"url":true,"node:url":[">= 14.18 && < 15",">= 16"],"util":true,"node:util":[">= 14.18 && < 15",">= 16"],"util/types":">= 15.3","node:util/types":">= 16","v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/consarray":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/csvparser":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/logreader":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/profile_view":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/splaytree":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8":">= 1","node:v8":[">= 14.18 && < 15",">= 16"],"vm":true,"node:vm":[">= 14.18 && < 15",">= 16"],"wasi":">= 13.4 && < 13.5","worker_threads":">= 11.7","node:worker_threads":[">= 14.18 && < 15",">= 16"],"zlib":">= 0.5","node:zlib":[">= 14.18 && < 15",">= 16"]}');

},{}],"a5KvZ":[function(require,module,exports) {
var isCoreModule = require("7db2f4a8cfa41f8a");
module.exports = function isCore(x) {
    return isCoreModule(x);
};

},{"7db2f4a8cfa41f8a":"ijxJe"}],"8YavR":[function(require,module,exports) {
var process = require("a33671848af13612");
var isCore = require("9927431d19ef38b9");
var fs = require("a4b0f797f314f3b8");
var path = require("a693c0c4b3bbcb6a");
var getHomedir = require("f4451faa0fac00e9");
var caller = require("96aa2e61793d9338");
var nodeModulesPaths = require("e338e7c299b0a612");
var normalizeOptions = require("dd0a227bf2475545");
var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
var homedir = getHomedir();
var defaultPaths = function() {
    return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
    ];
};
var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file, {
            throwIfNoEntry: false
        });
    } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
    }
    return !!stat && (stat.isFile() || stat.isFIFO());
};
var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir, {
            throwIfNoEntry: false
        });
    } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
    }
    return !!stat && stat.isDirectory();
};
var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") throw realpathErr;
    }
    return x;
};
var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) return realpathSync(x);
    return x;
};
var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
        var pkg = JSON.parse(body);
        return pkg;
    } catch (jsonErr) {}
};
var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for(var i = 0; i < dirs.length; i++)dirs[i] = path.join(dirs[i], x);
    return dirs;
};
module.exports = function resolveSync(x, options) {
    if (typeof x !== "string") throw new TypeError("Path must be a string.");
    var opts = normalizeOptions(x, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [
        ".js"
    ];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x)) return x;
    else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
        }
        if (isFile(x)) return x;
        for(var i = 0; i < extensions.length; i++){
            var file = x + extensions[i];
            if (isFile(file)) return file;
        }
    }
    function loadpkg(dir) {
        if (dir === "" || dir === "/") return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) return;
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return;
        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) return loadpkg(path.dirname(dir));
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) // v2 will pass pkgfile
        pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        return {
            pkg: pkg,
            dir: dir
        };
    }
    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), "/package.json");
        if (isFile(pkgfile)) {
            try {
                var pkg = readPackageSync(readFileSync, pkgfile);
            } catch (e) {}
            if (pkg && opts.packageFilter) // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                    var mainError = new TypeError("package “" + pkg.name + "” `main` must be a string");
                    mainError.code = "INVALID_PACKAGE_MAIN";
                    throw mainError;
                }
                if (pkg.main === "." || pkg.main === "./") pkg.main = "index";
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }
        return loadAsFileSync(path.join(x, "/index"));
    }
    function loadNodeModulesSync(x, start) {
        var thunk = function() {
            return getPackageCandidates(x, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();
        for(var i = 0; i < dirs.length; i++){
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};

},{"a33671848af13612":"d5jf4","9927431d19ef38b9":"ijxJe","a4b0f797f314f3b8":"jhUEF","a693c0c4b3bbcb6a":"loE3o","f4451faa0fac00e9":"9qZf1","96aa2e61793d9338":"bT3Zz","e338e7c299b0a612":"jIcdT","dd0a227bf2475545":"jB6cN"}],"kXQEE":[function(require,module,exports) {
"use strict";
var dirname = require("c444cdf5c12cf2ef").dirname;
var constantinople = require("df8dc9e5b32590b");
var walk = require("462a4c5be99365d8");
var error = require("6331452e89ef7f75");
var runFilter = require("64354919023c89da");
module.exports = handleFilters;
function handleFilters(ast, filters, options, filterAliases) {
    options = options || {};
    walk(ast, function(node) {
        var dir = node.filename ? dirname(node.filename) : null;
        if (node.type === "Filter") {
            handleNestedFilters(node, filters, options, filterAliases);
            var text = getBodyAsText(node);
            var attrs = getAttributes(node, options);
            attrs.filename = node.filename;
            node.type = "Text";
            node.val = filterWithFallback(node, text, attrs);
        } else if (node.type === "RawInclude" && node.filters.length) {
            var firstFilter = node.filters.pop();
            var attrs = getAttributes(firstFilter, options);
            var filename = attrs.filename = node.file.fullPath;
            node.type = "Text";
            node.val = filterFileWithFallback(firstFilter, filename, node.file, attrs);
            node.filters.slice().reverse().forEach(function(filter) {
                var attrs = getAttributes(filter, options);
                attrs.filename = filename;
                node.val = filterWithFallback(filter, node.val, attrs);
            });
            node.filters = undefined;
            node.file = undefined;
        }
        function filterWithFallback(filter, text, attrs, funcName) {
            try {
                var filterName = getFilterName(filter);
                if (filters && filters[filterName]) return filters[filterName](text, attrs);
                else return runFilter(filterName, text, attrs, dir, funcName);
            } catch (ex) {
                if (ex.code === "UNKNOWN_FILTER") throw error(ex.code, ex.message, filter);
                throw ex;
            }
        }
        function filterFileWithFallback(filter, filename, file, attrs) {
            var filterName = getFilterName(filter);
            if (filters && filters[filterName]) {
                if (filters[filterName].renderBuffer) return filters[filterName].renderBuffer(file.raw, attrs);
                else return filters[filterName](file.str, attrs);
            } else return filterWithFallback(filter, filename, attrs, "renderFile");
        }
    }, {
        includeDependencies: true
    });
    function getFilterName(filter) {
        var filterName = filter.name;
        if (filterAliases && filterAliases[filterName]) {
            filterName = filterAliases[filterName];
            if (filterAliases[filterName]) throw error("FILTER_ALISE_CHAIN", 'The filter "' + filter.name + '" is an alias for "' + filterName + '", which is an alias for "' + filterAliases[filterName] + '".  Pug does not support chains of filter aliases.', filter);
        }
        return filterName;
    }
    return ast;
}
function handleNestedFilters(node, filters, options, filterAliases) {
    if (node.block.nodes[0] && node.block.nodes[0].type === "Filter") node.block.nodes[0] = handleFilters(node.block, filters, options, filterAliases).nodes[0];
}
function getBodyAsText(node) {
    return node.block.nodes.map(function(node) {
        return node.val;
    }).join("");
}
function getAttributes(node, options) {
    var attrs = {};
    node.attrs.forEach(function(attr) {
        try {
            attrs[attr.name] = attr.val === true ? true : constantinople.toConstant(attr.val);
        } catch (ex) {
            if (/not constant/.test(ex.message)) throw error("FILTER_OPTION_NOT_CONSTANT", ex.message + " All filters are rendered compile-time so filter options must be constants.", node);
            throw ex;
        }
    });
    var opts = options[node.name] || {};
    Object.keys(opts).forEach(function(opt) {
        if (!attrs.hasOwnProperty(opt)) attrs[opt] = opts[opt];
    });
    return attrs;
}

},{"c444cdf5c12cf2ef":"loE3o","df8dc9e5b32590b":"hMtKb","462a4c5be99365d8":"kOecN","6331452e89ef7f75":"khglH","64354919023c89da":"2y7kz"}],"hMtKb":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var parser_1 = require("b9c099ee34007e12");
var b = require("6f636a4ec42d13af");
var binaryOperation_1 = require("c7cad71975807021");
function expressionToConstant(expression, options) {
    if (options === void 0) options = {};
    var constant = true;
    function toConstant(expression) {
        if (!constant) return;
        if (b.isArrayExpression(expression)) {
            var result_1 = [];
            for(var i = 0; constant && i < expression.elements.length; i++){
                var element = expression.elements[i];
                if (b.isSpreadElement(element)) {
                    var spread = toConstant(element.argument);
                    if (!(isSpreadable(spread) && constant)) constant = false;
                    else result_1.push.apply(result_1, spread);
                } else if (b.isExpression(element)) result_1.push(toConstant(element));
                else constant = false;
            }
            return result_1;
        }
        if (b.isBinaryExpression(expression)) {
            var left = toConstant(expression.left);
            var right = toConstant(expression.right);
            return constant && binaryOperation_1["default"](expression.operator, left, right);
        }
        if (b.isBooleanLiteral(expression)) return expression.value;
        if (b.isCallExpression(expression)) {
            var args = [];
            for(var i = 0; constant && i < expression.arguments.length; i++){
                var arg = expression.arguments[i];
                if (b.isSpreadElement(arg)) {
                    var spread = toConstant(arg.argument);
                    if (!(isSpreadable(spread) && constant)) constant = false;
                    else args.push.apply(args, spread);
                } else if (b.isExpression(arg)) args.push(toConstant(arg));
                else constant = false;
            }
            if (!constant) return;
            if (b.isMemberExpression(expression.callee)) {
                var object = toConstant(expression.callee.object);
                if (!object || !constant) {
                    constant = false;
                    return;
                }
                var member = expression.callee.computed ? toConstant(expression.callee.property) : b.isIdentifier(expression.callee.property) ? expression.callee.property.name : undefined;
                if (member === undefined && !expression.callee.computed) constant = false;
                if (!constant) return;
                if (canCallMethod(object, "" + member)) return object[member].apply(object, args);
            } else {
                if (!b.isExpression(expression.callee)) {
                    constant = false;
                    return;
                }
                var callee = toConstant(expression.callee);
                if (!constant) return;
                return callee.apply(null, args);
            }
        }
        if (b.isConditionalExpression(expression)) {
            var test = toConstant(expression.test);
            return test ? toConstant(expression.consequent) : toConstant(expression.alternate);
        }
        if (b.isIdentifier(expression)) {
            if (options.constants && ({}).hasOwnProperty.call(options.constants, expression.name)) return options.constants[expression.name];
        }
        if (b.isLogicalExpression(expression)) {
            var left = toConstant(expression.left);
            var right = toConstant(expression.right);
            if (constant && expression.operator === "&&") return left && right;
            if (constant && expression.operator === "||") return left || right;
        }
        if (b.isMemberExpression(expression)) {
            var object = toConstant(expression.object);
            if (!object || !constant) {
                constant = false;
                return;
            }
            var member = expression.computed ? toConstant(expression.property) : b.isIdentifier(expression.property) ? expression.property.name : undefined;
            if (member === undefined && !expression.computed) constant = false;
            if (!constant) return;
            if (({}).hasOwnProperty.call(object, "" + member) && member[0] !== "_") return object[member];
        }
        if (b.isNullLiteral(expression)) return null;
        if (b.isNumericLiteral(expression)) return expression.value;
        if (b.isObjectExpression(expression)) {
            var result_2 = {};
            for(var i = 0; constant && i < expression.properties.length; i++){
                var property = expression.properties[i];
                if (b.isObjectProperty(property)) {
                    if (property.shorthand) {
                        constant = false;
                        return;
                    }
                    var key = property.computed ? toConstant(property.key) : b.isIdentifier(property.key) ? property.key.name : b.isStringLiteral(property.key) ? property.key.value : undefined;
                    if (!key || key[0] === "_") constant = false;
                    if (!constant) return;
                    if (b.isExpression(property.value)) {
                        var value = toConstant(property.value);
                        if (!constant) return;
                        result_2[key] = value;
                    } else constant = false;
                } else if (b.isObjectMethod(property)) constant = false;
                else if (b.isSpreadProperty(property)) {
                    var argument = toConstant(property.argument);
                    if (!argument) constant = false;
                    if (!constant) return;
                    Object.assign(result_2, argument);
                }
            }
            return result_2;
        }
        if (b.isParenthesizedExpression(expression)) return toConstant(expression.expression);
        if (b.isRegExpLiteral(expression)) return new RegExp(expression.pattern, expression.flags);
        if (b.isSequenceExpression(expression)) {
            for(var i = 0; i < expression.expressions.length - 1 && constant; i++)toConstant(expression.expressions[i]);
            return toConstant(expression.expressions[expression.expressions.length - 1]);
        }
        if (b.isStringLiteral(expression)) return expression.value;
        // TODO: TaggedTemplateExpression
        if (b.isTemplateLiteral(expression)) {
            var result_3 = "";
            for(var i = 0; i < expression.quasis.length; i++){
                var quasi = expression.quasis[i];
                result_3 += quasi.value.cooked;
                if (i < expression.expressions.length) result_3 += "" + toConstant(expression.expressions[i]);
            }
            return result_3;
        }
        if (b.isUnaryExpression(expression)) {
            var argument = toConstant(expression.argument);
            if (!constant) return;
            switch(expression.operator){
                case "-":
                    return -argument;
                case "+":
                    return +argument;
                case "!":
                    return !argument;
                case "~":
                    return ~argument;
                case "typeof":
                    return typeof argument;
                case "void":
                    return void 0;
            }
        }
        constant = false;
    }
    var result = toConstant(expression);
    return constant ? {
        constant: true,
        result: result
    } : {
        constant: false
    };
}
exports.expressionToConstant = expressionToConstant;
function isSpreadable(value) {
    return typeof value === "string" || Array.isArray(value) || typeof Set !== "undefined" && value instanceof Set || typeof Map !== "undefined" && value instanceof Map;
}
function shallowEqual(a, b) {
    if (a === b) return true;
    if (a && b && typeof a === "object" && typeof b === "object") {
        for(var key in a){
            if (a[key] !== b[key]) return false;
        }
        for(var key in b){
            if (a[key] !== b[key]) return false;
        }
        return true;
    }
    return false;
}
function canCallMethod(object, member) {
    switch(typeof object){
        case "boolean":
            switch(member){
                case "toString":
                    return true;
                default:
                    return false;
            }
        case "number":
            switch(member){
                case "toExponential":
                case "toFixed":
                case "toPrecision":
                case "toString":
                    return true;
                default:
                    return false;
            }
        case "string":
            switch(member){
                case "charAt":
                case "charCodeAt":
                case "codePointAt":
                case "concat":
                case "endsWith":
                case "includes":
                case "indexOf":
                case "lastIndexOf":
                case "match":
                case "normalize":
                case "padEnd":
                case "padStart":
                case "repeat":
                case "replace":
                case "search":
                case "slice":
                case "split":
                case "startsWith":
                case "substr":
                case "substring":
                case "toLowerCase":
                case "toUpperCase":
                case "trim":
                    return true;
                default:
                    return false;
            }
        default:
            if (object instanceof RegExp) switch(member){
                case "test":
                case "exec":
                    return true;
                default:
                    return false;
            }
            return ({}).hasOwnProperty.call(object, member) && member[0] !== "_";
    }
}
var EMPTY_OBJECT = {};
var lastSrc = "";
var lastConstants = EMPTY_OBJECT;
var lastOptions = EMPTY_OBJECT;
var lastResult = null;
var lastWasConstant = false;
function isConstant(src, constants, options) {
    if (constants === void 0) constants = EMPTY_OBJECT;
    if (options === void 0) options = EMPTY_OBJECT;
    if (lastSrc === src && shallowEqual(lastConstants, constants) && shallowEqual(lastOptions, options)) return lastWasConstant;
    lastSrc = src;
    lastConstants = constants;
    var ast;
    try {
        ast = parser_1.parseExpression(src, options);
    } catch (ex) {
        return lastWasConstant = false;
    }
    var _a = expressionToConstant(ast, {
        constants: constants
    }), result = _a.result, constant = _a.constant;
    lastResult = result;
    return lastWasConstant = constant;
}
exports.isConstant = isConstant;
function toConstant(src, constants, options) {
    if (constants === void 0) constants = EMPTY_OBJECT;
    if (options === void 0) options = EMPTY_OBJECT;
    if (!isConstant(src, constants, options)) throw new Error(JSON.stringify(src) + " is not constant.");
    return lastResult;
}
exports.toConstant = toConstant;
exports["default"] = isConstant;
module.exports = isConstant;
module.exports["default"] = isConstant;
module.exports.expressionToConstant = expressionToConstant;
module.exports.isConstant = isConstant;
module.exports.toConstant = toConstant;

},{"b9c099ee34007e12":"j1WdR","6f636a4ec42d13af":"hnm3y","c7cad71975807021":"j9YRY"}],"j1WdR":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
class Position {
    constructor(line, col, index){
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line;
        this.column = col;
        this.index = index;
    }
}
class SourceLocation {
    constructor(start, end){
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
    }
}
function createPositionWithColumnOffset(position, columnOffset) {
    const { line , column , index  } = position;
    return new Position(line, column + columnOffset, index + columnOffset);
}
var ParseErrorCode = {
    SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
    SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
};
const reflect = (keys, last = keys.length - 1)=>({
        get () {
            return keys.reduce((object, key)=>object[key], this);
        },
        set (value) {
            keys.reduce((item, key, i)=>i === last ? item[key] = value : item[key], this);
        }
    });
const instantiate = (constructor, properties, descriptors)=>Object.keys(descriptors).map((key)=>[
            key,
            descriptors[key]
        ]).filter(([, descriptor])=>!!descriptor).map(([key, descriptor])=>[
            key,
            typeof descriptor === "function" ? {
                value: descriptor,
                enumerable: false
            } : typeof descriptor.reflect === "string" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor
        ]).reduce((instance, [key, descriptor])=>Object.defineProperty(instance, key, Object.assign({
            configurable: true
        }, descriptor)), Object.assign(new constructor(), properties));
var ModuleErrors = {
    ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code: ParseErrorCode.SourceTypeModuleError
    },
    ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code: ParseErrorCode.SourceTypeModuleError
    }
};
const NodeDescriptions = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
};
const toNodeDescription = ({ type , prefix  })=>type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];
var StandardErrors = {
    AccessorIsGenerator: ({ kind  })=>`A ${kind}ter cannot be a generator.`,
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: ({ kind  })=>`Missing initializer in ${kind} declaration.`,
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: ({ exportName  })=>`\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: ({ localName , exportName  })=>`A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: ({ type  })=>`'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: ({ type  })=>`Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: ({ importName  })=>`A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${importName}" as foo }\`?`,
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: ({ maxArgumentCount  })=>`\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: ({ radix  })=>`Expected number in radix ${radix}.`,
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: ({ reservedWord  })=>`Escape sequence in keyword ${reservedWord}.`,
    InvalidIdentifier: ({ identifierName  })=>`Invalid identifier ${identifierName}.`,
    InvalidLhs: ({ ancestor  })=>`Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidLhsBinding: ({ ancestor  })=>`Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: ({ unexpected  })=>`Unexpected character '${unexpected}'.`,
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: ({ identifierName  })=>`Private name #${identifierName} is not defined.`,
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: ({ labelName  })=>`Label '${labelName}' is already declared.`,
    LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: ({ missingPlugin  })=>`This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name)=>JSON.stringify(name)).join(", ")}.`,
    MissingOneOfPlugins: ({ missingPlugin  })=>`This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name)=>JSON.stringify(name)).join(", ")}.`,
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: ({ key  })=>`Duplicate key "${key}" is not allowed in module attributes.`,
    ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode  })=>`An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
    ModuleExportUndefined: ({ localName  })=>`Export '${localName}' is not defined.`,
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: ({ identifierName  })=>`Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
    PrivateNameRedeclaration: ({ identifierName  })=>`Duplicate private name #${identifierName}.`,
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: ({ keyword  })=>`Unexpected keyword '${keyword}'.`,
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: ({ reservedWord  })=>`Unexpected reserved word '${reservedWord}'.`,
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: ({ expected , unexpected  })=>`Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: ({ target , onlyValidPropertyName  })=>`The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: ({ identifierName  })=>`Identifier '${identifierName}' has already been declared.`,
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
};
var StrictModeErrors = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: ({ referenceName  })=>`Assigning to '${referenceName}' in strict mode.`,
    StrictEvalArgumentsBinding: ({ bindingName  })=>`Binding '${bindingName}' in strict mode.`,
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
};
const UnparenthesizedPipeBodyDescriptions = new Set([
    "ArrowFunctionExpression",
    "AssignmentExpression",
    "ConditionalExpression",
    "YieldExpression"
]);
var PipelineOperatorErrors = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: ({ token  })=>`Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: ({ type  })=>`Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
            type
        })}; please wrap it in parentheses.`,
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
};
const _excluded$1 = [
    "toMessage"
], _excluded2$1 = [
    "message"
];
function toParseErrorConstructor(_ref) {
    let { toMessage  } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
    return function constructor({ loc , details  }) {
        return instantiate(SyntaxError, Object.assign({}, properties, {
            loc
        }), {
            clone (overrides = {}) {
                const loc = overrides.loc || {};
                return constructor({
                    loc: new Position("line" in loc ? loc.line : this.loc.line, "column" in loc ? loc.column : this.loc.column, "index" in loc ? loc.index : this.loc.index),
                    details: Object.assign({}, this.details, overrides.details)
                });
            },
            details: {
                value: details,
                enumerable: false
            },
            message: {
                get () {
                    return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;
                },
                set (value) {
                    Object.defineProperty(this, "message", {
                        value
                    });
                }
            },
            pos: {
                reflect: "loc.index",
                enumerable: true
            },
            missingPlugin: "missingPlugin" in details && {
                reflect: "details.missingPlugin",
                enumerable: true
            }
        });
    };
}
function ParseErrorEnum(argument, syntaxPlugin) {
    if (Array.isArray(argument)) return (parseErrorTemplates)=>ParseErrorEnum(parseErrorTemplates, argument[0]);
    const ParseErrorConstructors = {};
    for (const reasonCode of Object.keys(argument)){
        const template = argument[reasonCode];
        const _ref2 = typeof template === "string" ? {
            message: ()=>template
        } : typeof template === "function" ? {
            message: template
        } : template, { message  } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
        const toMessage = typeof message === "string" ? ()=>message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
            code: ParseErrorCode.SyntaxError,
            reasonCode,
            toMessage
        }, syntaxPlugin ? {
            syntaxPlugin
        } : {}, rest));
    }
    return ParseErrorConstructors;
}
const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
const { defineProperty  } = Object;
const toUnenumerable = (object, key)=>defineProperty(object, key, {
        enumerable: false,
        value: object[key]
    });
function toESTreeLocation(node) {
    node.loc.start && toUnenumerable(node.loc.start, "index");
    node.loc.end && toUnenumerable(node.loc.end, "index");
    return node;
}
var estree = (superClass)=>class ESTreeParserMixin extends superClass {
        parse() {
            const file = toESTreeLocation(super.parse());
            if (this.options.tokens) file.tokens = file.tokens.map(toESTreeLocation);
            return file;
        }
        parseRegExpLiteral({ pattern , flags  }) {
            let regex = null;
            try {
                regex = new RegExp(pattern, flags);
            } catch (e) {}
            const node = this.estreeParseLiteral(regex);
            node.regex = {
                pattern,
                flags
            };
            return node;
        }
        parseBigIntLiteral(value) {
            let bigInt;
            try {
                bigInt = BigInt(value);
            } catch (_unused) {
                bigInt = null;
            }
            const node = this.estreeParseLiteral(bigInt);
            node.bigint = String(node.value || value);
            return node;
        }
        parseDecimalLiteral(value) {
            const decimal = null;
            const node = this.estreeParseLiteral(decimal);
            node.decimal = String(node.value || value);
            return node;
        }
        estreeParseLiteral(value) {
            return this.parseLiteral(value, "Literal");
        }
        parseStringLiteral(value) {
            return this.estreeParseLiteral(value);
        }
        parseNumericLiteral(value) {
            return this.estreeParseLiteral(value);
        }
        parseNullLiteral() {
            return this.estreeParseLiteral(null);
        }
        parseBooleanLiteral(value) {
            return this.estreeParseLiteral(value);
        }
        directiveToStmt(directive) {
            const expression = directive.value;
            delete directive.value;
            expression.type = "Literal";
            expression.raw = expression.extra.raw;
            expression.value = expression.extra.expressionValue;
            const stmt = directive;
            stmt.type = "ExpressionStatement";
            stmt.expression = expression;
            stmt.directive = expression.extra.rawValue;
            delete expression.extra;
            return stmt;
        }
        initFunction(node, isAsync) {
            super.initFunction(node, isAsync);
            node.expression = false;
        }
        checkDeclaration(node) {
            if (node != null && this.isObjectProperty(node)) this.checkDeclaration(node.value);
            else super.checkDeclaration(node);
        }
        getObjectOrClassMethodParams(method) {
            return method.value.params;
        }
        isValidDirective(stmt) {
            var _stmt$expression$extr;
            return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
            super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
            const directiveStatements = node.directives.map((d)=>this.directiveToStmt(d));
            node.body = directiveStatements.concat(node.body);
            delete node.directives;
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
            if (method.typeParameters) {
                method.value.typeParameters = method.typeParameters;
                delete method.typeParameters;
            }
            classBody.body.push(method);
        }
        parsePrivateName() {
            const node = super.parsePrivateName();
            if (!this.getPluginOption("estree", "classFeatures")) return node;
            return this.convertPrivateNameToPrivateIdentifier(node);
        }
        convertPrivateNameToPrivateIdentifier(node) {
            const name = super.getPrivateNameSV(node);
            node;
            delete node.id;
            node.name = name;
            node.type = "PrivateIdentifier";
            return node;
        }
        isPrivateName(node) {
            if (!this.getPluginOption("estree", "classFeatures")) return super.isPrivateName(node);
            return node.type === "PrivateIdentifier";
        }
        getPrivateNameSV(node) {
            if (!this.getPluginOption("estree", "classFeatures")) return super.getPrivateNameSV(node);
            return node.name;
        }
        parseLiteral(value, type) {
            const node = super.parseLiteral(value, type);
            node.raw = node.extra.raw;
            delete node.extra;
            return node;
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
            super.parseFunctionBody(node, allowExpression, isMethod);
            node.expression = node.body.type !== "BlockStatement";
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
            let funcNode = this.startNode();
            funcNode.kind = node.kind;
            funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
            funcNode.type = "FunctionExpression";
            delete funcNode.kind;
            node.value = funcNode;
            if (type === "ClassPrivateMethod") node.computed = false;
            return this.finishNode(node, "MethodDefinition");
        }
        parseClassProperty(...args) {
            const propertyNode = super.parseClassProperty(...args);
            if (!this.getPluginOption("estree", "classFeatures")) return propertyNode;
            propertyNode.type = "PropertyDefinition";
            return propertyNode;
        }
        parseClassPrivateProperty(...args) {
            const propertyNode = super.parseClassPrivateProperty(...args);
            if (!this.getPluginOption("estree", "classFeatures")) return propertyNode;
            propertyNode.type = "PropertyDefinition";
            propertyNode.computed = false;
            return propertyNode;
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
            const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
            if (node) {
                node.type = "Property";
                if (node.kind === "method") node.kind = "init";
                node.shorthand = false;
            }
            return node;
        }
        parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
            const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
            if (node) {
                node.kind = "init";
                node.type = "Property";
            }
            return node;
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
            return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        isAssignable(node, isBinding) {
            if (node != null && this.isObjectProperty(node)) return this.isAssignable(node.value, isBinding);
            return super.isAssignable(node, isBinding);
        }
        toAssignable(node, isLHS = false) {
            if (node != null && this.isObjectProperty(node)) {
                const { key , value  } = node;
                if (this.isPrivateName(key)) this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
                this.toAssignable(value, isLHS);
            } else super.toAssignable(node, isLHS);
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
            if (prop.kind === "get" || prop.kind === "set") this.raise(Errors.PatternHasAccessor, {
                at: prop.key
            });
            else if (prop.method) this.raise(Errors.PatternHasMethod, {
                at: prop.key
            });
            else super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
        finishCallExpression(unfinished, optional) {
            const node = super.finishCallExpression(unfinished, optional);
            if (node.callee.type === "Import") {
                node.type = "ImportExpression";
                node.source = node.arguments[0];
                if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
                    var _node$arguments$;
                    node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
                }
                delete node.arguments;
                delete node.callee;
            }
            return node;
        }
        toReferencedArguments(node) {
            if (node.type === "ImportExpression") return;
            super.toReferencedArguments(node);
        }
        parseExport(unfinished, decorators) {
            const exportStartLoc = this.state.lastTokStartLoc;
            const node = super.parseExport(unfinished, decorators);
            switch(node.type){
                case "ExportAllDeclaration":
                    node.exported = null;
                    break;
                case "ExportNamedDeclaration":
                    if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                        node.type = "ExportAllDeclaration";
                        node.exported = node.specifiers[0].exported;
                        delete node.specifiers;
                    }
                case "ExportDefaultDeclaration":
                    {
                        var _declaration$decorato;
                        const { declaration  } = node;
                        if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) this.resetStartLocation(node, exportStartLoc);
                    }
                    break;
            }
            return node;
        }
        parseSubscript(base, startLoc, noCalls, state) {
            const node = super.parseSubscript(base, startLoc, noCalls, state);
            if (state.optionalChainMember) {
                if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") node.type = node.type.substring(8);
                if (state.stop) {
                    const chain = this.startNodeAtNode(node);
                    chain.expression = node;
                    return this.finishNode(chain, "ChainExpression");
                }
            } else if (node.type === "MemberExpression" || node.type === "CallExpression") node.optional = false;
            return node;
        }
        hasPropertyAsPrivateName(node) {
            if (node.type === "ChainExpression") node = node.expression;
            return super.hasPropertyAsPrivateName(node);
        }
        isObjectProperty(node) {
            return node.type === "Property" && node.kind === "init" && !node.method;
        }
        isObjectMethod(node) {
            return node.method || node.kind === "get" || node.kind === "set";
        }
        finishNodeAt(node, type, endLoc) {
            return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
        }
        resetStartLocation(node, startLoc) {
            super.resetStartLocation(node, startLoc);
            toESTreeLocation(node);
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
            super.resetEndLocation(node, endLoc);
            toESTreeLocation(node);
        }
    };
class TokContext {
    constructor(token, preserveSpace){
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
    }
}
const types = {
    brace: new TokContext("{"),
    j_oTag: new TokContext("<tag"),
    j_cTag: new TokContext("</tag"),
    j_expr: new TokContext("<tag>...</tag>", true)
};
types.template = new TokContext("`", true);
const beforeExpr = true;
const startsExpr = true;
const isLoop = true;
const isAssign = true;
const prefix = true;
const postfix = true;
class ExportedTokenType {
    constructor(label, conf = {}){
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        this.updateContext = null;
    }
}
const keywords$1 = new Map();
function createKeyword(name, options = {}) {
    options.keyword = name;
    const token = createToken(name, options);
    keywords$1.set(name, token);
    return token;
}
function createBinop(name, binop) {
    return createToken(name, {
        beforeExpr,
        binop
    });
}
let tokenTypeCounter = -1;
const tokenTypes = [];
const tokenLabels = [];
const tokenBinops = [];
const tokenBeforeExprs = [];
const tokenStartsExprs = [];
const tokenPrefixes = [];
function createToken(name, options = {}) {
    var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
    ++tokenTypeCounter;
    tokenLabels.push(name);
    tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
    tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
    tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
    tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
    tokenTypes.push(new ExportedTokenType(name, options));
    return tokenTypeCounter;
}
function createKeywordLike(name, options = {}) {
    var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
    ++tokenTypeCounter;
    keywords$1.set(name, tokenTypeCounter);
    tokenLabels.push(name);
    tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
    tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
    tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
    tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
    tokenTypes.push(new ExportedTokenType("name", options));
    return tokenTypeCounter;
}
const tt = {
    bracketL: createToken("[", {
        beforeExpr,
        startsExpr
    }),
    bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
    }),
    bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
    }),
    bracketR: createToken("]"),
    bracketBarR: createToken("|]"),
    braceL: createToken("{", {
        beforeExpr,
        startsExpr
    }),
    braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
    }),
    braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
    }),
    braceR: createToken("}"),
    braceBarR: createToken("|}"),
    parenL: createToken("(", {
        beforeExpr,
        startsExpr
    }),
    parenR: createToken(")"),
    comma: createToken(",", {
        beforeExpr
    }),
    semi: createToken(";", {
        beforeExpr
    }),
    colon: createToken(":", {
        beforeExpr
    }),
    doubleColon: createToken("::", {
        beforeExpr
    }),
    dot: createToken("."),
    question: createToken("?", {
        beforeExpr
    }),
    questionDot: createToken("?."),
    arrow: createToken("=>", {
        beforeExpr
    }),
    template: createToken("template"),
    ellipsis: createToken("...", {
        beforeExpr
    }),
    backQuote: createToken("`", {
        startsExpr
    }),
    dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
    }),
    templateTail: createToken("...`", {
        startsExpr
    }),
    templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
    }),
    at: createToken("@"),
    hash: createToken("#", {
        startsExpr
    }),
    interpreterDirective: createToken("#!..."),
    eq: createToken("=", {
        beforeExpr,
        isAssign
    }),
    assign: createToken("_=", {
        beforeExpr,
        isAssign
    }),
    slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
    }),
    xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
    }),
    moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
    }),
    incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
    }),
    bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    doubleCaret: createToken("^^", {
        startsExpr
    }),
    doubleAt: createToken("@@", {
        startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    lt: createBinop("</>/<=/>=", 7),
    gt: createBinop("</>/<=/>=", 7),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    bitShiftL: createBinop("<</>>/>>>", 8),
    bitShiftR: createBinop("<</>>/>>>", 8),
    plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
    }),
    modulo: createToken("%", {
        binop: 10,
        startsExpr
    }),
    star: createToken("*", {
        binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
    }),
    _in: createKeyword("in", {
        beforeExpr,
        binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
        beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
        beforeExpr
    }),
    _else: createKeyword("else", {
        beforeExpr
    }),
    _finally: createKeyword("finally"),
    _function: createKeyword("function", {
        startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
        beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
        beforeExpr,
        startsExpr
    }),
    _this: createKeyword("this", {
        startsExpr
    }),
    _super: createKeyword("super", {
        startsExpr
    }),
    _class: createKeyword("class", {
        startsExpr
    }),
    _extends: createKeyword("extends", {
        beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
        startsExpr
    }),
    _null: createKeyword("null", {
        startsExpr
    }),
    _true: createKeyword("true", {
        startsExpr
    }),
    _false: createKeyword("false", {
        startsExpr
    }),
    _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
    }),
    _do: createKeyword("do", {
        isLoop,
        beforeExpr
    }),
    _for: createKeyword("for", {
        isLoop
    }),
    _while: createKeyword("while", {
        isLoop
    }),
    _as: createKeywordLike("as", {
        startsExpr
    }),
    _assert: createKeywordLike("assert", {
        startsExpr
    }),
    _async: createKeywordLike("async", {
        startsExpr
    }),
    _await: createKeywordLike("await", {
        startsExpr
    }),
    _from: createKeywordLike("from", {
        startsExpr
    }),
    _get: createKeywordLike("get", {
        startsExpr
    }),
    _let: createKeywordLike("let", {
        startsExpr
    }),
    _meta: createKeywordLike("meta", {
        startsExpr
    }),
    _of: createKeywordLike("of", {
        startsExpr
    }),
    _sent: createKeywordLike("sent", {
        startsExpr
    }),
    _set: createKeywordLike("set", {
        startsExpr
    }),
    _static: createKeywordLike("static", {
        startsExpr
    }),
    _using: createKeywordLike("using", {
        startsExpr
    }),
    _yield: createKeywordLike("yield", {
        startsExpr
    }),
    _asserts: createKeywordLike("asserts", {
        startsExpr
    }),
    _checks: createKeywordLike("checks", {
        startsExpr
    }),
    _exports: createKeywordLike("exports", {
        startsExpr
    }),
    _global: createKeywordLike("global", {
        startsExpr
    }),
    _implements: createKeywordLike("implements", {
        startsExpr
    }),
    _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
    }),
    _infer: createKeywordLike("infer", {
        startsExpr
    }),
    _is: createKeywordLike("is", {
        startsExpr
    }),
    _mixins: createKeywordLike("mixins", {
        startsExpr
    }),
    _proto: createKeywordLike("proto", {
        startsExpr
    }),
    _require: createKeywordLike("require", {
        startsExpr
    }),
    _satisfies: createKeywordLike("satisfies", {
        startsExpr
    }),
    _keyof: createKeywordLike("keyof", {
        startsExpr
    }),
    _readonly: createKeywordLike("readonly", {
        startsExpr
    }),
    _unique: createKeywordLike("unique", {
        startsExpr
    }),
    _abstract: createKeywordLike("abstract", {
        startsExpr
    }),
    _declare: createKeywordLike("declare", {
        startsExpr
    }),
    _enum: createKeywordLike("enum", {
        startsExpr
    }),
    _module: createKeywordLike("module", {
        startsExpr
    }),
    _namespace: createKeywordLike("namespace", {
        startsExpr
    }),
    _interface: createKeywordLike("interface", {
        startsExpr
    }),
    _type: createKeywordLike("type", {
        startsExpr
    }),
    _opaque: createKeywordLike("opaque", {
        startsExpr
    }),
    name: createToken("name", {
        startsExpr
    }),
    string: createToken("string", {
        startsExpr
    }),
    num: createToken("num", {
        startsExpr
    }),
    bigint: createToken("bigint", {
        startsExpr
    }),
    decimal: createToken("decimal", {
        startsExpr
    }),
    regexp: createToken("regexp", {
        startsExpr
    }),
    privateName: createToken("#name", {
        startsExpr
    }),
    eof: createToken("eof"),
    jsxName: createToken("jsxName"),
    jsxText: createToken("jsxText", {
        beforeExpr: true
    }),
    jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
    }),
    jsxTagEnd: createToken("jsxTagEnd"),
    placeholder: createToken("%%", {
        startsExpr: true
    })
};
function tokenIsIdentifier(token) {
    return token >= 93 && token <= 130;
}
function tokenKeywordOrIdentifierIsKeyword(token) {
    return token <= 92;
}
function tokenIsKeywordOrIdentifier(token) {
    return token >= 58 && token <= 130;
}
function tokenIsLiteralPropertyName(token) {
    return token >= 58 && token <= 134;
}
function tokenComesBeforeExpression(token) {
    return tokenBeforeExprs[token];
}
function tokenCanStartExpression(token) {
    return tokenStartsExprs[token];
}
function tokenIsAssignment(token) {
    return token >= 29 && token <= 33;
}
function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
    return token >= 127 && token <= 129;
}
function tokenIsLoop(token) {
    return token >= 90 && token <= 92;
}
function tokenIsKeyword(token) {
    return token >= 58 && token <= 92;
}
function tokenIsOperator(token) {
    return token >= 39 && token <= 59;
}
function tokenIsPostfix(token) {
    return token === 34;
}
function tokenIsPrefix(token) {
    return tokenPrefixes[token];
}
function tokenIsTSTypeOperator(token) {
    return token >= 119 && token <= 121;
}
function tokenIsTSDeclarationStart(token) {
    return token >= 122 && token <= 128;
}
function tokenLabelName(token) {
    return tokenLabels[token];
}
function tokenOperatorPrecedence(token) {
    return tokenBinops[token];
}
function tokenIsRightAssociative(token) {
    return token === 57;
}
function tokenIsTemplate(token) {
    return token >= 24 && token <= 25;
}
function getExportedToken(token) {
    return tokenTypes[token];
}
tokenTypes[8].updateContext = (context)=>{
    context.pop();
};
tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context)=>{
    context.push(types.brace);
};
tokenTypes[22].updateContext = (context)=>{
    if (context[context.length - 1] === types.template) context.pop();
    else context.push(types.template);
};
tokenTypes[140].updateContext = (context)=>{
    context.push(types.j_expr, types.j_oTag);
};
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
let nonASCIIidentifierChars = "‌‍\xb7̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    68,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    349,
    41,
    7,
    1,
    79,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    20,
    1,
    64,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    16,
    0,
    2,
    12,
    2,
    33,
    125,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1071,
    18,
    5,
    4026,
    582,
    8634,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    689,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    43,
    8,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    16,
    0,
    30,
    2,
    3,
    0,
    15,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    7,
    5,
    262,
    61,
    147,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    485,
    27,
    757,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4153,
    7,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
    1507,
    4938,
    6,
    4191
];
const astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    370,
    1,
    81,
    2,
    71,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    3,
    0,
    158,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    10,
    1,
    2,
    0,
    49,
    6,
    4,
    4,
    14,
    9,
    5351,
    0,
    7,
    14,
    13835,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    1014,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4706,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    101,
    0,
    161,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    499,
    13,
    983,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
];
function isInAstralSet(code, set) {
    let pos = 0x10000;
    for(let i = 0, length = set.length; i < length; i += 2){
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
    }
    return false;
}
function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
const reservedWords = {
    keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ],
    strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ],
    strictBind: [
        "eval",
        "arguments"
    ]
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
    return keywords.has(word);
}
function isIteratorStart(current, next, next2) {
    return current === 64 && next === 64 && isIdentifierStart(next2);
}
const reservedWordLikeSet = new Set([
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete",
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield",
    "eval",
    "arguments",
    "enum",
    "await"
]);
function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
}
const SCOPE_OTHER = 0, SCOPE_PROGRAM = 1, SCOPE_FUNCTION = 2, SCOPE_ARROW = 4, SCOPE_SIMPLE_CATCH = 8, SCOPE_SUPER = 16, SCOPE_DIRECT_SUPER = 32, SCOPE_CLASS = 64, SCOPE_STATIC_BLOCK = 128, SCOPE_TS_MODULE = 256, SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_STATIC_BLOCK | SCOPE_TS_MODULE;
const BIND_KIND_VALUE = 1, BIND_KIND_TYPE = 2, BIND_SCOPE_VAR = 4, BIND_SCOPE_LEXICAL = 8, BIND_SCOPE_FUNCTION = 16, BIND_FLAGS_NONE = 64, BIND_FLAGS_CLASS = 128, BIND_FLAGS_TS_ENUM = 256, BIND_FLAGS_TS_CONST_ENUM = 512, BIND_FLAGS_TS_EXPORT_ONLY = 1024, BIND_FLAGS_FLOW_DECLARE_FN = 2048, BIND_FLAGS_TS_IMPORT = 4096, BIND_FLAGS_NO_LET_IN_LEXICAL = 8192;
const BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS | BIND_FLAGS_NO_LET_IN_LEXICAL, BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | BIND_FLAGS_NO_LET_IN_LEXICAL, BIND_CATCH_PARAM = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0, BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0, BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0, BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS, BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0, BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM | BIND_FLAGS_NO_LET_IN_LEXICAL, BIND_TS_AMBIENT = 0 | BIND_FLAGS_TS_EXPORT_ONLY, BIND_NONE = 0 | BIND_FLAGS_NONE, BIND_OUTSIDE = BIND_KIND_VALUE | 0 | BIND_FLAGS_NONE, BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM, BIND_TS_NAMESPACE = 0 | BIND_FLAGS_TS_EXPORT_ONLY, BIND_TS_TYPE_IMPORT = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_TS_IMPORT, BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
const CLASS_ELEMENT_FLAG_STATIC = 4, CLASS_ELEMENT_KIND_GETTER = 2, CLASS_ELEMENT_KIND_SETTER = 1, CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
const CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC, CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC, CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER, CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER, CLASS_ELEMENT_OTHER = 0;
class Scope {
    constructor(flags){
        this.var = new Set();
        this.lexical = new Set();
        this.functions = new Set();
        this.flags = flags;
    }
}
class ScopeHandler {
    constructor(parser, inModule){
        this.parser = void 0;
        this.scopeStack = [];
        this.inModule = void 0;
        this.undefinedExports = new Map();
        this.parser = parser;
        this.inModule = inModule;
    }
    get inTopLevel() {
        return (this.currentScope().flags & SCOPE_PROGRAM) > 0;
    }
    get inFunction() {
        return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
    }
    get allowSuper() {
        return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
    }
    get allowDirectSuper() {
        return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
    }
    get inClass() {
        return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
    }
    get inStaticBlock() {
        for(let i = this.scopeStack.length - 1;; i--){
            const { flags  } = this.scopeStack[i];
            if (flags & SCOPE_STATIC_BLOCK) return true;
            if (flags & (SCOPE_VAR | SCOPE_CLASS)) return false;
        }
    }
    get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
    }
    get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(flags) {
        return new Scope(flags);
    }
    enter(flags) {
        this.scopeStack.push(this.createScope(flags));
    }
    exit() {
        const scope = this.scopeStack.pop();
        return scope.flags;
    }
    treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);
    }
    declareName(name, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            if (bindingType & BIND_SCOPE_FUNCTION) scope.functions.add(name);
            else scope.lexical.add(name);
            if (bindingType & BIND_SCOPE_LEXICAL) this.maybeExportDefined(scope, name);
        } else if (bindingType & BIND_SCOPE_VAR) for(let i = this.scopeStack.length - 1; i >= 0; --i){
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            scope.var.add(name);
            this.maybeExportDefined(scope, name);
            if (scope.flags & SCOPE_VAR) break;
        }
        if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) this.undefinedExports.delete(name);
    }
    maybeExportDefined(scope, name) {
        if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) this.undefinedExports.delete(name);
    }
    checkRedeclarationInScope(scope, name, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name, bindingType)) this.parser.raise(Errors.VarRedeclaration, {
            at: loc,
            identifierName: name
        });
    }
    isRedeclaredInScope(scope, name, bindingType) {
        if (!(bindingType & BIND_KIND_VALUE)) return false;
        if (bindingType & BIND_SCOPE_LEXICAL) return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
        if (bindingType & BIND_SCOPE_FUNCTION) return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
        return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
    }
    checkLocalExport(id) {
        const { name  } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) this.undefinedExports.set(name, id.loc.start);
    }
    currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
        for(let i = this.scopeStack.length - 1;; i--){
            const { flags  } = this.scopeStack[i];
            if (flags & SCOPE_VAR) return flags;
        }
    }
    currentThisScopeFlags() {
        for(let i = this.scopeStack.length - 1;; i--){
            const { flags  } = this.scopeStack[i];
            if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) return flags;
        }
    }
}
class FlowScope extends Scope {
    constructor(...args){
        super(...args);
        this.declareFunctions = new Set();
    }
}
class FlowScopeHandler extends ScopeHandler {
    createScope(flags) {
        return new FlowScope(flags);
    }
    declareName(name, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
            scope.declareFunctions.add(name);
            return;
        }
        super.declareName(name, bindingType, loc);
    }
    isRedeclaredInScope(scope, name, bindingType) {
        if (super.isRedeclaredInScope(scope, name, bindingType)) return true;
        if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
        return false;
    }
    checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) super.checkLocalExport(id);
    }
}
class BaseParser {
    constructor(){
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") return this.plugins.has(pluginConfig);
        else {
            const [pluginName, pluginOptions] = pluginConfig;
            if (!this.hasPlugin(pluginName)) return false;
            const actualOptions = this.plugins.get(pluginName);
            for (const key of Object.keys(pluginOptions)){
                if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) return false;
            }
            return true;
        }
    }
    getPluginOption(plugin, name) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
    }
}
function setTrailingComments(node, comments) {
    if (node.trailingComments === undefined) node.trailingComments = comments;
    else node.trailingComments.unshift(...comments);
}
function setLeadingComments(node, comments) {
    if (node.leadingComments === undefined) node.leadingComments = comments;
    else node.leadingComments.unshift(...comments);
}
function setInnerComments(node, comments) {
    if (node.innerComments === undefined) node.innerComments = comments;
    else node.innerComments.unshift(...comments);
}
function adjustInnerComments(node, elements, commentWS) {
    let lastElement = null;
    let i = elements.length;
    while(lastElement === null && i > 0)lastElement = elements[--i];
    if (lastElement === null || lastElement.start > commentWS.start) setInnerComments(node, commentWS.comments);
    else setTrailingComments(lastElement, commentWS.comments);
}
class CommentsParser extends BaseParser {
    addComment(comment) {
        if (this.filename) comment.loc.filename = this.filename;
        this.state.comments.push(comment);
    }
    processComment(node) {
        const { commentStack  } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node.end) {
            lastCommentWS.leadingNode = node;
            i--;
        }
        const { start: nodeStart  } = node;
        for(; i >= 0; i--){
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            if (commentEnd > nodeStart) {
                commentWS.containingNode = node;
                this.finalizeComment(commentWS);
                commentStack.splice(i, 1);
            } else {
                if (commentEnd === nodeStart) commentWS.trailingNode = node;
                break;
            }
        }
    }
    finalizeComment(commentWS) {
        const { comments  } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
            if (commentWS.leadingNode !== null) setTrailingComments(commentWS.leadingNode, comments);
            if (commentWS.trailingNode !== null) setLeadingComments(commentWS.trailingNode, comments);
        } else {
            const { containingNode: node , start: commentStart  } = commentWS;
            if (this.input.charCodeAt(commentStart - 1) === 44) switch(node.type){
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                    adjustInnerComments(node, node.properties, commentWS);
                    break;
                case "CallExpression":
                case "OptionalCallExpression":
                    adjustInnerComments(node, node.arguments, commentWS);
                    break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                    adjustInnerComments(node, node.params, commentWS);
                    break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                    adjustInnerComments(node, node.elements, commentWS);
                    break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                    adjustInnerComments(node, node.specifiers, commentWS);
                    break;
                default:
                    setInnerComments(node, comments);
            }
            else setInnerComments(node, comments);
        }
    }
    finalizeRemainingComments() {
        const { commentStack  } = this.state;
        for(let i = commentStack.length - 1; i >= 0; i--)this.finalizeComment(commentStack[i]);
        this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(node) {
        const { commentStack  } = this.state;
        const { length  } = commentStack;
        if (length === 0) return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node) commentWS.leadingNode = null;
    }
    resetPreviousIdentifierLeadingComments(node) {
        const { commentStack  } = this.state;
        const { length  } = commentStack;
        if (length === 0) return;
        if (commentStack[length - 1].trailingNode === node) commentStack[length - 1].trailingNode = null;
        else if (length >= 2 && commentStack[length - 2].trailingNode === node) commentStack[length - 2].trailingNode = null;
    }
    takeSurroundingComments(node, start, end) {
        const { commentStack  } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        for(; i >= 0; i--){
            const commentWS = commentStack[i];
            const commentEnd = commentWS.end;
            const commentStart = commentWS.start;
            if (commentStart === end) commentWS.leadingNode = node;
            else if (commentEnd === start) commentWS.trailingNode = node;
            else if (commentEnd < start) break;
        }
    }
}
const lineBreak = /\r\n?|[\n\u2028\u2029]/;
const lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
    switch(code){
        case 10:
        case 13:
        case 8232:
        case 8233:
            return true;
        default:
            return false;
    }
}
const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
const skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function isWhitespace(code) {
    switch(code){
        case 0x0009:
        case 0x000b:
        case 0x000c:
        case 32:
        case 160:
        case 5760:
        case 0x2000:
        case 0x2001:
        case 0x2002:
        case 0x2003:
        case 0x2004:
        case 0x2005:
        case 0x2006:
        case 0x2007:
        case 0x2008:
        case 0x2009:
        case 0x200a:
        case 0x202f:
        case 0x205f:
        case 0x3000:
        case 0xfeff:
            return true;
        default:
            return false;
    }
}
class State {
    constructor(){
        this.strict = void 0;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.maybeInArrowParameters = false;
        this.inType = false;
        this.noAnonFunctionType = false;
        this.hasFlowComment = false;
        this.isAmbientContext = false;
        this.inAbstractClass = false;
        this.inDisallowConditionalTypesContext = false;
        this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
        };
        this.soloAwait = false;
        this.inFSharpPipelineDirectBody = false;
        this.labels = [];
        this.comments = [];
        this.commentStack = [];
        this.pos = 0;
        this.type = 137;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.lastTokStart = 0;
        this.context = [
            types.brace
        ];
        this.canStartJSXElement = true;
        this.containsEsc = false;
        this.firstInvalidTemplateEscapePos = null;
        this.strictErrors = new Map();
        this.tokensLength = 0;
    }
    init({ strictMode , sourceType , startLine , startColumn  }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
    }
    curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone(skipArrays) {
        const state = new State();
        const keys = Object.keys(this);
        for(let i = 0, length = keys.length; i < length; i++){
            const key = keys[i];
            let val = this[key];
            if (!skipArrays && Array.isArray(val)) val = val.slice();
            state[key] = val;
        }
        return state;
    }
}
var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
};
const forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([
        46,
        66,
        69,
        79,
        95,
        98,
        101,
        111
    ]),
    hex: new Set([
        46,
        88,
        95,
        120
    ])
};
const isAllowedNumericSeparatorSibling = {
    bin: (ch)=>ch === 48 || ch === 49,
    oct: (ch)=>ch >= 48 && ch <= 55,
    dec: (ch)=>ch >= 48 && ch <= 57,
    hex: (ch)=>ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
};
function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const { length  } = input;
    for(;;){
        if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
        }
        if (ch === 92) {
            out += input.slice(chunkStart, pos);
            const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
            if (res.ch === null && !firstInvalidLoc) firstInvalidLoc = {
                pos,
                lineStart,
                curLine
            };
            else out += res.ch;
            ({ pos , lineStart , curLine  } = res);
            chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
        } else if (ch === 10 || ch === 13) {
            if (type === "template") {
                out += input.slice(chunkStart, pos) + "\n";
                ++pos;
                if (ch === 13 && input.charCodeAt(pos) === 10) ++pos;
                ++curLine;
                chunkStart = lineStart = pos;
            } else errors.unterminated(initialPos, initialLineStart, initialCurLine);
        } else ++pos;
    }
    return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
    };
}
function isStringEnd(type, ch, input, pos) {
    if (type === "template") return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    return ch === (type === "double" ? 34 : 39);
}
function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch)=>({
            pos,
            ch,
            lineStart,
            curLine
        });
    const ch = input.charCodeAt(pos++);
    switch(ch){
        case 110:
            return res("\n");
        case 114:
            return res("\r");
        case 120:
            {
                let code;
                ({ code , pos  } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
                return res(code === null ? null : String.fromCharCode(code));
            }
        case 117:
            {
                let code;
                ({ code , pos  } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
                return res(code === null ? null : String.fromCodePoint(code));
            }
        case 116:
            return res("	");
        case 98:
            return res("\b");
        case 118:
            return res("\v");
        case 102:
            return res("\f");
        case 13:
            if (input.charCodeAt(pos) === 10) ++pos;
        case 10:
            lineStart = pos;
            ++curLine;
        case 8232:
        case 8233:
            return res("");
        case 56:
        case 57:
            if (inTemplate) return res(null);
            else errors.strictNumericEscape(pos - 1, lineStart, curLine);
        default:
            if (ch >= 48 && ch <= 55) {
                const startPos = pos - 1;
                const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
                let octalStr = match[0];
                let octal = parseInt(octalStr, 8);
                if (octal > 255) {
                    octalStr = octalStr.slice(0, -1);
                    octal = parseInt(octalStr, 8);
                }
                pos += octalStr.length - 1;
                const next = input.charCodeAt(pos);
                if (octalStr !== "0" || next === 56 || next === 57) {
                    if (inTemplate) return res(null);
                    else errors.strictNumericEscape(startPos, lineStart, curLine);
                }
                return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
    }
}
function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n;
    ({ n , pos  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    if (n === null) {
        if (throwOnInvalid) errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        else pos = initialPos - 1;
    }
    return {
        code: n,
        pos
    };
}
function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for(let i = 0, e = len == null ? Infinity : len; i < e; ++i){
        const code = input.charCodeAt(pos);
        let val;
        if (code === 95 && allowNumSeparator !== "bail") {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
                if (bailOnError) return {
                    n: null,
                    pos
                };
                errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                if (bailOnError) return {
                    n: null,
                    pos
                };
                errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
        }
        if (code >= 97) val = code - 97 + 10;
        else if (code >= 65) val = code - 65 + 10;
        else if (_isDigit(code)) val = code - 48;
        else val = Infinity;
        if (val >= radix) {
            if (val <= 9 && bailOnError) return {
                n: null,
                pos
            };
            else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) val = 0;
            else if (forceLen) {
                val = 0;
                invalid = true;
            } else break;
        }
        ++pos;
        total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) return {
        n: null,
        pos
    };
    return {
        n: total,
        pos
    };
}
function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code;
    if (ch === 123) {
        ++pos;
        ({ code , pos  } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code !== null && code > 0x10ffff) {
            if (throwOnInvalid) errors.invalidCodePoint(pos, lineStart, curLine);
            else return {
                code: null,
                pos
            };
        }
    } else ({ code , pos  } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    return {
        code,
        pos
    };
}
const _excluded = [
    "at"
], _excluded2 = [
    "at"
];
function buildPosition(pos, lineStart, curLine) {
    return new Position(curLine, pos - lineStart, pos);
}
const VALID_REGEX_FLAGS = new Set([
    103,
    109,
    115,
    105,
    121,
    117,
    100,
    118
]);
class Token {
    constructor(state){
        this.type = state.type;
        this.value = state.value;
        this.start = state.start;
        this.end = state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }
}
class Tokenizer extends CommentsParser {
    constructor(options, input){
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.errorHandlers_readInt = {
            invalidDigit: (pos, lineStart, curLine, radix)=>{
                if (!this.options.errorRecovery) return false;
                this.raise(Errors.InvalidDigit, {
                    at: buildPosition(pos, lineStart, curLine),
                    radix
                });
                return true;
            },
            numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
            unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        };
        this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
            invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
            invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        });
        this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: (pos, lineStart, curLine)=>{
                this.recordStrictModeErrors(Errors.StrictNumericEscape, {
                    at: buildPosition(pos, lineStart, curLine)
                });
            },
            unterminated: (pos, lineStart, curLine)=>{
                throw this.raise(Errors.UnterminatedString, {
                    at: buildPosition(pos - 1, lineStart, curLine)
                });
            }
        });
        this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
            unterminated: (pos, lineStart, curLine)=>{
                throw this.raise(Errors.UnterminatedTemplate, {
                    at: buildPosition(pos, lineStart, curLine)
                });
            }
        });
        this.state = new State();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.isLookahead = false;
    }
    pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
    }
    next() {
        this.checkKeywordEscapes();
        if (this.options.tokens) this.pushToken(new Token(this.state));
        this.state.lastTokStart = this.state.start;
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
    }
    eat(type) {
        if (this.match(type)) {
            this.next();
            return true;
        } else return false;
    }
    match(type) {
        return this.state.type === type;
    }
    createLookaheadState(state) {
        return {
            pos: state.pos,
            value: null,
            type: state.type,
            start: state.start,
            end: state.end,
            context: [
                this.curContext()
            ],
            inType: state.inType,
            startLoc: state.startLoc,
            lastTokEndLoc: state.lastTokEndLoc,
            curLine: state.curLine,
            lineStart: state.lineStart,
            curPosition: state.curPosition
        };
    }
    lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
    }
    nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    }
    lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(pos) {
        skipWhiteSpaceInLine.lastIndex = pos;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
    }
    lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {
            const trail = this.input.charCodeAt(pos);
            if ((trail & 0xfc00) === 0xdc00) cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
        return cp;
    }
    setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
            this.state.strictErrors.forEach(([toParseError, at])=>this.raise(toParseError, {
                    at
                }));
            this.state.strictErrors.clear();
        }
    }
    curContext() {
        return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
            this.finishToken(137);
            return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(commentEnd) {
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        if (end === -1) throw this.raise(Errors.UnterminatedComment, {
            at: this.state.curPosition()
        });
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while(lineBreakG.test(this.input) && lineBreakG.lastIndex <= end){
            ++this.state.curLine;
            this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead) return;
        const comment = {
            type: "CommentBlock",
            value: this.input.slice(start + 2, end),
            start,
            end: end + commentEnd.length,
            loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens) this.pushToken(comment);
        return comment;
    }
    skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) while(!isNewLine(ch) && ++this.state.pos < this.length)ch = this.input.charCodeAt(this.state.pos);
        if (this.isLookahead) return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
            type: "CommentLine",
            value,
            start,
            end,
            loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens) this.pushToken(comment);
        return comment;
    }
    skipSpace() {
        const spaceStart = this.state.pos;
        const comments = [];
        loop: while(this.state.pos < this.length){
            const ch = this.input.charCodeAt(this.state.pos);
            switch(ch){
                case 32:
                case 160:
                case 9:
                    ++this.state.pos;
                    break;
                case 13:
                    if (this.input.charCodeAt(this.state.pos + 1) === 10) ++this.state.pos;
                case 10:
                case 8232:
                case 8233:
                    ++this.state.pos;
                    ++this.state.curLine;
                    this.state.lineStart = this.state.pos;
                    break;
                case 47:
                    switch(this.input.charCodeAt(this.state.pos + 1)){
                        case 42:
                            {
                                const comment = this.skipBlockComment("*/");
                                if (comment !== undefined) {
                                    this.addComment(comment);
                                    if (this.options.attachComment) comments.push(comment);
                                }
                                break;
                            }
                        case 47:
                            {
                                const comment = this.skipLineComment(2);
                                if (comment !== undefined) {
                                    this.addComment(comment);
                                    if (this.options.attachComment) comments.push(comment);
                                }
                                break;
                            }
                        default:
                            break loop;
                    }
                    break;
                default:
                    if (isWhitespace(ch)) ++this.state.pos;
                    else if (ch === 45 && !this.inModule && this.options.annexB) {
                        const pos = this.state.pos;
                        if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                            const comment = this.skipLineComment(3);
                            if (comment !== undefined) {
                                this.addComment(comment);
                                if (this.options.attachComment) comments.push(comment);
                            }
                        } else break loop;
                    } else if (ch === 60 && !this.inModule && this.options.annexB) {
                        const pos = this.state.pos;
                        if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                            const comment = this.skipLineComment(4);
                            if (comment !== undefined) {
                                this.addComment(comment);
                                if (this.options.attachComment) comments.push(comment);
                            }
                        } else break loop;
                    } else break loop;
            }
        }
        if (comments.length > 0) {
            const end = this.state.pos;
            const commentWhitespace = {
                start: spaceStart,
                end,
                comments,
                leadingNode: null,
                trailingNode: null,
                containingNode: null
            };
            this.state.commentStack.push(commentWhitespace);
        }
    }
    finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) this.updateContext(prevType);
    }
    replaceToken(type) {
        this.state.type = type;
        this.updateContext();
    }
    readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) return;
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) throw this.raise(Errors.UnexpectedDigitAfterHash, {
            at: this.state.curPosition()
        });
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
            this.expectPlugin("recordAndTuple");
            if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
                at: this.state.curPosition()
            });
            this.state.pos += 2;
            if (next === 123) this.finishToken(7);
            else this.finishToken(1);
        } else if (isIdentifierStart(next)) {
            ++this.state.pos;
            this.finishToken(136, this.readWord1(next));
        } else if (next === 92) {
            ++this.state.pos;
            this.finishToken(136, this.readWord1());
        } else this.finishOp(27, 1);
    }
    readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
            this.readNumber(true);
            return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(21);
        } else {
            ++this.state.pos;
            this.finishToken(16);
        }
    }
    readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) this.finishOp(31, 2);
        else this.finishOp(56, 1);
    }
    readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2) return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33) return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while(!isNewLine(ch) && ++this.state.pos < this.length)ch = this.input.charCodeAt(this.state.pos);
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
    }
    readToken_mult_modulo(code) {
        let type = code === 42 ? 55 : 54;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 42 && next === 42) {
            width++;
            next = this.input.charCodeAt(this.state.pos + 2);
            type = 57;
        }
        if (next === 61 && !this.state.inType) {
            width++;
            type = code === 37 ? 33 : 30;
        }
        this.finishOp(type, width);
    }
    readToken_pipe_amp(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) this.finishOp(30, 3);
            else this.finishOp(code === 124 ? 41 : 42, 2);
            return;
        }
        if (code === 124) {
            if (next === 62) {
                this.finishOp(39, 2);
                return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 125) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                    at: this.state.curPosition()
                });
                this.state.pos += 2;
                this.finishToken(9);
                return;
            }
            if (this.hasPlugin("recordAndTuple") && next === 93) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                    at: this.state.curPosition()
                });
                this.state.pos += 2;
                this.finishToken(4);
                return;
            }
        }
        if (next === 61) {
            this.finishOp(30, 2);
            return;
        }
        this.finishOp(code === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) this.finishOp(32, 2);
        else if (next === 94 && this.hasPlugin([
            "pipelineOperator",
            {
                proposal: "hack",
                topicToken: "^^"
            }
        ])) {
            this.finishOp(37, 2);
            const lookaheadCh = this.input.codePointAt(this.state.pos);
            if (lookaheadCh === 94) this.unexpected();
        } else this.finishOp(44, 1);
    }
    readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin([
            "pipelineOperator",
            {
                proposal: "hack",
                topicToken: "@@"
            }
        ])) this.finishOp(38, 2);
        else this.finishOp(26, 1);
    }
    readToken_plus_min(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code) {
            this.finishOp(34, 2);
            return;
        }
        if (next === 61) this.finishOp(30, 2);
        else this.finishOp(53, 1);
    }
    readToken_lt() {
        const { pos  } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
            if (this.input.charCodeAt(pos + 2) === 61) {
                this.finishOp(30, 3);
                return;
            }
            this.finishOp(51, 2);
            return;
        }
        if (next === 61) {
            this.finishOp(49, 2);
            return;
        }
        this.finishOp(47, 1);
    }
    readToken_gt() {
        const { pos  } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
            const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(pos + size) === 61) {
                this.finishOp(30, size + 1);
                return;
            }
            this.finishOp(52, size);
            return;
        }
        if (next === 61) {
            this.finishOp(49, 2);
            return;
        }
        this.finishOp(48, 1);
    }
    readToken_eq_excl(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
        }
        if (code === 61 && next === 62) {
            this.state.pos += 2;
            this.finishToken(19);
            return;
        }
        this.finishOp(code === 61 ? 29 : 35, 1);
    }
    readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
            if (next2 === 61) this.finishOp(30, 3);
            else this.finishOp(40, 2);
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
            this.state.pos += 2;
            this.finishToken(18);
        } else {
            ++this.state.pos;
            this.finishToken(17);
        }
    }
    getTokenFromCode(code) {
        switch(code){
            case 46:
                this.readToken_dot();
                return;
            case 40:
                ++this.state.pos;
                this.finishToken(10);
                return;
            case 41:
                ++this.state.pos;
                this.finishToken(11);
                return;
            case 59:
                ++this.state.pos;
                this.finishToken(13);
                return;
            case 44:
                ++this.state.pos;
                this.finishToken(12);
                return;
            case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                        at: this.state.curPosition()
                    });
                    this.state.pos += 2;
                    this.finishToken(2);
                } else {
                    ++this.state.pos;
                    this.finishToken(0);
                }
                return;
            case 93:
                ++this.state.pos;
                this.finishToken(3);
                return;
            case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                        at: this.state.curPosition()
                    });
                    this.state.pos += 2;
                    this.finishToken(6);
                } else {
                    ++this.state.pos;
                    this.finishToken(5);
                }
                return;
            case 125:
                ++this.state.pos;
                this.finishToken(8);
                return;
            case 58:
                if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) this.finishOp(15, 2);
                else {
                    ++this.state.pos;
                    this.finishToken(14);
                }
                return;
            case 63:
                this.readToken_question();
                return;
            case 96:
                this.readTemplateToken();
                return;
            case 48:
                {
                    const next = this.input.charCodeAt(this.state.pos + 1);
                    if (next === 120 || next === 88) {
                        this.readRadixNumber(16);
                        return;
                    }
                    if (next === 111 || next === 79) {
                        this.readRadixNumber(8);
                        return;
                    }
                    if (next === 98 || next === 66) {
                        this.readRadixNumber(2);
                        return;
                    }
                }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
                this.readNumber(false);
                return;
            case 34:
            case 39:
                this.readString(code);
                return;
            case 47:
                this.readToken_slash();
                return;
            case 37:
            case 42:
                this.readToken_mult_modulo(code);
                return;
            case 124:
            case 38:
                this.readToken_pipe_amp(code);
                return;
            case 94:
                this.readToken_caret();
                return;
            case 43:
            case 45:
                this.readToken_plus_min(code);
                return;
            case 60:
                this.readToken_lt();
                return;
            case 62:
                this.readToken_gt();
                return;
            case 61:
            case 33:
                this.readToken_eq_excl(code);
                return;
            case 126:
                this.finishOp(36, 1);
                return;
            case 64:
                this.readToken_atSign();
                return;
            case 35:
                this.readToken_numberSign();
                return;
            case 92:
                this.readWord();
                return;
            default:
                if (isIdentifierStart(code)) {
                    this.readWord(code);
                    return;
                }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(code)
        });
    }
    finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
    }
    readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        let { pos  } = this.state;
        for(;; ++pos){
            if (pos >= this.length) throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
            });
            const ch = this.input.charCodeAt(pos);
            if (isNewLine(ch)) throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
            });
            if (escaped) escaped = false;
            else {
                if (ch === 91) inClass = true;
                else if (ch === 93 && inClass) inClass = false;
                else if (ch === 47 && !inClass) break;
                escaped = ch === 92;
            }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        const nextPos = ()=>createPositionWithColumnOffset(startLoc, pos + 2 - start);
        while(pos < this.length){
            const cp = this.codePointAtPos(pos);
            const char = String.fromCharCode(cp);
            if (VALID_REGEX_FLAGS.has(cp)) {
                if (cp === 118) {
                    if (mods.includes("u")) this.raise(Errors.IncompatibleRegExpUVFlags, {
                        at: nextPos()
                    });
                } else if (cp === 117) {
                    if (mods.includes("v")) this.raise(Errors.IncompatibleRegExpUVFlags, {
                        at: nextPos()
                    });
                }
                if (mods.includes(char)) this.raise(Errors.DuplicateRegExpFlags, {
                    at: nextPos()
                });
            } else if (isIdentifierChar(cp) || cp === 92) this.raise(Errors.MalformedRegExpFlags, {
                at: nextPos()
            });
            else break;
            ++pos;
            mods += char;
        }
        this.state.pos = pos;
        this.finishToken(135, {
            pattern: content,
            flags: mods
        });
    }
    readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const { n , pos  } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        this.state.pos = pos;
        return n;
    }
    readRadixNumber(radix) {
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) this.raise(Errors.InvalidDigit, {
            at: createPositionWithColumnOffset(startLoc, 2),
            radix
        });
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
            ++this.state.pos;
            isBigInt = true;
        } else if (next === 109) throw this.raise(Errors.InvalidDecimal, {
            at: startLoc
        });
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) throw this.raise(Errors.NumberIdentifier, {
            at: this.state.curPosition()
        });
        if (isBigInt) {
            const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
            this.finishToken(133, str);
            return;
        }
        this.finishToken(132, val);
    }
    readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let isDecimal = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) this.raise(Errors.InvalidNumber, {
            at: this.state.curPosition()
        });
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
            const integer = this.input.slice(start, this.state.pos);
            this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
                at: startLoc
            });
            if (!this.state.strict) {
                const underscorePos = integer.indexOf("_");
                if (underscorePos > 0) this.raise(Errors.ZeroDigitNumericSeparator, {
                    at: createPositionWithColumnOffset(startLoc, underscorePos)
                });
            }
            isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
            ++this.state.pos;
            this.readInt(10);
            isFloat = true;
            next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
            next = this.input.charCodeAt(++this.state.pos);
            if (next === 43 || next === 45) ++this.state.pos;
            if (this.readInt(10) === null) this.raise(Errors.InvalidOrMissingExponent, {
                at: startLoc
            });
            isFloat = true;
            hasExponent = true;
            next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
            if (isFloat || hasLeadingZero) this.raise(Errors.InvalidBigIntLiteral, {
                at: startLoc
            });
            ++this.state.pos;
            isBigInt = true;
        }
        if (next === 109) {
            this.expectPlugin("decimal", this.state.curPosition());
            if (hasExponent || hasLeadingZero) this.raise(Errors.InvalidDecimal, {
                at: startLoc
            });
            ++this.state.pos;
            isDecimal = true;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) throw this.raise(Errors.NumberIdentifier, {
            at: this.state.curPosition()
        });
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
            this.finishToken(133, str);
            return;
        }
        if (isDecimal) {
            this.finishToken(134, str);
            return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(132, val);
    }
    readCodePoint(throwOnInvalid) {
        const { code , pos  } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        this.state.pos = pos;
        return code;
    }
    readString(quote) {
        const { str , pos , curLine , lineStart  } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(131, str);
    }
    readTemplateContinuation() {
        if (!this.match(8)) this.unexpected(null, 8);
        this.state.pos--;
        this.readTemplateToken();
    }
    readTemplateToken() {
        const opening = this.input[this.state.pos];
        const { str , firstInvalidLoc , pos , curLine , lineStart  } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        if (firstInvalidLoc) this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
        if (this.input.codePointAt(pos) === 96) this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
        else {
            this.state.pos++;
            this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
        }
    }
    recordStrictModeErrors(toParseError, { at  }) {
        const index = at.index;
        if (this.state.strict && !this.state.strictErrors.has(index)) this.raise(toParseError, {
            at
        });
        else this.state.strictErrors.set(index, [
            toParseError,
            at
        ]);
    }
    readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== undefined) this.state.pos += firstCode <= 0xffff ? 1 : 2;
        while(this.state.pos < this.length){
            const ch = this.codePointAtPos(this.state.pos);
            if (isIdentifierChar(ch)) this.state.pos += ch <= 0xffff ? 1 : 2;
            else if (ch === 92) {
                this.state.containsEsc = true;
                word += this.input.slice(chunkStart, this.state.pos);
                const escStart = this.state.curPosition();
                const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(Errors.MissingUnicodeEscape, {
                        at: this.state.curPosition()
                    });
                    chunkStart = this.state.pos - 1;
                    continue;
                }
                ++this.state.pos;
                const esc = this.readCodePoint(true);
                if (esc !== null) {
                    if (!identifierCheck(esc)) this.raise(Errors.EscapedCharNotAnIdentifier, {
                        at: escStart
                    });
                    word += String.fromCodePoint(esc);
                }
                chunkStart = this.state.pos;
            } else break;
        }
        return word + this.input.slice(chunkStart, this.state.pos);
    }
    readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1.get(word);
        if (type !== undefined) this.finishToken(type, tokenLabelName(type));
        else this.finishToken(130, word);
    }
    checkKeywordEscapes() {
        const { type  } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) this.raise(Errors.InvalidEscapedReservedWord, {
            at: this.state.startLoc,
            reservedWord: tokenLabelName(type)
        });
    }
    raise(toParseError, raiseProperties) {
        const { at  } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
        const loc = at instanceof Position ? at : at.loc.start;
        const error = toParseError({
            loc,
            details
        });
        if (!this.options.errorRecovery) throw error;
        if (!this.isLookahead) this.state.errors.push(error);
        return error;
    }
    raiseOverwrite(toParseError, raiseProperties) {
        const { at  } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
        const loc = at instanceof Position ? at : at.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        for(let i = errors.length - 1; i >= 0; i--){
            const error = errors[i];
            if (error.loc.index === pos) return errors[i] = toParseError({
                loc,
                details
            });
            if (error.loc.index < pos) break;
        }
        return this.raise(toParseError, raiseProperties);
    }
    updateContext(prevType) {}
    unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, {
            expected: type ? tokenLabelName(type) : null,
            at: loc != null ? loc : this.state.startLoc
        });
    }
    expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) return true;
        throw this.raise(Errors.MissingPlugin, {
            at: loc != null ? loc : this.state.startLoc,
            missingPlugin: [
                pluginName
            ]
        });
    }
    expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name)=>this.hasPlugin(name))) throw this.raise(Errors.MissingOneOfPlugins, {
            at: this.state.startLoc,
            missingPlugin: pluginNames
        });
    }
    errorBuilder(error) {
        return (pos, lineStart, curLine)=>{
            this.raise(error, {
                at: buildPosition(pos, lineStart, curLine)
            });
        };
    }
}
class ClassScope {
    constructor(){
        this.privateNames = new Set();
        this.loneAccessors = new Map();
        this.undefinedPrivateNames = new Map();
    }
}
class ClassScopeHandler {
    constructor(parser){
        this.parser = void 0;
        this.stack = [];
        this.undefinedPrivateNames = new Map();
        this.parser = parser;
    }
    current() {
        return this.stack[this.stack.length - 1];
    }
    enter() {
        this.stack.push(new ClassScope());
    }
    exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)){
            if (current) {
                if (!current.undefinedPrivateNames.has(name)) current.undefinedPrivateNames.set(name, loc);
            } else this.parser.raise(Errors.InvalidPrivateFieldResolution, {
                at: loc,
                identifierName: name
            });
        }
    }
    declarePrivateName(name, elementType, loc) {
        const { privateNames , loneAccessors , undefinedPrivateNames  } = this.current();
        let redefined = privateNames.has(name);
        if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
            const accessor = redefined && loneAccessors.get(name);
            if (accessor) {
                const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
                const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
                const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
                const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
                redefined = oldKind === newKind || oldStatic !== newStatic;
                if (!redefined) loneAccessors.delete(name);
            } else if (!redefined) loneAccessors.set(name, elementType);
        }
        if (redefined) this.parser.raise(Errors.PrivateNameRedeclaration, {
            at: loc,
            identifierName: name
        });
        privateNames.add(name);
        undefinedPrivateNames.delete(name);
    }
    usePrivateName(name, loc) {
        let classScope;
        for (classScope of this.stack){
            if (classScope.privateNames.has(name)) return;
        }
        if (classScope) classScope.undefinedPrivateNames.set(name, loc);
        else this.parser.raise(Errors.InvalidPrivateFieldResolution, {
            at: loc,
            identifierName: name
        });
    }
}
const kExpression = 0, kMaybeArrowParameterDeclaration = 1, kMaybeAsyncArrowParameterDeclaration = 2, kParameterDeclaration = 3;
class ExpressionScope {
    constructor(type = kExpression){
        this.type = void 0;
        this.type = type;
    }
    canBeArrowParameterDeclaration() {
        return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
    }
    isCertainlyParameterDeclaration() {
        return this.type === kParameterDeclaration;
    }
}
class ArrowHeadParsingScope extends ExpressionScope {
    constructor(type){
        super(type);
        this.declarationErrors = new Map();
    }
    recordDeclarationError(ParsingErrorClass, { at  }) {
        const index = at.index;
        this.declarationErrors.set(index, [
            ParsingErrorClass,
            at
        ]);
    }
    clearDeclarationError(index) {
        this.declarationErrors.delete(index);
    }
    iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
    }
}
class ExpressionScopeHandler {
    constructor(parser){
        this.parser = void 0;
        this.stack = [
            new ExpressionScope()
        ];
        this.parser = parser;
    }
    enter(scope) {
        this.stack.push(scope);
    }
    exit() {
        this.stack.pop();
    }
    recordParameterInitializerError(toParseError, { at: node  }) {
        const origin = {
            at: node.loc.start
        };
        const { stack  } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while(!scope.isCertainlyParameterDeclaration()){
            if (scope.canBeArrowParameterDeclaration()) scope.recordDeclarationError(toParseError, origin);
            else return;
            scope = stack[--i];
        }
        this.parser.raise(toParseError, origin);
    }
    recordArrowParameterBindingError(error, { at: node  }) {
        const { stack  } = this;
        const scope = stack[stack.length - 1];
        const origin = {
            at: node.loc.start
        };
        if (scope.isCertainlyParameterDeclaration()) this.parser.raise(error, origin);
        else if (scope.canBeArrowParameterDeclaration()) scope.recordDeclarationError(error, origin);
        else return;
    }
    recordAsyncArrowParametersError({ at  }) {
        const { stack  } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while(scope.canBeArrowParameterDeclaration()){
            if (scope.type === kMaybeAsyncArrowParameterDeclaration) scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
                at
            });
            scope = stack[--i];
        }
    }
    validateAsPattern() {
        const { stack  } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration()) return;
        currentScope.iterateErrors(([toParseError, loc])=>{
            this.parser.raise(toParseError, {
                at: loc
            });
            let i = stack.length - 2;
            let scope = stack[i];
            while(scope.canBeArrowParameterDeclaration()){
                scope.clearDeclarationError(loc.index);
                scope = stack[--i];
            }
        });
    }
}
function newParameterDeclarationScope() {
    return new ExpressionScope(kParameterDeclaration);
}
function newArrowHeadScope() {
    return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
}
function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
}
function newExpressionScope() {
    return new ExpressionScope();
}
const PARAM = 0, PARAM_YIELD = 1, PARAM_AWAIT = 2, PARAM_RETURN = 4, PARAM_IN = 8;
class ProductionParameterHandler {
    constructor(){
        this.stacks = [];
    }
    enter(flags) {
        this.stacks.push(flags);
    }
    exit() {
        this.stacks.pop();
    }
    currentFlags() {
        return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
        return (this.currentFlags() & PARAM_AWAIT) > 0;
    }
    get hasYield() {
        return (this.currentFlags() & PARAM_YIELD) > 0;
    }
    get hasReturn() {
        return (this.currentFlags() & PARAM_RETURN) > 0;
    }
    get hasIn() {
        return (this.currentFlags() & PARAM_IN) > 0;
    }
}
function functionFlags(isAsync, isGenerator) {
    return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
}
class UtilParser extends Tokenizer {
    addExtra(node, key, value, enumerable = true) {
        if (!node) return;
        const extra = node.extra = node.extra || {};
        if (enumerable) extra[key] = value;
        else Object.defineProperty(extra, key, {
            enumerable,
            value
        });
    }
    isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
    }
    isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
            const nextCh = this.input.charCodeAt(nameEnd);
            return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);
        }
        return false;
    }
    isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
    }
    eatContextual(token) {
        if (this.isContextual(token)) {
            this.next();
            return true;
        }
        return false;
    }
    expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
            if (toParseError != null) throw this.raise(toParseError, {
                at: this.state.startLoc
            });
            this.unexpected(null, token);
        }
    }
    canInsertSemicolon() {
        return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
        return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
    }
    isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
        this.raise(Errors.MissingSemicolon, {
            at: this.state.lastTokEndLoc
        });
    }
    expect(type, loc) {
        this.eat(type) || this.unexpected(loc, type);
    }
    tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
            node: null
        };
        try {
            const node = fn((node = null)=>{
                abortSignal.node = node;
                throw abortSignal;
            });
            if (this.state.errors.length > oldState.errors.length) {
                const failState = this.state;
                this.state = oldState;
                this.state.tokensLength = failState.tokensLength;
                return {
                    node,
                    error: failState.errors[oldState.errors.length],
                    thrown: false,
                    aborted: false,
                    failState
                };
            }
            return {
                node,
                error: null,
                thrown: false,
                aborted: false,
                failState: null
            };
        } catch (error) {
            const failState = this.state;
            this.state = oldState;
            if (error instanceof SyntaxError) return {
                node: null,
                error,
                thrown: true,
                aborted: false,
                failState
            };
            if (error === abortSignal) return {
                node: abortSignal.node,
                error: null,
                thrown: false,
                aborted: true,
                failState
            };
            throw error;
        }
    }
    checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors) return false;
        const { shorthandAssignLoc , doubleProtoLoc , privateKeyLoc , optionalParametersLoc  } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
        if (!andThrow) return hasErrors;
        if (shorthandAssignLoc != null) this.raise(Errors.InvalidCoverInitializedName, {
            at: shorthandAssignLoc
        });
        if (doubleProtoLoc != null) this.raise(Errors.DuplicateProto, {
            at: doubleProtoLoc
        });
        if (privateKeyLoc != null) this.raise(Errors.UnexpectedPrivateField, {
            at: privateKeyLoc
        });
        if (optionalParametersLoc != null) this.unexpected(optionalParametersLoc);
    }
    isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
    }
    isPrivateName(node) {
        return node.type === "PrivateName";
    }
    getPrivateNameSV(node) {
        return node.id.name;
    }
    hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    }
    isObjectProperty(node) {
        return node.type === "ObjectProperty";
    }
    isObjectMethod(node) {
        return node.type === "ObjectMethod";
    }
    initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler = this.getScopeHandler();
        this.scope = new ScopeHandler(this, inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this);
        return ()=>{
            this.state.labels = oldLabels;
            this.exportedIdentifiers = oldExportedIdentifiers;
            this.inModule = oldInModule;
            this.scope = oldScope;
            this.prodParam = oldProdParam;
            this.classScope = oldClassScope;
            this.expressionScope = oldExpressionScope;
        };
    }
    enterInitialScopes() {
        let paramFlags = PARAM;
        if (this.inModule) paramFlags |= PARAM_AWAIT;
        this.scope.enter(SCOPE_PROGRAM);
        this.prodParam.enter(paramFlags);
    }
    checkDestructuringPrivate(refExpressionErrors) {
        const { privateKeyLoc  } = refExpressionErrors;
        if (privateKeyLoc !== null) this.expectPlugin("destructuringPrivate", privateKeyLoc);
    }
}
class ExpressionErrors {
    constructor(){
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
    }
}
class Node {
    constructor(parser, pos, loc){
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if (parser != null && parser.options.ranges) this.range = [
            pos,
            0
        ];
        if (parser != null && parser.filename) this.loc.filename = parser.filename;
    }
}
const NodePrototype = Node.prototype;
NodePrototype.__clone = function() {
    const newNode = new Node(undefined, this.start, this.loc.start);
    const keys = Object.keys(this);
    for(let i = 0, length = keys.length; i < length; i++){
        const key = keys[i];
        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") newNode[key] = this[key];
    }
    return newNode;
};
function clonePlaceholder(node) {
    return cloneIdentifier(node);
}
function cloneIdentifier(node) {
    const { type , start , end , loc , range , extra , name  } = node;
    const cloned = Object.create(NodePrototype);
    cloned.type = type;
    cloned.start = start;
    cloned.end = end;
    cloned.loc = loc;
    cloned.range = range;
    cloned.extra = extra;
    cloned.name = name;
    if (type === "Placeholder") cloned.expectedNode = node.expectedNode;
    return cloned;
}
function cloneStringLiteral(node) {
    const { type , start , end , loc , range , extra  } = node;
    if (type === "Placeholder") return clonePlaceholder(node);
    const cloned = Object.create(NodePrototype);
    cloned.type = type;
    cloned.start = start;
    cloned.end = end;
    cloned.loc = loc;
    cloned.range = range;
    if (node.raw !== undefined) cloned.raw = node.raw;
    else cloned.extra = extra;
    cloned.value = node.value;
    return cloned;
}
class NodeUtils extends UtilParser {
    startNode() {
        return new Node(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(loc) {
        return new Node(this, loc.index, loc);
    }
    startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
    }
    finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
    }
    finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.options.ranges) node.range[1] = endLoc.index;
        if (this.options.attachComment) this.processComment(node);
        return node;
    }
    resetStartLocation(node, startLoc) {
        node.start = startLoc.index;
        node.loc.start = startLoc;
        if (this.options.ranges) node.range[0] = startLoc.index;
    }
    resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.options.ranges) node.range[1] = endLoc.index;
    }
    resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
    }
}
const reservedTypes = new Set([
    "_",
    "any",
    "bool",
    "boolean",
    "empty",
    "extends",
    "false",
    "interface",
    "mixed",
    "null",
    "number",
    "static",
    "string",
    "true",
    "typeof",
    "void"
]);
const FlowErrors = ParseErrorEnum`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: ({ reservedType  })=>`Cannot overwrite reserved type ${reservedType}.`,
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: ({ memberName , enumName  })=>`Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
    EnumDuplicateMemberName: ({ memberName , enumName  })=>`Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
    EnumInconsistentMemberValues: ({ enumName  })=>`Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
    EnumInvalidExplicitType: ({ invalidEnumType , enumName  })=>`Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidExplicitTypeUnknownSupplied: ({ enumName  })=>`Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerPrimaryType: ({ enumName , memberName , explicitType  })=>`Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
    EnumInvalidMemberInitializerSymbolType: ({ enumName , memberName  })=>`Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
    EnumInvalidMemberInitializerUnknownType: ({ enumName , memberName  })=>`The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
    EnumInvalidMemberName: ({ enumName , memberName , suggestion  })=>`Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
    EnumNumberMemberNotInitialized: ({ enumName , memberName  })=>`Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
    EnumStringMemberInconsistentlyInitailized: ({ enumName  })=>`String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
        reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: ({ reservedType  })=>`Unexpected reserved type ${reservedType}.`,
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: ({ unsupportedExportKind , suggestion  })=>`\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
});
function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
}
function hasTypeImportKind(node) {
    return node.importKind === "type" || node.importKind === "typeof";
}
const exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
};
function partition(list, test) {
    const list1 = [];
    const list2 = [];
    for(let i = 0; i < list.length; i++)(test(list[i], i, list) ? list1 : list2).push(list[i]);
    return [
        list1,
        list2
    ];
}
const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
var flow = (superClass)=>class FlowParserMixin extends superClass {
        constructor(...args){
            super(...args);
            this.flowPragma = undefined;
        }
        getScopeHandler() {
            return FlowScopeHandler;
        }
        shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
        shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
        }
        finishToken(type, val) {
            if (type !== 131 && type !== 13 && type !== 28) {
                if (this.flowPragma === undefined) this.flowPragma = null;
            }
            super.finishToken(type, val);
        }
        addComment(comment) {
            if (this.flowPragma === undefined) {
                const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
                if (!matches) ;
                else if (matches[1] === "flow") this.flowPragma = "flow";
                else if (matches[1] === "noflow") this.flowPragma = "noflow";
                else throw new Error("Unexpected flow pragma");
            }
            super.addComment(comment);
        }
        flowParseTypeInitialiser(tok) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            this.expect(tok || 14);
            const type = this.flowParseType();
            this.state.inType = oldInType;
            return type;
        }
        flowParsePredicate() {
            const node = this.startNode();
            const moduloLoc = this.state.startLoc;
            this.next();
            this.expectContextual(108);
            if (this.state.lastTokStart > moduloLoc.index + 1) this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
                at: moduloLoc
            });
            if (this.eat(10)) {
                node.value = super.parseExpression();
                this.expect(11);
                return this.finishNode(node, "DeclaredPredicate");
            } else return this.finishNode(node, "InferredPredicate");
        }
        flowParseTypeAndPredicateInitialiser() {
            const oldInType = this.state.inType;
            this.state.inType = true;
            this.expect(14);
            let type = null;
            let predicate = null;
            if (this.match(54)) {
                this.state.inType = oldInType;
                predicate = this.flowParsePredicate();
            } else {
                type = this.flowParseType();
                this.state.inType = oldInType;
                if (this.match(54)) predicate = this.flowParsePredicate();
            }
            return [
                type,
                predicate
            ];
        }
        flowParseDeclareClass(node) {
            this.next();
            this.flowParseInterfaceish(node, true);
            return this.finishNode(node, "DeclareClass");
        }
        flowParseDeclareFunction(node) {
            this.next();
            const id = node.id = this.parseIdentifier();
            const typeNode = this.startNode();
            const typeContainer = this.startNode();
            if (this.match(47)) typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
            else typeNode.typeParameters = null;
            this.expect(10);
            const tmp = this.flowParseFunctionTypeParams();
            typeNode.params = tmp.params;
            typeNode.rest = tmp.rest;
            typeNode.this = tmp._this;
            this.expect(11);
            [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
            id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
            this.resetEndLocation(id);
            this.semicolon();
            this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);
            return this.finishNode(node, "DeclareFunction");
        }
        flowParseDeclare(node, insideModule) {
            if (this.match(80)) return this.flowParseDeclareClass(node);
            else if (this.match(68)) return this.flowParseDeclareFunction(node);
            else if (this.match(74)) return this.flowParseDeclareVariable(node);
            else if (this.eatContextual(125)) {
                if (this.match(16)) return this.flowParseDeclareModuleExports(node);
                else {
                    if (insideModule) this.raise(FlowErrors.NestedDeclareModule, {
                        at: this.state.lastTokStartLoc
                    });
                    return this.flowParseDeclareModule(node);
                }
            } else if (this.isContextual(128)) return this.flowParseDeclareTypeAlias(node);
            else if (this.isContextual(129)) return this.flowParseDeclareOpaqueType(node);
            else if (this.isContextual(127)) return this.flowParseDeclareInterface(node);
            else if (this.match(82)) return this.flowParseDeclareExportDeclaration(node, insideModule);
            else this.unexpected();
        }
        flowParseDeclareVariable(node) {
            this.next();
            node.id = this.flowParseTypeAnnotatableIdentifier(true);
            this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
            this.semicolon();
            return this.finishNode(node, "DeclareVariable");
        }
        flowParseDeclareModule(node) {
            this.scope.enter(SCOPE_OTHER);
            if (this.match(131)) node.id = super.parseExprAtom();
            else node.id = this.parseIdentifier();
            const bodyNode = node.body = this.startNode();
            const body = bodyNode.body = [];
            this.expect(5);
            while(!this.match(8)){
                let bodyNode = this.startNode();
                if (this.match(83)) {
                    this.next();
                    if (!this.isContextual(128) && !this.match(87)) this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                        at: this.state.lastTokStartLoc
                    });
                    super.parseImport(bodyNode);
                } else {
                    this.expectContextual(123, FlowErrors.UnsupportedStatementInDeclareModule);
                    bodyNode = this.flowParseDeclare(bodyNode, true);
                }
                body.push(bodyNode);
            }
            this.scope.exit();
            this.expect(8);
            this.finishNode(bodyNode, "BlockStatement");
            let kind = null;
            let hasModuleExport = false;
            body.forEach((bodyElement)=>{
                if (isEsModuleType(bodyElement)) {
                    if (kind === "CommonJS") this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                        at: bodyElement
                    });
                    kind = "ES";
                } else if (bodyElement.type === "DeclareModuleExports") {
                    if (hasModuleExport) this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                        at: bodyElement
                    });
                    if (kind === "ES") this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                        at: bodyElement
                    });
                    kind = "CommonJS";
                    hasModuleExport = true;
                }
            });
            node.kind = kind || "CommonJS";
            return this.finishNode(node, "DeclareModule");
        }
        flowParseDeclareExportDeclaration(node, insideModule) {
            this.expect(82);
            if (this.eat(65)) {
                if (this.match(68) || this.match(80)) node.declaration = this.flowParseDeclare(this.startNode());
                else {
                    node.declaration = this.flowParseType();
                    this.semicolon();
                }
                node.default = true;
                return this.finishNode(node, "DeclareExportDeclaration");
            } else {
                if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !insideModule) {
                    const label = this.state.value;
                    throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
                        at: this.state.startLoc,
                        unsupportedExportKind: label,
                        suggestion: exportSuggestions[label]
                    });
                }
                if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129)) {
                    node.declaration = this.flowParseDeclare(this.startNode());
                    node.default = false;
                    return this.finishNode(node, "DeclareExportDeclaration");
                } else if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129)) {
                    node = this.parseExport(node, null);
                    if (node.type === "ExportNamedDeclaration") {
                        node.type = "ExportDeclaration";
                        node.default = false;
                        delete node.exportKind;
                    }
                    node.type = "Declare" + node.type;
                    return node;
                }
            }
            this.unexpected();
        }
        flowParseDeclareModuleExports(node) {
            this.next();
            this.expectContextual(109);
            node.typeAnnotation = this.flowParseTypeAnnotation();
            this.semicolon();
            return this.finishNode(node, "DeclareModuleExports");
        }
        flowParseDeclareTypeAlias(node) {
            this.next();
            const finished = this.flowParseTypeAlias(node);
            finished.type = "DeclareTypeAlias";
            return finished;
        }
        flowParseDeclareOpaqueType(node) {
            this.next();
            const finished = this.flowParseOpaqueType(node, true);
            finished.type = "DeclareOpaqueType";
            return finished;
        }
        flowParseDeclareInterface(node) {
            this.next();
            this.flowParseInterfaceish(node, false);
            return this.finishNode(node, "DeclareInterface");
        }
        flowParseInterfaceish(node, isClass) {
            node.id = this.flowParseRestrictedIdentifier(!isClass, true);
            this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);
            if (this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
            else node.typeParameters = null;
            node.extends = [];
            if (this.eat(81)) do node.extends.push(this.flowParseInterfaceExtends());
            while (!isClass && this.eat(12));
            if (isClass) {
                node.implements = [];
                node.mixins = [];
                if (this.eatContextual(115)) do node.mixins.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
                if (this.eatContextual(111)) do node.implements.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
            }
            node.body = this.flowParseObjectType({
                allowStatic: isClass,
                allowExact: false,
                allowSpread: false,
                allowProto: isClass,
                allowInexact: false
            });
        }
        flowParseInterfaceExtends() {
            const node = this.startNode();
            node.id = this.flowParseQualifiedTypeIdentifier();
            if (this.match(47)) node.typeParameters = this.flowParseTypeParameterInstantiation();
            else node.typeParameters = null;
            return this.finishNode(node, "InterfaceExtends");
        }
        flowParseInterface(node) {
            this.flowParseInterfaceish(node, false);
            return this.finishNode(node, "InterfaceDeclaration");
        }
        checkNotUnderscore(word) {
            if (word === "_") this.raise(FlowErrors.UnexpectedReservedUnderscore, {
                at: this.state.startLoc
            });
        }
        checkReservedType(word, startLoc, declaration) {
            if (!reservedTypes.has(word)) return;
            this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
                at: startLoc,
                reservedType: word
            });
        }
        flowParseRestrictedIdentifier(liberal, declaration) {
            this.checkReservedType(this.state.value, this.state.startLoc, declaration);
            return this.parseIdentifier(liberal);
        }
        flowParseTypeAlias(node) {
            node.id = this.flowParseRestrictedIdentifier(false, true);
            this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
            if (this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
            else node.typeParameters = null;
            node.right = this.flowParseTypeInitialiser(29);
            this.semicolon();
            return this.finishNode(node, "TypeAlias");
        }
        flowParseOpaqueType(node, declare) {
            this.expectContextual(128);
            node.id = this.flowParseRestrictedIdentifier(true, true);
            this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
            if (this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
            else node.typeParameters = null;
            node.supertype = null;
            if (this.match(14)) node.supertype = this.flowParseTypeInitialiser(14);
            node.impltype = null;
            if (!declare) node.impltype = this.flowParseTypeInitialiser(29);
            this.semicolon();
            return this.finishNode(node, "OpaqueType");
        }
        flowParseTypeParameter(requireDefault = false) {
            const nodeStartLoc = this.state.startLoc;
            const node = this.startNode();
            const variance = this.flowParseVariance();
            const ident = this.flowParseTypeAnnotatableIdentifier();
            node.name = ident.name;
            node.variance = variance;
            node.bound = ident.typeAnnotation;
            if (this.match(29)) {
                this.eat(29);
                node.default = this.flowParseType();
            } else if (requireDefault) this.raise(FlowErrors.MissingTypeParamDefault, {
                at: nodeStartLoc
            });
            return this.finishNode(node, "TypeParameter");
        }
        flowParseTypeParameterDeclaration() {
            const oldInType = this.state.inType;
            const node = this.startNode();
            node.params = [];
            this.state.inType = true;
            if (this.match(47) || this.match(140)) this.next();
            else this.unexpected();
            let defaultRequired = false;
            do {
                const typeParameter = this.flowParseTypeParameter(defaultRequired);
                node.params.push(typeParameter);
                if (typeParameter.default) defaultRequired = true;
                if (!this.match(48)) this.expect(12);
            }while (!this.match(48));
            this.expect(48);
            this.state.inType = oldInType;
            return this.finishNode(node, "TypeParameterDeclaration");
        }
        flowParseTypeParameterInstantiation() {
            const node = this.startNode();
            const oldInType = this.state.inType;
            node.params = [];
            this.state.inType = true;
            this.expect(47);
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = false;
            while(!this.match(48)){
                node.params.push(this.flowParseType());
                if (!this.match(48)) this.expect(12);
            }
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            this.expect(48);
            this.state.inType = oldInType;
            return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseTypeParameterInstantiationCallOrNew() {
            const node = this.startNode();
            const oldInType = this.state.inType;
            node.params = [];
            this.state.inType = true;
            this.expect(47);
            while(!this.match(48)){
                node.params.push(this.flowParseTypeOrImplicitInstantiation());
                if (!this.match(48)) this.expect(12);
            }
            this.expect(48);
            this.state.inType = oldInType;
            return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseInterfaceType() {
            const node = this.startNode();
            this.expectContextual(127);
            node.extends = [];
            if (this.eat(81)) do node.extends.push(this.flowParseInterfaceExtends());
            while (this.eat(12));
            node.body = this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: false,
                allowProto: false,
                allowInexact: false
            });
            return this.finishNode(node, "InterfaceTypeAnnotation");
        }
        flowParseObjectPropertyKey() {
            return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
        }
        flowParseObjectTypeIndexer(node, isStatic, variance) {
            node.static = isStatic;
            if (this.lookahead().type === 14) {
                node.id = this.flowParseObjectPropertyKey();
                node.key = this.flowParseTypeInitialiser();
            } else {
                node.id = null;
                node.key = this.flowParseType();
            }
            this.expect(3);
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
            return this.finishNode(node, "ObjectTypeIndexer");
        }
        flowParseObjectTypeInternalSlot(node, isStatic) {
            node.static = isStatic;
            node.id = this.flowParseObjectPropertyKey();
            this.expect(3);
            this.expect(3);
            if (this.match(47) || this.match(10)) {
                node.method = true;
                node.optional = false;
                node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
            } else {
                node.method = false;
                if (this.eat(17)) node.optional = true;
                node.value = this.flowParseTypeInitialiser();
            }
            return this.finishNode(node, "ObjectTypeInternalSlot");
        }
        flowParseObjectTypeMethodish(node) {
            node.params = [];
            node.rest = null;
            node.typeParameters = null;
            node.this = null;
            if (this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            if (this.match(78)) {
                node.this = this.flowParseFunctionTypeParam(true);
                node.this.name = null;
                if (!this.match(11)) this.expect(12);
            }
            while(!this.match(11) && !this.match(21)){
                node.params.push(this.flowParseFunctionTypeParam(false));
                if (!this.match(11)) this.expect(12);
            }
            if (this.eat(21)) node.rest = this.flowParseFunctionTypeParam(false);
            this.expect(11);
            node.returnType = this.flowParseTypeInitialiser();
            return this.finishNode(node, "FunctionTypeAnnotation");
        }
        flowParseObjectTypeCallProperty(node, isStatic) {
            const valueNode = this.startNode();
            node.static = isStatic;
            node.value = this.flowParseObjectTypeMethodish(valueNode);
            return this.finishNode(node, "ObjectTypeCallProperty");
        }
        flowParseObjectType({ allowStatic , allowExact , allowSpread , allowProto , allowInexact  }) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            const nodeStart = this.startNode();
            nodeStart.callProperties = [];
            nodeStart.properties = [];
            nodeStart.indexers = [];
            nodeStart.internalSlots = [];
            let endDelim;
            let exact;
            let inexact = false;
            if (allowExact && this.match(6)) {
                this.expect(6);
                endDelim = 9;
                exact = true;
            } else {
                this.expect(5);
                endDelim = 8;
                exact = false;
            }
            nodeStart.exact = exact;
            while(!this.match(endDelim)){
                let isStatic = false;
                let protoStartLoc = null;
                let inexactStartLoc = null;
                const node = this.startNode();
                if (allowProto && this.isContextual(116)) {
                    const lookahead = this.lookahead();
                    if (lookahead.type !== 14 && lookahead.type !== 17) {
                        this.next();
                        protoStartLoc = this.state.startLoc;
                        allowStatic = false;
                    }
                }
                if (allowStatic && this.isContextual(104)) {
                    const lookahead = this.lookahead();
                    if (lookahead.type !== 14 && lookahead.type !== 17) {
                        this.next();
                        isStatic = true;
                    }
                }
                const variance = this.flowParseVariance();
                if (this.eat(0)) {
                    if (protoStartLoc != null) this.unexpected(protoStartLoc);
                    if (this.eat(0)) {
                        if (variance) this.unexpected(variance.loc.start);
                        nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
                    } else nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
                } else if (this.match(10) || this.match(47)) {
                    if (protoStartLoc != null) this.unexpected(protoStartLoc);
                    if (variance) this.unexpected(variance.loc.start);
                    nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
                } else {
                    let kind = "init";
                    if (this.isContextual(98) || this.isContextual(103)) {
                        const lookahead = this.lookahead();
                        if (tokenIsLiteralPropertyName(lookahead.type)) {
                            kind = this.state.value;
                            this.next();
                        }
                    }
                    const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
                    if (propOrInexact === null) {
                        inexact = true;
                        inexactStartLoc = this.state.lastTokStartLoc;
                    } else nodeStart.properties.push(propOrInexact);
                }
                this.flowObjectTypeSemicolon();
                if (inexactStartLoc && !this.match(8) && !this.match(9)) this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
                    at: inexactStartLoc
                });
            }
            this.expect(endDelim);
            if (allowSpread) nodeStart.inexact = inexact;
            const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
            this.state.inType = oldInType;
            return out;
        }
        flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
            if (this.eat(21)) {
                const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
                if (isInexactToken) {
                    if (!allowSpread) this.raise(FlowErrors.InexactInsideNonObject, {
                        at: this.state.lastTokStartLoc
                    });
                    else if (!allowInexact) this.raise(FlowErrors.InexactInsideExact, {
                        at: this.state.lastTokStartLoc
                    });
                    if (variance) this.raise(FlowErrors.InexactVariance, {
                        at: variance
                    });
                    return null;
                }
                if (!allowSpread) this.raise(FlowErrors.UnexpectedSpreadType, {
                    at: this.state.lastTokStartLoc
                });
                if (protoStartLoc != null) this.unexpected(protoStartLoc);
                if (variance) this.raise(FlowErrors.SpreadVariance, {
                    at: variance
                });
                node.argument = this.flowParseType();
                return this.finishNode(node, "ObjectTypeSpreadProperty");
            } else {
                node.key = this.flowParseObjectPropertyKey();
                node.static = isStatic;
                node.proto = protoStartLoc != null;
                node.kind = kind;
                let optional = false;
                if (this.match(47) || this.match(10)) {
                    node.method = true;
                    if (protoStartLoc != null) this.unexpected(protoStartLoc);
                    if (variance) this.unexpected(variance.loc.start);
                    node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
                    if (kind === "get" || kind === "set") this.flowCheckGetterSetterParams(node);
                    if (!allowSpread && node.key.name === "constructor" && node.value.this) this.raise(FlowErrors.ThisParamBannedInConstructor, {
                        at: node.value.this
                    });
                } else {
                    if (kind !== "init") this.unexpected();
                    node.method = false;
                    if (this.eat(17)) optional = true;
                    node.value = this.flowParseTypeInitialiser();
                    node.variance = variance;
                }
                node.optional = optional;
                return this.finishNode(node, "ObjectTypeProperty");
            }
        }
        flowCheckGetterSetterParams(property) {
            const paramCount = property.kind === "get" ? 0 : 1;
            const length = property.value.params.length + (property.value.rest ? 1 : 0);
            if (property.value.this) this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
                at: property.value.this
            });
            if (length !== paramCount) this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
                at: property
            });
            if (property.kind === "set" && property.value.rest) this.raise(Errors.BadSetterRestParameter, {
                at: property
            });
        }
        flowObjectTypeSemicolon() {
            if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) this.unexpected();
        }
        flowParseQualifiedTypeIdentifier(startLoc, id) {
            var _startLoc;
            (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
            let node = id || this.flowParseRestrictedIdentifier(true);
            while(this.eat(16)){
                const node2 = this.startNodeAt(startLoc);
                node2.qualification = node;
                node2.id = this.flowParseRestrictedIdentifier(true);
                node = this.finishNode(node2, "QualifiedTypeIdentifier");
            }
            return node;
        }
        flowParseGenericType(startLoc, id) {
            const node = this.startNodeAt(startLoc);
            node.typeParameters = null;
            node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
            if (this.match(47)) node.typeParameters = this.flowParseTypeParameterInstantiation();
            return this.finishNode(node, "GenericTypeAnnotation");
        }
        flowParseTypeofType() {
            const node = this.startNode();
            this.expect(87);
            node.argument = this.flowParsePrimaryType();
            return this.finishNode(node, "TypeofTypeAnnotation");
        }
        flowParseTupleType() {
            const node = this.startNode();
            node.types = [];
            this.expect(0);
            while(this.state.pos < this.length && !this.match(3)){
                node.types.push(this.flowParseType());
                if (this.match(3)) break;
                this.expect(12);
            }
            this.expect(3);
            return this.finishNode(node, "TupleTypeAnnotation");
        }
        flowParseFunctionTypeParam(first) {
            let name = null;
            let optional = false;
            let typeAnnotation = null;
            const node = this.startNode();
            const lh = this.lookahead();
            const isThis = this.state.type === 78;
            if (lh.type === 14 || lh.type === 17) {
                if (isThis && !first) this.raise(FlowErrors.ThisParamMustBeFirst, {
                    at: node
                });
                name = this.parseIdentifier(isThis);
                if (this.eat(17)) {
                    optional = true;
                    if (isThis) this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                        at: node
                    });
                }
                typeAnnotation = this.flowParseTypeInitialiser();
            } else typeAnnotation = this.flowParseType();
            node.name = name;
            node.optional = optional;
            node.typeAnnotation = typeAnnotation;
            return this.finishNode(node, "FunctionTypeParam");
        }
        reinterpretTypeAsFunctionTypeParam(type) {
            const node = this.startNodeAt(type.loc.start);
            node.name = null;
            node.optional = false;
            node.typeAnnotation = type;
            return this.finishNode(node, "FunctionTypeParam");
        }
        flowParseFunctionTypeParams(params = []) {
            let rest = null;
            let _this = null;
            if (this.match(78)) {
                _this = this.flowParseFunctionTypeParam(true);
                _this.name = null;
                if (!this.match(11)) this.expect(12);
            }
            while(!this.match(11) && !this.match(21)){
                params.push(this.flowParseFunctionTypeParam(false));
                if (!this.match(11)) this.expect(12);
            }
            if (this.eat(21)) rest = this.flowParseFunctionTypeParam(false);
            return {
                params,
                rest,
                _this
            };
        }
        flowIdentToTypeAnnotation(startLoc, node, id) {
            switch(id.name){
                case "any":
                    return this.finishNode(node, "AnyTypeAnnotation");
                case "bool":
                case "boolean":
                    return this.finishNode(node, "BooleanTypeAnnotation");
                case "mixed":
                    return this.finishNode(node, "MixedTypeAnnotation");
                case "empty":
                    return this.finishNode(node, "EmptyTypeAnnotation");
                case "number":
                    return this.finishNode(node, "NumberTypeAnnotation");
                case "string":
                    return this.finishNode(node, "StringTypeAnnotation");
                case "symbol":
                    return this.finishNode(node, "SymbolTypeAnnotation");
                default:
                    this.checkNotUnderscore(id.name);
                    return this.flowParseGenericType(startLoc, id);
            }
        }
        flowParsePrimaryType() {
            const startLoc = this.state.startLoc;
            const node = this.startNode();
            let tmp;
            let type;
            let isGroupedType = false;
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            switch(this.state.type){
                case 5:
                    return this.flowParseObjectType({
                        allowStatic: false,
                        allowExact: false,
                        allowSpread: true,
                        allowProto: false,
                        allowInexact: true
                    });
                case 6:
                    return this.flowParseObjectType({
                        allowStatic: false,
                        allowExact: true,
                        allowSpread: true,
                        allowProto: false,
                        allowInexact: false
                    });
                case 0:
                    this.state.noAnonFunctionType = false;
                    type = this.flowParseTupleType();
                    this.state.noAnonFunctionType = oldNoAnonFunctionType;
                    return type;
                case 47:
                    node.typeParameters = this.flowParseTypeParameterDeclaration();
                    this.expect(10);
                    tmp = this.flowParseFunctionTypeParams();
                    node.params = tmp.params;
                    node.rest = tmp.rest;
                    node.this = tmp._this;
                    this.expect(11);
                    this.expect(19);
                    node.returnType = this.flowParseType();
                    return this.finishNode(node, "FunctionTypeAnnotation");
                case 10:
                    this.next();
                    if (!this.match(11) && !this.match(21)) {
                        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                            const token = this.lookahead().type;
                            isGroupedType = token !== 17 && token !== 14;
                        } else isGroupedType = true;
                    }
                    if (isGroupedType) {
                        this.state.noAnonFunctionType = false;
                        type = this.flowParseType();
                        this.state.noAnonFunctionType = oldNoAnonFunctionType;
                        if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                            this.expect(11);
                            return type;
                        } else this.eat(12);
                    }
                    if (type) tmp = this.flowParseFunctionTypeParams([
                        this.reinterpretTypeAsFunctionTypeParam(type)
                    ]);
                    else tmp = this.flowParseFunctionTypeParams();
                    node.params = tmp.params;
                    node.rest = tmp.rest;
                    node.this = tmp._this;
                    this.expect(11);
                    this.expect(19);
                    node.returnType = this.flowParseType();
                    node.typeParameters = null;
                    return this.finishNode(node, "FunctionTypeAnnotation");
                case 131:
                    return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                case 85:
                case 86:
                    node.value = this.match(85);
                    this.next();
                    return this.finishNode(node, "BooleanLiteralTypeAnnotation");
                case 53:
                    if (this.state.value === "-") {
                        this.next();
                        if (this.match(132)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                        if (this.match(133)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                        throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                            at: this.state.startLoc
                        });
                    }
                    this.unexpected();
                    return;
                case 132:
                    return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                case 133:
                    return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                case 88:
                    this.next();
                    return this.finishNode(node, "VoidTypeAnnotation");
                case 84:
                    this.next();
                    return this.finishNode(node, "NullLiteralTypeAnnotation");
                case 78:
                    this.next();
                    return this.finishNode(node, "ThisTypeAnnotation");
                case 55:
                    this.next();
                    return this.finishNode(node, "ExistsTypeAnnotation");
                case 87:
                    return this.flowParseTypeofType();
                default:
                    if (tokenIsKeyword(this.state.type)) {
                        const label = tokenLabelName(this.state.type);
                        this.next();
                        return super.createIdentifier(node, label);
                    } else if (tokenIsIdentifier(this.state.type)) {
                        if (this.isContextual(127)) return this.flowParseInterfaceType();
                        return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
                    }
            }
            this.unexpected();
        }
        flowParsePostfixType() {
            const startLoc = this.state.startLoc;
            let type = this.flowParsePrimaryType();
            let seenOptionalIndexedAccess = false;
            while((this.match(0) || this.match(18)) && !this.canInsertSemicolon()){
                const node = this.startNodeAt(startLoc);
                const optional = this.eat(18);
                seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
                this.expect(0);
                if (!optional && this.match(3)) {
                    node.elementType = type;
                    this.next();
                    type = this.finishNode(node, "ArrayTypeAnnotation");
                } else {
                    node.objectType = type;
                    node.indexType = this.flowParseType();
                    this.expect(3);
                    if (seenOptionalIndexedAccess) {
                        node.optional = optional;
                        type = this.finishNode(node, "OptionalIndexedAccessType");
                    } else type = this.finishNode(node, "IndexedAccessType");
                }
            }
            return type;
        }
        flowParsePrefixType() {
            const node = this.startNode();
            if (this.eat(17)) {
                node.typeAnnotation = this.flowParsePrefixType();
                return this.finishNode(node, "NullableTypeAnnotation");
            } else return this.flowParsePostfixType();
        }
        flowParseAnonFunctionWithoutParens() {
            const param = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
                const node = this.startNodeAt(param.loc.start);
                node.params = [
                    this.reinterpretTypeAsFunctionTypeParam(param)
                ];
                node.rest = null;
                node.this = null;
                node.returnType = this.flowParseType();
                node.typeParameters = null;
                return this.finishNode(node, "FunctionTypeAnnotation");
            }
            return param;
        }
        flowParseIntersectionType() {
            const node = this.startNode();
            this.eat(45);
            const type = this.flowParseAnonFunctionWithoutParens();
            node.types = [
                type
            ];
            while(this.eat(45))node.types.push(this.flowParseAnonFunctionWithoutParens());
            return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        }
        flowParseUnionType() {
            const node = this.startNode();
            this.eat(43);
            const type = this.flowParseIntersectionType();
            node.types = [
                type
            ];
            while(this.eat(43))node.types.push(this.flowParseIntersectionType());
            return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        }
        flowParseType() {
            const oldInType = this.state.inType;
            this.state.inType = true;
            const type = this.flowParseUnionType();
            this.state.inType = oldInType;
            return type;
        }
        flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 130 && this.state.value === "_") {
                const startLoc = this.state.startLoc;
                const node = this.parseIdentifier();
                return this.flowParseGenericType(startLoc, node);
            } else return this.flowParseType();
        }
        flowParseTypeAnnotation() {
            const node = this.startNode();
            node.typeAnnotation = this.flowParseTypeInitialiser();
            return this.finishNode(node, "TypeAnnotation");
        }
        flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
            const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            if (this.match(14)) {
                ident.typeAnnotation = this.flowParseTypeAnnotation();
                this.resetEndLocation(ident);
            }
            return ident;
        }
        typeCastToParameter(node) {
            node.expression.typeAnnotation = node.typeAnnotation;
            this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
            return node.expression;
        }
        flowParseVariance() {
            let variance = null;
            if (this.match(53)) {
                variance = this.startNode();
                if (this.state.value === "+") variance.kind = "plus";
                else variance.kind = "minus";
                this.next();
                return this.finishNode(variance, "Variance");
            }
            return variance;
        }
        parseFunctionBody(node, allowExpressionBody, isMethod = false) {
            if (allowExpressionBody) {
                this.forwardNoArrowParamsConversionAt(node, ()=>super.parseFunctionBody(node, true, isMethod));
                return;
            }
            super.parseFunctionBody(node, false, isMethod);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
            if (this.match(14)) {
                const typeNode = this.startNode();
                [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
                node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        parseStatementLike(flags) {
            if (this.state.strict && this.isContextual(127)) {
                const lookahead = this.lookahead();
                if (tokenIsKeywordOrIdentifier(lookahead.type)) {
                    const node = this.startNode();
                    this.next();
                    return this.flowParseInterface(node);
                }
            } else if (this.shouldParseEnums() && this.isContextual(124)) {
                const node = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(node);
            }
            const stmt = super.parseStatementLike(flags);
            if (this.flowPragma === undefined && !this.isValidDirective(stmt)) this.flowPragma = null;
            return stmt;
        }
        parseExpressionStatement(node, expr, decorators) {
            if (expr.type === "Identifier") {
                if (expr.name === "declare") {
                    if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(node);
                } else if (tokenIsIdentifier(this.state.type)) {
                    if (expr.name === "interface") return this.flowParseInterface(node);
                    else if (expr.name === "type") return this.flowParseTypeAlias(node);
                    else if (expr.name === "opaque") return this.flowParseOpaqueType(node, false);
                }
            }
            return super.parseExpressionStatement(node, expr, decorators);
        }
        shouldParseExportDeclaration() {
            const { type  } = this.state;
            if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) return !this.state.containsEsc;
            return super.shouldParseExportDeclaration();
        }
        isExportDefaultSpecifier() {
            const { type  } = this.state;
            if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) return this.state.containsEsc;
            return super.isExportDefaultSpecifier();
        }
        parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(124)) {
                const node = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(node);
            }
            return super.parseExportDefaultExpression();
        }
        parseConditional(expr, startLoc, refExpressionErrors) {
            if (!this.match(17)) return expr;
            if (this.state.maybeInArrowParameters) {
                const nextCh = this.lookaheadCharCode();
                if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
                    this.setOptionalParametersError(refExpressionErrors);
                    return expr;
                }
            }
            this.expect(17);
            const state = this.state.clone();
            const originalNoArrowAt = this.state.noArrowAt;
            const node = this.startNodeAt(startLoc);
            let { consequent , failed  } = this.tryParseConditionalConsequent();
            let [valid, invalid] = this.getArrowLikeExpressions(consequent);
            if (failed || invalid.length > 0) {
                const noArrowAt = [
                    ...originalNoArrowAt
                ];
                if (invalid.length > 0) {
                    this.state = state;
                    this.state.noArrowAt = noArrowAt;
                    for(let i = 0; i < invalid.length; i++)noArrowAt.push(invalid[i].start);
                    ({ consequent , failed  } = this.tryParseConditionalConsequent());
                    [valid, invalid] = this.getArrowLikeExpressions(consequent);
                }
                if (failed && valid.length > 1) this.raise(FlowErrors.AmbiguousConditionalArrow, {
                    at: state.startLoc
                });
                if (failed && valid.length === 1) {
                    this.state = state;
                    noArrowAt.push(valid[0].start);
                    this.state.noArrowAt = noArrowAt;
                    ({ consequent , failed  } = this.tryParseConditionalConsequent());
                }
            }
            this.getArrowLikeExpressions(consequent, true);
            this.state.noArrowAt = originalNoArrowAt;
            this.expect(14);
            node.test = expr;
            node.consequent = consequent;
            node.alternate = this.forwardNoArrowParamsConversionAt(node, ()=>this.parseMaybeAssign(undefined, undefined));
            return this.finishNode(node, "ConditionalExpression");
        }
        tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const consequent = this.parseMaybeAssignAllowIn();
            const failed = !this.match(14);
            this.state.noArrowParamsConversionAt.pop();
            return {
                consequent,
                failed
            };
        }
        getArrowLikeExpressions(node, disallowInvalid) {
            const stack = [
                node
            ];
            const arrows = [];
            while(stack.length !== 0){
                const node = stack.pop();
                if (node.type === "ArrowFunctionExpression") {
                    if (node.typeParameters || !node.returnType) this.finishArrowValidation(node);
                    else arrows.push(node);
                    stack.push(node.body);
                } else if (node.type === "ConditionalExpression") {
                    stack.push(node.consequent);
                    stack.push(node.alternate);
                }
            }
            if (disallowInvalid) {
                arrows.forEach((node)=>this.finishArrowValidation(node));
                return [
                    arrows,
                    []
                ];
            }
            return partition(arrows, (node)=>node.params.every((param)=>this.isAssignable(param, true)));
        }
        finishArrowValidation(node) {
            var _node$extra;
            this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
            this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
            super.checkParams(node, false, true);
            this.scope.exit();
        }
        forwardNoArrowParamsConversionAt(node, parse) {
            let result;
            if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
                this.state.noArrowParamsConversionAt.push(this.state.start);
                result = parse();
                this.state.noArrowParamsConversionAt.pop();
            } else result = parse();
            return result;
        }
        parseParenItem(node, startLoc) {
            node = super.parseParenItem(node, startLoc);
            if (this.eat(17)) {
                node.optional = true;
                this.resetEndLocation(node);
            }
            if (this.match(14)) {
                const typeCastNode = this.startNodeAt(startLoc);
                typeCastNode.expression = node;
                typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
                return this.finishNode(typeCastNode, "TypeCastExpression");
            }
            return node;
        }
        assertModuleNodeAllowed(node) {
            if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") return;
            super.assertModuleNodeAllowed(node);
        }
        parseExportDeclaration(node) {
            if (this.isContextual(128)) {
                node.exportKind = "type";
                const declarationNode = this.startNode();
                this.next();
                if (this.match(5)) {
                    node.specifiers = this.parseExportSpecifiers(true);
                    super.parseExportFrom(node);
                    return null;
                } else return this.flowParseTypeAlias(declarationNode);
            } else if (this.isContextual(129)) {
                node.exportKind = "type";
                const declarationNode = this.startNode();
                this.next();
                return this.flowParseOpaqueType(declarationNode, false);
            } else if (this.isContextual(127)) {
                node.exportKind = "type";
                const declarationNode = this.startNode();
                this.next();
                return this.flowParseInterface(declarationNode);
            } else if (this.shouldParseEnums() && this.isContextual(124)) {
                node.exportKind = "value";
                const declarationNode = this.startNode();
                this.next();
                return this.flowParseEnumDeclaration(declarationNode);
            } else return super.parseExportDeclaration(node);
        }
        eatExportStar(node) {
            if (super.eatExportStar(node)) return true;
            if (this.isContextual(128) && this.lookahead().type === 55) {
                node.exportKind = "type";
                this.next();
                this.next();
                return true;
            }
            return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
            const { startLoc  } = this.state;
            const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
            if (hasNamespace && node.exportKind === "type") this.unexpected(startLoc);
            return hasNamespace;
        }
        parseClassId(node, isStatement, optionalId) {
            super.parseClassId(node, isStatement, optionalId);
            if (this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        parseClassMember(classBody, member, state) {
            const { startLoc  } = this.state;
            if (this.isContextual(123)) {
                if (super.parseClassMemberFromModifier(classBody, member)) return;
                member.declare = true;
            }
            super.parseClassMember(classBody, member, state);
            if (member.declare) {
                if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") this.raise(FlowErrors.DeclareClassElement, {
                    at: startLoc
                });
                else if (member.value) this.raise(FlowErrors.DeclareClassFieldInitializer, {
                    at: member.value
                });
            }
        }
        isIterator(word) {
            return word === "iterator" || word === "asyncIterator";
        }
        readIterator() {
            const word = super.readWord1();
            const fullWord = "@@" + word;
            if (!this.isIterator(word) || !this.state.inType) this.raise(Errors.InvalidIdentifier, {
                at: this.state.curPosition(),
                identifierName: fullWord
            });
            this.finishToken(130, fullWord);
        }
        getTokenFromCode(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (code === 123 && next === 124) this.finishOp(6, 2);
            else if (this.state.inType && (code === 62 || code === 60)) this.finishOp(code === 62 ? 48 : 47, 1);
            else if (this.state.inType && code === 63) {
                if (next === 46) this.finishOp(18, 2);
                else this.finishOp(17, 1);
            } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
                this.state.pos += 2;
                this.readIterator();
            } else super.getTokenFromCode(code);
        }
        isAssignable(node, isBinding) {
            if (node.type === "TypeCastExpression") return this.isAssignable(node.expression, isBinding);
            else return super.isAssignable(node, isBinding);
        }
        toAssignable(node, isLHS = false) {
            if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") node.left = this.typeCastToParameter(node.left);
            super.toAssignable(node, isLHS);
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
            for(let i = 0; i < exprList.length; i++){
                const expr = exprList[i];
                if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") exprList[i] = this.typeCastToParameter(expr);
            }
            super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        toReferencedList(exprList, isParenthesizedExpr) {
            for(let i = 0; i < exprList.length; i++){
                var _expr$extra;
                const expr = exprList[i];
                if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) this.raise(FlowErrors.TypeCastInPattern, {
                    at: expr.typeAnnotation
                });
            }
            return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
            if (canBePattern && !this.state.maybeInArrowParameters) this.toReferencedList(node.elements);
            return node;
        }
        isValidLVal(type, isParenthesized, binding) {
            return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
        }
        parseClassProperty(node) {
            if (this.match(14)) node.typeAnnotation = this.flowParseTypeAnnotation();
            return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
            if (this.match(14)) node.typeAnnotation = this.flowParseTypeAnnotation();
            return super.parseClassPrivateProperty(node);
        }
        isClassMethod() {
            return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
            return this.match(14) || super.isClassProperty();
        }
        isNonstaticConstructor(method) {
            return !this.match(14) && super.isNonstaticConstructor(method);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            if (method.variance) this.unexpected(method.variance.loc.start);
            delete method.variance;
            if (this.match(47)) method.typeParameters = this.flowParseTypeParameterDeclaration();
            super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
            if (method.params && isConstructor) {
                const params = method.params;
                if (params.length > 0 && this.isThisParam(params[0])) this.raise(FlowErrors.ThisParamBannedInConstructor, {
                    at: method
                });
            } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
                const params = method.value.params;
                if (params.length > 0 && this.isThisParam(params[0])) this.raise(FlowErrors.ThisParamBannedInConstructor, {
                    at: method
                });
            }
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            if (method.variance) this.unexpected(method.variance.loc.start);
            delete method.variance;
            if (this.match(47)) method.typeParameters = this.flowParseTypeParameterDeclaration();
            super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        parseClassSuper(node) {
            super.parseClassSuper(node);
            if (node.superClass && this.match(47)) node.superTypeParameters = this.flowParseTypeParameterInstantiation();
            if (this.isContextual(111)) {
                this.next();
                const implemented = node.implements = [];
                do {
                    const node = this.startNode();
                    node.id = this.flowParseRestrictedIdentifier(true);
                    if (this.match(47)) node.typeParameters = this.flowParseTypeParameterInstantiation();
                    else node.typeParameters = null;
                    implemented.push(this.finishNode(node, "ClassImplements"));
                }while (this.eat(12));
            }
        }
        checkGetterSetterParams(method) {
            super.checkGetterSetterParams(method);
            const params = this.getObjectOrClassMethodParams(method);
            if (params.length > 0) {
                const param = params[0];
                if (this.isThisParam(param) && method.kind === "get") this.raise(FlowErrors.GetterMayNotHaveThisParam, {
                    at: param
                });
                else if (this.isThisParam(param)) this.raise(FlowErrors.SetterMayNotHaveThisParam, {
                    at: param
                });
            }
        }
        parsePropertyNamePrefixOperator(node) {
            node.variance = this.flowParseVariance();
        }
        parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
            if (prop.variance) this.unexpected(prop.variance.loc.start);
            delete prop.variance;
            let typeParameters;
            if (this.match(47) && !isAccessor) {
                typeParameters = this.flowParseTypeParameterDeclaration();
                if (!this.match(10)) this.unexpected();
            }
            const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
            if (typeParameters) (result.value || result).typeParameters = typeParameters;
            return result;
        }
        parseAssignableListItemTypes(param) {
            if (this.eat(17)) {
                if (param.type !== "Identifier") this.raise(FlowErrors.PatternIsOptional, {
                    at: param
                });
                if (this.isThisParam(param)) this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                    at: param
                });
                param.optional = true;
            }
            if (this.match(14)) param.typeAnnotation = this.flowParseTypeAnnotation();
            else if (this.isThisParam(param)) this.raise(FlowErrors.ThisParamAnnotationRequired, {
                at: param
            });
            if (this.match(29) && this.isThisParam(param)) this.raise(FlowErrors.ThisParamNoDefault, {
                at: param
            });
            this.resetEndLocation(param);
            return param;
        }
        parseMaybeDefault(startLoc, left) {
            const node = super.parseMaybeDefault(startLoc, left);
            if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) this.raise(FlowErrors.TypeBeforeInitializer, {
                at: node.typeAnnotation
            });
            return node;
        }
        checkImportReflection(node) {
            super.checkImportReflection(node);
            if (node.module && node.importKind !== "value") this.raise(FlowErrors.ImportReflectionHasImportType, {
                at: node.specifiers[0].loc.start
            });
        }
        parseImportSpecifierLocal(node, specifier, type) {
            specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
            node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        isPotentialImportPhase(isExport) {
            if (super.isPotentialImportPhase(isExport)) return true;
            if (this.isContextual(128)) {
                if (!isExport) return true;
                const ch = this.lookaheadCharCode();
                return ch === 123 || ch === 42;
            }
            return !isExport && this.isContextual(87);
        }
        applyImportPhase(node, isExport, phase, loc) {
            super.applyImportPhase(node, isExport, phase, loc);
            if (isExport) {
                if (!phase && this.match(65)) return;
                node.exportKind = phase === "type" ? phase : "value";
            } else {
                if (phase === "type" && this.match(55)) this.unexpected();
                node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
            }
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
            const firstIdent = specifier.imported;
            let specifierTypeKind = null;
            if (firstIdent.type === "Identifier") {
                if (firstIdent.name === "type") specifierTypeKind = "type";
                else if (firstIdent.name === "typeof") specifierTypeKind = "typeof";
            }
            let isBinding = false;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                const as_ident = this.parseIdentifier(true);
                if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
                    specifier.imported = as_ident;
                    specifier.importKind = specifierTypeKind;
                    specifier.local = cloneIdentifier(as_ident);
                } else {
                    specifier.imported = firstIdent;
                    specifier.importKind = null;
                    specifier.local = this.parseIdentifier();
                }
            } else {
                if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
                    specifier.imported = this.parseIdentifier(true);
                    specifier.importKind = specifierTypeKind;
                } else {
                    if (importedIsString) throw this.raise(Errors.ImportBindingIsString, {
                        at: specifier,
                        importName: firstIdent.value
                    });
                    specifier.imported = firstIdent;
                    specifier.importKind = null;
                }
                if (this.eatContextual(93)) specifier.local = this.parseIdentifier();
                else {
                    isBinding = true;
                    specifier.local = cloneIdentifier(specifier.imported);
                }
            }
            const specifierIsTypeImport = hasTypeImportKind(specifier);
            if (isInTypeOnlyImport && specifierIsTypeImport) this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
                at: specifier
            });
            if (isInTypeOnlyImport || specifierIsTypeImport) this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
            if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
            return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        parseBindingAtom() {
            switch(this.state.type){
                case 78:
                    return this.parseIdentifier(true);
                default:
                    return super.parseBindingAtom();
            }
        }
        parseFunctionParams(node, isConstructor) {
            const kind = node.kind;
            if (kind !== "get" && kind !== "set" && this.match(47)) node.typeParameters = this.flowParseTypeParameterDeclaration();
            super.parseFunctionParams(node, isConstructor);
        }
        parseVarId(decl, kind) {
            super.parseVarId(decl, kind);
            if (this.match(14)) {
                decl.id.typeAnnotation = this.flowParseTypeAnnotation();
                this.resetEndLocation(decl.id);
            }
        }
        parseAsyncArrowFromCallExpression(node, call) {
            if (this.match(14)) {
                const oldNoAnonFunctionType = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                node.returnType = this.flowParseTypeAnnotation();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
            }
            return super.parseAsyncArrowFromCallExpression(node, call);
        }
        shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
            var _jsx;
            let state = null;
            let jsx;
            if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                state = this.state.clone();
                jsx = this.tryParse(()=>super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
                if (!jsx.error) return jsx.node;
                const { context  } = this.state;
                const currentContext = context[context.length - 1];
                if (currentContext === types.j_oTag || currentContext === types.j_expr) context.pop();
            }
            if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {
                var _jsx2, _jsx3;
                state = state || this.state.clone();
                let typeParameters;
                const arrow = this.tryParse((abort)=>{
                    var _arrowExpression$extr;
                    typeParameters = this.flowParseTypeParameterDeclaration();
                    const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, ()=>{
                        const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                        this.resetStartLocationFromNode(result, typeParameters);
                        return result;
                    });
                    if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();
                    const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);
                    if (expr.type !== "ArrowFunctionExpression") abort();
                    expr.typeParameters = typeParameters;
                    this.resetStartLocationFromNode(expr, typeParameters);
                    return arrowExpression;
                }, state);
                let arrowExpression = null;
                if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
                    if (!arrow.error && !arrow.aborted) {
                        if (arrow.node.async) this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                            at: typeParameters
                        });
                        return arrow.node;
                    }
                    arrowExpression = arrow.node;
                }
                if ((_jsx2 = jsx) != null && _jsx2.node) {
                    this.state = jsx.failState;
                    return jsx.node;
                }
                if (arrowExpression) {
                    this.state = arrow.failState;
                    return arrowExpression;
                }
                if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
                if (arrow.thrown) throw arrow.error;
                throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
                    at: typeParameters
                });
            }
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        parseArrow(node) {
            if (this.match(14)) {
                const result = this.tryParse(()=>{
                    const oldNoAnonFunctionType = this.state.noAnonFunctionType;
                    this.state.noAnonFunctionType = true;
                    const typeNode = this.startNode();
                    [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
                    this.state.noAnonFunctionType = oldNoAnonFunctionType;
                    if (this.canInsertSemicolon()) this.unexpected();
                    if (!this.match(19)) this.unexpected();
                    return typeNode;
                });
                if (result.thrown) return null;
                if (result.error) this.state = result.failState;
                node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(node);
        }
        shouldParseArrow(params) {
            return this.match(14) || super.shouldParseArrow(params);
        }
        setArrowFunctionParameters(node, params) {
            if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) node.params = params;
            else super.setArrowFunctionParameters(node, params);
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
            if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) return;
            for(let i = 0; i < node.params.length; i++)if (this.isThisParam(node.params[i]) && i > 0) this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node.params[i]
            });
            super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
        }
        parseParenAndDistinguishExpression(canBeArrow) {
            return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
        parseSubscripts(base, startLoc, noCalls) {
            if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
                this.next();
                const node = this.startNodeAt(startLoc);
                node.callee = base;
                node.arguments = super.parseCallExpressionArguments(11, false);
                base = this.finishNode(node, "CallExpression");
            } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
                const state = this.state.clone();
                const arrow = this.tryParse((abort)=>this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
                if (!arrow.error && !arrow.aborted) return arrow.node;
                const result = this.tryParse(()=>super.parseSubscripts(base, startLoc, noCalls), state);
                if (result.node && !result.error) return result.node;
                if (arrow.node) {
                    this.state = arrow.failState;
                    return arrow.node;
                }
                if (result.node) {
                    this.state = result.failState;
                    return result.node;
                }
                throw arrow.error || result.error;
            }
            return super.parseSubscripts(base, startLoc, noCalls);
        }
        parseSubscript(base, startLoc, noCalls, subscriptState) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
                subscriptState.optionalChainMember = true;
                if (noCalls) {
                    subscriptState.stop = true;
                    return base;
                }
                this.next();
                const node = this.startNodeAt(startLoc);
                node.callee = base;
                node.typeArguments = this.flowParseTypeParameterInstantiation();
                this.expect(10);
                node.arguments = this.parseCallExpressionArguments(11, false);
                node.optional = true;
                return this.finishCallExpression(node, true);
            } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
                const node = this.startNodeAt(startLoc);
                node.callee = base;
                const result = this.tryParse(()=>{
                    node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
                    this.expect(10);
                    node.arguments = super.parseCallExpressionArguments(11, false);
                    if (subscriptState.optionalChainMember) node.optional = false;
                    return this.finishCallExpression(node, subscriptState.optionalChainMember);
                });
                if (result.node) {
                    if (result.error) this.state = result.failState;
                    return result.node;
                }
            }
            return super.parseSubscript(base, startLoc, noCalls, subscriptState);
        }
        parseNewCallee(node) {
            super.parseNewCallee(node);
            let targs = null;
            if (this.shouldParseTypes() && this.match(47)) targs = this.tryParse(()=>this.flowParseTypeParameterInstantiationCallOrNew()).node;
            node.typeArguments = targs;
        }
        parseAsyncArrowWithTypeParameters(startLoc) {
            const node = this.startNodeAt(startLoc);
            this.parseFunctionParams(node, false);
            if (!this.parseArrow(node)) return;
            return super.parseArrowExpression(node, undefined, true);
        }
        readToken_mult_modulo(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (code === 42 && next === 47 && this.state.hasFlowComment) {
                this.state.hasFlowComment = false;
                this.state.pos += 2;
                this.nextToken();
                return;
            }
            super.readToken_mult_modulo(code);
        }
        readToken_pipe_amp(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (code === 124 && next === 125) {
                this.finishOp(9, 2);
                return;
            }
            super.readToken_pipe_amp(code);
        }
        parseTopLevel(file, program) {
            const fileNode = super.parseTopLevel(file, program);
            if (this.state.hasFlowComment) this.raise(FlowErrors.UnterminatedFlowComment, {
                at: this.state.curPosition()
            });
            return fileNode;
        }
        skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                if (this.state.hasFlowComment) throw this.raise(FlowErrors.NestedFlowComment, {
                    at: this.state.startLoc
                });
                this.hasFlowCommentCompletion();
                const commentSkip = this.skipFlowComment();
                if (commentSkip) {
                    this.state.pos += commentSkip;
                    this.state.hasFlowComment = true;
                }
                return;
            }
            return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
        }
        skipFlowComment() {
            const { pos  } = this.state;
            let shiftToFirstNonWhiteSpace = 2;
            while([
                32,
                9
            ].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace)))shiftToFirstNonWhiteSpace++;
            const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
            const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
            if (ch2 === 58 && ch3 === 58) return shiftToFirstNonWhiteSpace + 2;
            if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") return shiftToFirstNonWhiteSpace + 12;
            if (ch2 === 58 && ch3 !== 58) return shiftToFirstNonWhiteSpace;
            return false;
        }
        hasFlowCommentCompletion() {
            const end = this.input.indexOf("*/", this.state.pos);
            if (end === -1) throw this.raise(Errors.UnterminatedComment, {
                at: this.state.curPosition()
            });
        }
        flowEnumErrorBooleanMemberNotInitialized(loc, { enumName , memberName  }) {
            this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
                at: loc,
                memberName,
                enumName
            });
        }
        flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
            return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
                at: loc
            }, enumContext));
        }
        flowEnumErrorNumberMemberNotInitialized(loc, { enumName , memberName  }) {
            this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
                at: loc,
                enumName,
                memberName
            });
        }
        flowEnumErrorStringMemberInconsistentlyInitailized(node, { enumName  }) {
            this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
                at: node,
                enumName
            });
        }
        flowEnumMemberInit() {
            const startLoc = this.state.startLoc;
            const endOfInit = ()=>this.match(12) || this.match(8);
            switch(this.state.type){
                case 132:
                    {
                        const literal = this.parseNumericLiteral(this.state.value);
                        if (endOfInit()) return {
                            type: "number",
                            loc: literal.loc.start,
                            value: literal
                        };
                        return {
                            type: "invalid",
                            loc: startLoc
                        };
                    }
                case 131:
                    {
                        const literal = this.parseStringLiteral(this.state.value);
                        if (endOfInit()) return {
                            type: "string",
                            loc: literal.loc.start,
                            value: literal
                        };
                        return {
                            type: "invalid",
                            loc: startLoc
                        };
                    }
                case 85:
                case 86:
                    {
                        const literal = this.parseBooleanLiteral(this.match(85));
                        if (endOfInit()) return {
                            type: "boolean",
                            loc: literal.loc.start,
                            value: literal
                        };
                        return {
                            type: "invalid",
                            loc: startLoc
                        };
                    }
                default:
                    return {
                        type: "invalid",
                        loc: startLoc
                    };
            }
        }
        flowEnumMemberRaw() {
            const loc = this.state.startLoc;
            const id = this.parseIdentifier(true);
            const init = this.eat(29) ? this.flowEnumMemberInit() : {
                type: "none",
                loc
            };
            return {
                id,
                init
            };
        }
        flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
            const { explicitType  } = context;
            if (explicitType === null) return;
            if (explicitType !== expectedType) this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
        flowEnumMembers({ enumName , explicitType  }) {
            const seenNames = new Set();
            const members = {
                booleanMembers: [],
                numberMembers: [],
                stringMembers: [],
                defaultedMembers: []
            };
            let hasUnknownMembers = false;
            while(!this.match(8)){
                if (this.eat(21)) {
                    hasUnknownMembers = true;
                    break;
                }
                const memberNode = this.startNode();
                const { id , init  } = this.flowEnumMemberRaw();
                const memberName = id.name;
                if (memberName === "") continue;
                if (/^[a-z]/.test(memberName)) this.raise(FlowErrors.EnumInvalidMemberName, {
                    at: id,
                    memberName,
                    suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                    enumName
                });
                if (seenNames.has(memberName)) this.raise(FlowErrors.EnumDuplicateMemberName, {
                    at: id,
                    memberName,
                    enumName
                });
                seenNames.add(memberName);
                const context = {
                    enumName,
                    explicitType,
                    memberName
                };
                memberNode.id = id;
                switch(init.type){
                    case "boolean":
                        this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
                        memberNode.init = init.value;
                        members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                        break;
                    case "number":
                        this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
                        memberNode.init = init.value;
                        members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                        break;
                    case "string":
                        this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
                        memberNode.init = init.value;
                        members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                        break;
                    case "invalid":
                        throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
                    case "none":
                        switch(explicitType){
                            case "boolean":
                                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                                break;
                            case "number":
                                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                                break;
                            default:
                                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                        }
                }
                if (!this.match(8)) this.expect(12);
            }
            return {
                members,
                hasUnknownMembers
            };
        }
        flowEnumStringMembers(initializedMembers, defaultedMembers, { enumName  }) {
            if (initializedMembers.length === 0) return defaultedMembers;
            else if (defaultedMembers.length === 0) return initializedMembers;
            else if (defaultedMembers.length > initializedMembers.length) {
                for (const member of initializedMembers)this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                    enumName
                });
                return defaultedMembers;
            } else {
                for (const member of defaultedMembers)this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                    enumName
                });
                return initializedMembers;
            }
        }
        flowEnumParseExplicitType({ enumName  }) {
            if (!this.eatContextual(101)) return null;
            if (!tokenIsIdentifier(this.state.type)) throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
                at: this.state.startLoc,
                enumName
            });
            const { value  } = this.state;
            this.next();
            if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") this.raise(FlowErrors.EnumInvalidExplicitType, {
                at: this.state.startLoc,
                enumName,
                invalidEnumType: value
            });
            return value;
        }
        flowEnumBody(node, id) {
            const enumName = id.name;
            const nameLoc = id.loc.start;
            const explicitType = this.flowEnumParseExplicitType({
                enumName
            });
            this.expect(5);
            const { members , hasUnknownMembers  } = this.flowEnumMembers({
                enumName,
                explicitType
            });
            node.hasUnknownMembers = hasUnknownMembers;
            switch(explicitType){
                case "boolean":
                    node.explicitType = true;
                    node.members = members.booleanMembers;
                    this.expect(8);
                    return this.finishNode(node, "EnumBooleanBody");
                case "number":
                    node.explicitType = true;
                    node.members = members.numberMembers;
                    this.expect(8);
                    return this.finishNode(node, "EnumNumberBody");
                case "string":
                    node.explicitType = true;
                    node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                        enumName
                    });
                    this.expect(8);
                    return this.finishNode(node, "EnumStringBody");
                case "symbol":
                    node.members = members.defaultedMembers;
                    this.expect(8);
                    return this.finishNode(node, "EnumSymbolBody");
                default:
                    {
                        const empty = ()=>{
                            node.members = [];
                            this.expect(8);
                            return this.finishNode(node, "EnumStringBody");
                        };
                        node.explicitType = false;
                        const boolsLen = members.booleanMembers.length;
                        const numsLen = members.numberMembers.length;
                        const strsLen = members.stringMembers.length;
                        const defaultedLen = members.defaultedMembers.length;
                        if (!boolsLen && !numsLen && !strsLen && !defaultedLen) return empty();
                        else if (!boolsLen && !numsLen) {
                            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                                enumName
                            });
                            this.expect(8);
                            return this.finishNode(node, "EnumStringBody");
                        } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                            for (const member of members.defaultedMembers)this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                                enumName,
                                memberName: member.id.name
                            });
                            node.members = members.booleanMembers;
                            this.expect(8);
                            return this.finishNode(node, "EnumBooleanBody");
                        } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                            for (const member of members.defaultedMembers)this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                                enumName,
                                memberName: member.id.name
                            });
                            node.members = members.numberMembers;
                            this.expect(8);
                            return this.finishNode(node, "EnumNumberBody");
                        } else {
                            this.raise(FlowErrors.EnumInconsistentMemberValues, {
                                at: nameLoc,
                                enumName
                            });
                            return empty();
                        }
                    }
            }
        }
        flowParseEnumDeclaration(node) {
            const id = this.parseIdentifier();
            node.id = id;
            node.body = this.flowEnumBody(this.startNode(), id);
            return this.finishNode(node, "EnumDeclaration");
        }
        isLookaheadToken_lt() {
            const next = this.nextTokenStart();
            if (this.input.charCodeAt(next) === 60) {
                const afterNext = this.input.charCodeAt(next + 1);
                return afterNext !== 60 && afterNext !== 61;
            }
            return false;
        }
        maybeUnwrapTypeCastExpression(node) {
            return node.type === "TypeCastExpression" ? node.expression : node;
        }
    };
const entities = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xa0",
    iexcl: "\xa1",
    cent: "\xa2",
    pound: "\xa3",
    curren: "\xa4",
    yen: "\xa5",
    brvbar: "\xa6",
    sect: "\xa7",
    uml: "\xa8",
    copy: "\xa9",
    ordf: "\xaa",
    laquo: "\xab",
    not: "\xac",
    shy: "\xad",
    reg: "\xae",
    macr: "\xaf",
    deg: "\xb0",
    plusmn: "\xb1",
    sup2: "\xb2",
    sup3: "\xb3",
    acute: "\xb4",
    micro: "\xb5",
    para: "\xb6",
    middot: "\xb7",
    cedil: "\xb8",
    sup1: "\xb9",
    ordm: "\xba",
    raquo: "\xbb",
    frac14: "\xbc",
    frac12: "\xbd",
    frac34: "\xbe",
    iquest: "\xbf",
    Agrave: "\xc0",
    Aacute: "\xc1",
    Acirc: "\xc2",
    Atilde: "\xc3",
    Auml: "\xc4",
    Aring: "\xc5",
    AElig: "\xc6",
    Ccedil: "\xc7",
    Egrave: "\xc8",
    Eacute: "\xc9",
    Ecirc: "\xca",
    Euml: "\xcb",
    Igrave: "\xcc",
    Iacute: "\xcd",
    Icirc: "\xce",
    Iuml: "\xcf",
    ETH: "\xd0",
    Ntilde: "\xd1",
    Ograve: "\xd2",
    Oacute: "\xd3",
    Ocirc: "\xd4",
    Otilde: "\xd5",
    Ouml: "\xd6",
    times: "\xd7",
    Oslash: "\xd8",
    Ugrave: "\xd9",
    Uacute: "\xda",
    Ucirc: "\xdb",
    Uuml: "\xdc",
    Yacute: "\xdd",
    THORN: "\xde",
    szlig: "\xdf",
    agrave: "\xe0",
    aacute: "\xe1",
    acirc: "\xe2",
    atilde: "\xe3",
    auml: "\xe4",
    aring: "\xe5",
    aelig: "\xe6",
    ccedil: "\xe7",
    egrave: "\xe8",
    eacute: "\xe9",
    ecirc: "\xea",
    euml: "\xeb",
    igrave: "\xec",
    iacute: "\xed",
    icirc: "\xee",
    iuml: "\xef",
    eth: "\xf0",
    ntilde: "\xf1",
    ograve: "\xf2",
    oacute: "\xf3",
    ocirc: "\xf4",
    otilde: "\xf5",
    ouml: "\xf6",
    divide: "\xf7",
    oslash: "\xf8",
    ugrave: "\xf9",
    uacute: "\xfa",
    ucirc: "\xfb",
    uuml: "\xfc",
    yacute: "\xfd",
    thorn: "\xfe",
    yuml: "\xff",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
};
const JsxErrors = ParseErrorEnum`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: ({ openingTagName  })=>`Expected corresponding JSX closing tag for <${openingTagName}>.`,
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: ({ unexpected , HTMLEntity  })=>`Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
});
function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
}
function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") return object.name;
    if (object.type === "JSXNamespacedName") return object.namespace.name + ":" + object.name.name;
    if (object.type === "JSXMemberExpression") return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    throw new Error("Node had unexpected type: " + object.type);
}
var jsx = (superClass)=>class JSXParserMixin extends superClass {
        jsxReadToken() {
            let out = "";
            let chunkStart = this.state.pos;
            for(;;){
                if (this.state.pos >= this.length) throw this.raise(JsxErrors.UnterminatedJsxContent, {
                    at: this.state.startLoc
                });
                const ch = this.input.charCodeAt(this.state.pos);
                switch(ch){
                    case 60:
                    case 123:
                        if (this.state.pos === this.state.start) {
                            if (ch === 60 && this.state.canStartJSXElement) {
                                ++this.state.pos;
                                this.finishToken(140);
                            } else super.getTokenFromCode(ch);
                            return;
                        }
                        out += this.input.slice(chunkStart, this.state.pos);
                        this.finishToken(139, out);
                        return;
                    case 38:
                        out += this.input.slice(chunkStart, this.state.pos);
                        out += this.jsxReadEntity();
                        chunkStart = this.state.pos;
                        break;
                    case 62:
                    case 125:
                    default:
                        if (isNewLine(ch)) {
                            out += this.input.slice(chunkStart, this.state.pos);
                            out += this.jsxReadNewLine(true);
                            chunkStart = this.state.pos;
                        } else ++this.state.pos;
                }
            }
        }
        jsxReadNewLine(normalizeCRLF) {
            const ch = this.input.charCodeAt(this.state.pos);
            let out;
            ++this.state.pos;
            if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
                out = normalizeCRLF ? "\n" : "\r\n";
            } else out = String.fromCharCode(ch);
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            return out;
        }
        jsxReadString(quote) {
            let out = "";
            let chunkStart = ++this.state.pos;
            for(;;){
                if (this.state.pos >= this.length) throw this.raise(Errors.UnterminatedString, {
                    at: this.state.startLoc
                });
                const ch = this.input.charCodeAt(this.state.pos);
                if (ch === quote) break;
                if (ch === 38) {
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadEntity();
                    chunkStart = this.state.pos;
                } else if (isNewLine(ch)) {
                    out += this.input.slice(chunkStart, this.state.pos);
                    out += this.jsxReadNewLine(false);
                    chunkStart = this.state.pos;
                } else ++this.state.pos;
            }
            out += this.input.slice(chunkStart, this.state.pos++);
            this.finishToken(131, out);
        }
        jsxReadEntity() {
            const startPos = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
                ++this.state.pos;
                let radix = 10;
                if (this.codePointAtPos(this.state.pos) === 120) {
                    radix = 16;
                    ++this.state.pos;
                }
                const codePoint = this.readInt(radix, undefined, false, "bail");
                if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
                    ++this.state.pos;
                    return String.fromCodePoint(codePoint);
                }
            } else {
                let count = 0;
                let semi = false;
                while(count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59))++this.state.pos;
                if (semi) {
                    const desc = this.input.slice(startPos, this.state.pos);
                    const entity = entities[desc];
                    ++this.state.pos;
                    if (entity) return entity;
                }
            }
            this.state.pos = startPos;
            return "&";
        }
        jsxReadWord() {
            let ch;
            const start = this.state.pos;
            do ch = this.input.charCodeAt(++this.state.pos);
            while (isIdentifierChar(ch) || ch === 45);
            this.finishToken(138, this.input.slice(start, this.state.pos));
        }
        jsxParseIdentifier() {
            const node = this.startNode();
            if (this.match(138)) node.name = this.state.value;
            else if (tokenIsKeyword(this.state.type)) node.name = tokenLabelName(this.state.type);
            else this.unexpected();
            this.next();
            return this.finishNode(node, "JSXIdentifier");
        }
        jsxParseNamespacedName() {
            const startLoc = this.state.startLoc;
            const name = this.jsxParseIdentifier();
            if (!this.eat(14)) return name;
            const node = this.startNodeAt(startLoc);
            node.namespace = name;
            node.name = this.jsxParseIdentifier();
            return this.finishNode(node, "JSXNamespacedName");
        }
        jsxParseElementName() {
            const startLoc = this.state.startLoc;
            let node = this.jsxParseNamespacedName();
            if (node.type === "JSXNamespacedName") return node;
            while(this.eat(16)){
                const newNode = this.startNodeAt(startLoc);
                newNode.object = node;
                newNode.property = this.jsxParseIdentifier();
                node = this.finishNode(newNode, "JSXMemberExpression");
            }
            return node;
        }
        jsxParseAttributeValue() {
            let node;
            switch(this.state.type){
                case 5:
                    node = this.startNode();
                    this.setContext(types.brace);
                    this.next();
                    node = this.jsxParseExpressionContainer(node, types.j_oTag);
                    if (node.expression.type === "JSXEmptyExpression") this.raise(JsxErrors.AttributeIsEmpty, {
                        at: node
                    });
                    return node;
                case 140:
                case 131:
                    return this.parseExprAtom();
                default:
                    throw this.raise(JsxErrors.UnsupportedJsxValue, {
                        at: this.state.startLoc
                    });
            }
        }
        jsxParseEmptyExpression() {
            const node = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
        }
        jsxParseSpreadChild(node) {
            this.next();
            node.expression = this.parseExpression();
            this.setContext(types.j_expr);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(node, "JSXSpreadChild");
        }
        jsxParseExpressionContainer(node, previousContext) {
            if (this.match(8)) node.expression = this.jsxParseEmptyExpression();
            else {
                const expression = this.parseExpression();
                node.expression = expression;
            }
            this.setContext(previousContext);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(node, "JSXExpressionContainer");
        }
        jsxParseAttribute() {
            const node = this.startNode();
            if (this.match(5)) {
                this.setContext(types.brace);
                this.next();
                this.expect(21);
                node.argument = this.parseMaybeAssignAllowIn();
                this.setContext(types.j_oTag);
                this.state.canStartJSXElement = true;
                this.expect(8);
                return this.finishNode(node, "JSXSpreadAttribute");
            }
            node.name = this.jsxParseNamespacedName();
            node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
            return this.finishNode(node, "JSXAttribute");
        }
        jsxParseOpeningElementAt(startLoc) {
            const node = this.startNodeAt(startLoc);
            if (this.eat(141)) return this.finishNode(node, "JSXOpeningFragment");
            node.name = this.jsxParseElementName();
            return this.jsxParseOpeningElementAfterName(node);
        }
        jsxParseOpeningElementAfterName(node) {
            const attributes = [];
            while(!this.match(56) && !this.match(141))attributes.push(this.jsxParseAttribute());
            node.attributes = attributes;
            node.selfClosing = this.eat(56);
            this.expect(141);
            return this.finishNode(node, "JSXOpeningElement");
        }
        jsxParseClosingElementAt(startLoc) {
            const node = this.startNodeAt(startLoc);
            if (this.eat(141)) return this.finishNode(node, "JSXClosingFragment");
            node.name = this.jsxParseElementName();
            this.expect(141);
            return this.finishNode(node, "JSXClosingElement");
        }
        jsxParseElementAt(startLoc) {
            const node = this.startNodeAt(startLoc);
            const children = [];
            const openingElement = this.jsxParseOpeningElementAt(startLoc);
            let closingElement = null;
            if (!openingElement.selfClosing) {
                contents: for(;;)switch(this.state.type){
                    case 140:
                        startLoc = this.state.startLoc;
                        this.next();
                        if (this.eat(56)) {
                            closingElement = this.jsxParseClosingElementAt(startLoc);
                            break contents;
                        }
                        children.push(this.jsxParseElementAt(startLoc));
                        break;
                    case 139:
                        children.push(this.parseExprAtom());
                        break;
                    case 5:
                        {
                            const node = this.startNode();
                            this.setContext(types.brace);
                            this.next();
                            if (this.match(21)) children.push(this.jsxParseSpreadChild(node));
                            else children.push(this.jsxParseExpressionContainer(node, types.j_expr));
                            break;
                        }
                    default:
                        this.unexpected();
                }
                if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) this.raise(JsxErrors.MissingClosingTagFragment, {
                    at: closingElement
                });
                else if (!isFragment(openingElement) && isFragment(closingElement)) this.raise(JsxErrors.MissingClosingTagElement, {
                    at: closingElement,
                    openingTagName: getQualifiedJSXName(openingElement.name)
                });
                else if (!isFragment(openingElement) && !isFragment(closingElement)) {
                    if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) this.raise(JsxErrors.MissingClosingTagElement, {
                        at: closingElement,
                        openingTagName: getQualifiedJSXName(openingElement.name)
                    });
                }
            }
            if (isFragment(openingElement)) {
                node.openingFragment = openingElement;
                node.closingFragment = closingElement;
            } else {
                node.openingElement = openingElement;
                node.closingElement = closingElement;
            }
            node.children = children;
            if (this.match(47)) throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
                at: this.state.startLoc
            });
            return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        }
        jsxParseElement() {
            const startLoc = this.state.startLoc;
            this.next();
            return this.jsxParseElementAt(startLoc);
        }
        setContext(newContext) {
            const { context  } = this.state;
            context[context.length - 1] = newContext;
        }
        parseExprAtom(refExpressionErrors) {
            if (this.match(139)) return this.parseLiteral(this.state.value, "JSXText");
            else if (this.match(140)) return this.jsxParseElement();
            else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
                this.replaceToken(140);
                return this.jsxParseElement();
            } else return super.parseExprAtom(refExpressionErrors);
        }
        skipSpace() {
            const curContext = this.curContext();
            if (!curContext.preserveSpace) super.skipSpace();
        }
        getTokenFromCode(code) {
            const context = this.curContext();
            if (context === types.j_expr) {
                this.jsxReadToken();
                return;
            }
            if (context === types.j_oTag || context === types.j_cTag) {
                if (isIdentifierStart(code)) {
                    this.jsxReadWord();
                    return;
                }
                if (code === 62) {
                    ++this.state.pos;
                    this.finishToken(141);
                    return;
                }
                if ((code === 34 || code === 39) && context === types.j_oTag) {
                    this.jsxReadString(code);
                    return;
                }
            }
            if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                ++this.state.pos;
                this.finishToken(140);
                return;
            }
            super.getTokenFromCode(code);
        }
        updateContext(prevType) {
            const { context , type  } = this.state;
            if (type === 56 && prevType === 140) {
                context.splice(-2, 2, types.j_cTag);
                this.state.canStartJSXElement = false;
            } else if (type === 140) context.push(types.j_oTag);
            else if (type === 141) {
                const out = context[context.length - 1];
                if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
                    context.pop();
                    this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
                } else {
                    this.setContext(types.j_expr);
                    this.state.canStartJSXElement = true;
                }
            } else this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
    };
class TypeScriptScope extends Scope {
    constructor(...args){
        super(...args);
        this.types = new Set();
        this.enums = new Set();
        this.constEnums = new Set();
        this.classes = new Set();
        this.exportOnlyBindings = new Set();
    }
}
class TypeScriptScopeHandler extends ScopeHandler {
    constructor(...args){
        super(...args);
        this.importsStack = [];
    }
    createScope(flags) {
        this.importsStack.push(new Set());
        return new TypeScriptScope(flags);
    }
    enter(flags) {
        if (flags == SCOPE_TS_MODULE) this.importsStack.push(new Set());
        super.enter(flags);
    }
    exit() {
        const flags = super.exit();
        if (flags == SCOPE_TS_MODULE) this.importsStack.pop();
        return flags;
    }
    hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name)) return true;
        if (!allowShadow && len > 1) for(let i = 0; i < len - 1; i++){
            if (this.importsStack[i].has(name)) return true;
        }
        return false;
    }
    declareName(name, bindingType, loc) {
        if (bindingType & BIND_FLAGS_TS_IMPORT) {
            if (this.hasImport(name, true)) this.parser.raise(Errors.VarRedeclaration, {
                at: loc,
                identifierName: name
            });
            this.importsStack[this.importsStack.length - 1].add(name);
            return;
        }
        const scope = this.currentScope();
        if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
            this.maybeExportDefined(scope, name);
            scope.exportOnlyBindings.add(name);
            return;
        }
        super.declareName(name, bindingType, loc);
        if (bindingType & BIND_KIND_TYPE) {
            if (!(bindingType & BIND_KIND_VALUE)) {
                this.checkRedeclarationInScope(scope, name, bindingType, loc);
                this.maybeExportDefined(scope, name);
            }
            scope.types.add(name);
        }
        if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);
        if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);
        if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);
    }
    isRedeclaredInScope(scope, name, bindingType) {
        if (scope.enums.has(name)) {
            if (bindingType & BIND_FLAGS_TS_ENUM) {
                const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
                const wasConst = scope.constEnums.has(name);
                return isConst !== wasConst;
            }
            return true;
        }
        if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
            if (scope.lexical.has(name)) return !!(bindingType & BIND_KIND_VALUE);
            else return false;
        }
        if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) return true;
        return super.isRedeclaredInScope(scope, name, bindingType);
    }
    checkLocalExport(id) {
        const { name  } = id;
        if (this.hasImport(name)) return;
        const len = this.scopeStack.length;
        for(let i = len - 1; i >= 0; i--){
            const scope = this.scopeStack[i];
            if (scope.types.has(name) || scope.exportOnlyBindings.has(name)) return;
        }
        super.checkLocalExport(id);
    }
}
const getOwn$1 = (object, key)=>Object.hasOwnProperty.call(object, key) && object[key];
const unwrapParenthesizedExpression = (node)=>{
    return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
};
class LValParser extends NodeUtils {
    toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = undefined;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
            parenthesized = unwrapParenthesizedExpression(node);
            if (isLHS) {
                if (parenthesized.type === "Identifier") this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, {
                    at: node
                });
                else if (parenthesized.type !== "MemberExpression") this.raise(Errors.InvalidParenthesizedAssignment, {
                    at: node
                });
            } else this.raise(Errors.InvalidParenthesizedAssignment, {
                at: node
            });
        }
        switch(node.type){
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
                break;
            case "ObjectExpression":
                node.type = "ObjectPattern";
                for(let i = 0, length = node.properties.length, last = length - 1; i < length; i++){
                    var _node$extra2;
                    const prop = node.properties[i];
                    const isLast = i === last;
                    this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                    if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) this.raise(Errors.RestTrailingComma, {
                        at: node.extra.trailingCommaLoc
                    });
                }
                break;
            case "ObjectProperty":
                {
                    const { key , value  } = node;
                    if (this.isPrivateName(key)) this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
                    this.toAssignable(value, isLHS);
                    break;
                }
            case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
            case "ArrayExpression":
                node.type = "ArrayPattern";
                this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
                break;
            case "AssignmentExpression":
                if (node.operator !== "=") this.raise(Errors.MissingEqInAssignment, {
                    at: node.left.loc.end
                });
                node.type = "AssignmentPattern";
                delete node.operator;
                this.toAssignable(node.left, isLHS);
                break;
            case "ParenthesizedExpression":
                this.toAssignable(parenthesized, isLHS);
                break;
        }
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
            at: prop.key
        });
        else if (prop.type === "SpreadElement") {
            prop.type = "RestElement";
            const arg = prop.argument;
            this.checkToRestConversion(arg, false);
            this.toAssignable(arg, isLHS);
            if (!isLast) this.raise(Errors.RestTrailingComma, {
                at: prop
            });
        } else this.toAssignable(prop, isLHS);
    }
    toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        for(let i = 0; i <= end; i++){
            const elt = exprList[i];
            if (!elt) continue;
            if (elt.type === "SpreadElement") {
                elt.type = "RestElement";
                const arg = elt.argument;
                this.checkToRestConversion(arg, true);
                this.toAssignable(arg, isLHS);
            } else this.toAssignable(elt, isLHS);
            if (elt.type === "RestElement") {
                if (i < end) this.raise(Errors.RestTrailingComma, {
                    at: elt
                });
                else if (trailingCommaLoc) this.raise(Errors.RestTrailingComma, {
                    at: trailingCommaLoc
                });
            }
        }
    }
    isAssignable(node, isBinding) {
        switch(node.type){
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
                return true;
            case "ObjectExpression":
                {
                    const last = node.properties.length - 1;
                    return node.properties.every((prop, i)=>{
                        return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
                    });
                }
            case "ObjectProperty":
                return this.isAssignable(node.value);
            case "SpreadElement":
                return this.isAssignable(node.argument);
            case "ArrayExpression":
                return node.elements.every((element)=>element === null || this.isAssignable(element));
            case "AssignmentExpression":
                return node.operator === "=";
            case "ParenthesizedExpression":
                return this.isAssignable(node.expression);
            case "MemberExpression":
            case "OptionalMemberExpression":
                return !isBinding;
            default:
                return false;
        }
    }
    toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
    }
    toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList)if ((expr == null ? void 0 : expr.type) === "ArrayExpression") this.toReferencedListDeep(expr.elements);
    }
    parseSpread(refExpressionErrors) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);
        return this.finishNode(node, "SpreadElement");
    }
    parseRestBinding() {
        const node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
    }
    parseBindingAtom() {
        switch(this.state.type){
            case 0:
                {
                    const node = this.startNode();
                    this.next();
                    node.elements = this.parseBindingList(3, 93, 1);
                    return this.finishNode(node, "ArrayPattern");
                }
            case 5:
                return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
    }
    parseBindingList(close, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first = true;
        while(!this.eat(close)){
            if (first) first = false;
            else this.expect(12);
            if (allowEmpty && this.match(12)) elts.push(null);
            else if (this.eat(close)) break;
            else if (this.match(21)) {
                elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));
                if (!this.checkCommaAfterRest(closeCharCode)) {
                    this.expect(close);
                    break;
                }
            } else {
                const decorators = [];
                if (this.match(26) && this.hasPlugin("decorators")) this.raise(Errors.UnsupportedParameterDecorator, {
                    at: this.state.startLoc
                });
                while(this.match(26))decorators.push(this.parseDecorator());
                elts.push(this.parseAssignableListItem(flags, decorators));
            }
        }
        return elts;
    }
    parseBindingRestProperty(prop) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
    }
    parseBindingProperty() {
        const prop = this.startNode();
        const { type , startLoc  } = this.state;
        if (type === 21) return this.parseBindingRestProperty(prop);
        else if (type === 136) {
            this.expectPlugin("destructuringPrivate", startLoc);
            this.classScope.usePrivateName(this.state.value, startLoc);
            prop.key = this.parsePrivateName();
        } else this.parsePropertyName(prop);
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
    }
    parseAssignableListItem(flags, decorators) {
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left, flags);
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (decorators.length) left.decorators = decorators;
        return elt;
    }
    parseAssignableListItemTypes(param, flags) {
        return param;
    }
    parseMaybeDefault(startLoc, left) {
        var _startLoc, _left;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        left = (_left = left) != null ? _left : this.parseBindingAtom();
        if (!this.eat(29)) return left;
        const node = this.startNodeAt(startLoc);
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
    }
    isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return getOwn$1({
            AssignmentPattern: "left",
            RestElement: "argument",
            ObjectProperty: "value",
            ParenthesizedExpression: "expression",
            ArrayPattern: "elements",
            ObjectPattern: "properties"
        }, type);
    }
    checkLVal(expression, { in: ancestor , binding =BIND_NONE , checkClashes =false , strictModeChanged =false , hasParenthesizedAncestor =false  }) {
        var _expression$extra;
        const type = expression.type;
        if (this.isObjectMethod(expression)) return;
        if (type === "MemberExpression") {
            if (binding !== BIND_NONE) this.raise(Errors.InvalidPropertyBindingPattern, {
                at: expression
            });
            return;
        }
        if (type === "Identifier") {
            this.checkIdentifier(expression, binding, strictModeChanged);
            const { name  } = expression;
            if (checkClashes) {
                if (checkClashes.has(name)) this.raise(Errors.ParamDupe, {
                    at: expression
                });
                else checkClashes.add(name);
            }
            return;
        }
        const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === true) return;
        if (validity === false) {
            const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
            this.raise(ParseErrorClass, {
                at: expression,
                ancestor
            });
            return;
        }
        const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [
            validity,
            type === "ParenthesizedExpression"
        ];
        const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" || type === "ParenthesizedExpression" ? {
            type
        } : ancestor;
        for (const child of [].concat(expression[key]))if (child) this.checkLVal(child, {
            in: nextAncestor,
            binding,
            checkClashes,
            strictModeChanged,
            hasParenthesizedAncestor: isParenthesizedExpression
        });
    }
    checkIdentifier(at, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
            if (bindingType === BIND_NONE) this.raise(Errors.StrictEvalArguments, {
                at,
                referenceName: at.name
            });
            else this.raise(Errors.StrictEvalArgumentsBinding, {
                at,
                bindingName: at.name
            });
        }
        if (bindingType & BIND_FLAGS_NO_LET_IN_LEXICAL && at.name === "let") this.raise(Errors.LetInLexicalBinding, {
            at
        });
        if (!(bindingType & BIND_NONE)) this.declareNameFromIdentifier(at, bindingType);
    }
    declareNameFromIdentifier(identifier, binding) {
        this.scope.declareName(identifier.name, binding, identifier.loc.start);
    }
    checkToRestConversion(node, allowPattern) {
        switch(node.type){
            case "ParenthesizedExpression":
                this.checkToRestConversion(node.expression, allowPattern);
                break;
            case "Identifier":
            case "MemberExpression":
                break;
            case "ArrayExpression":
            case "ObjectExpression":
                if (allowPattern) break;
            default:
                this.raise(Errors.InvalidRestAssignmentPattern, {
                    at: node
                });
        }
    }
    checkCommaAfterRest(close) {
        if (!this.match(12)) return false;
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
            at: this.state.startLoc
        });
        return true;
    }
}
const getOwn = (object, key)=>Object.hasOwnProperty.call(object, key) && object[key];
function nonNull(x) {
    if (x == null) throw new Error(`Unexpected ${x} value.`);
    return x;
}
function assert(x) {
    if (!x) throw new Error("Assert fail");
}
const TSErrors = ParseErrorEnum`typescript`({
    AbstractMethodHasImplementation: ({ methodName  })=>`Method '${methodName}' cannot have an implementation because it is marked abstract.`,
    AbstractPropertyHasInitializer: ({ propertyName  })=>`Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: ({ kind  })=>`'declare' is not allowed in ${kind}ters.`,
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: ({ modifier  })=>`Accessibility modifier already seen.`,
    DuplicateModifier: ({ modifier  })=>`Duplicate modifier: '${modifier}'.`,
    EmptyHeritageClauseType: ({ token  })=>`'${token}' list cannot be empty.`,
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: ({ modifiers  })=>`'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: ({ modifier  })=>`Index signatures cannot have an accessibility modifier ('${modifier}').`,
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: ({ modifier  })=>`'${modifier}' modifier cannot appear on a type member.`,
    InvalidModifierOnTypeParameter: ({ modifier  })=>`'${modifier}' modifier cannot appear on a type parameter.`,
    InvalidModifierOnTypeParameterPositions: ({ modifier  })=>`'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    InvalidModifiersOrder: ({ orderedModifiers  })=>`'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: ({ modifier  })=>`Private elements cannot have an accessibility modifier ('${modifier}').`,
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: ({ typeParameterName  })=>`Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: ({ type  })=>`Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
});
function keywordTypeFromName(value) {
    switch(value){
        case "any":
            return "TSAnyKeyword";
        case "boolean":
            return "TSBooleanKeyword";
        case "bigint":
            return "TSBigIntKeyword";
        case "never":
            return "TSNeverKeyword";
        case "number":
            return "TSNumberKeyword";
        case "object":
            return "TSObjectKeyword";
        case "string":
            return "TSStringKeyword";
        case "symbol":
            return "TSSymbolKeyword";
        case "undefined":
            return "TSUndefinedKeyword";
        case "unknown":
            return "TSUnknownKeyword";
        default:
            return undefined;
    }
}
function tsIsAccessModifier(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
}
function tsIsVarianceAnnotations(modifier) {
    return modifier === "in" || modifier === "out";
}
var typescript = (superClass)=>class TypeScriptParserMixin extends superClass {
        constructor(...args){
            super(...args);
            this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
                allowedModifiers: [
                    "in",
                    "out"
                ],
                disallowedModifiers: [
                    "const",
                    "public",
                    "private",
                    "protected",
                    "readonly",
                    "declare",
                    "abstract",
                    "override"
                ],
                errorTemplate: TSErrors.InvalidModifierOnTypeParameter
            });
            this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
                allowedModifiers: [
                    "const"
                ],
                disallowedModifiers: [
                    "in",
                    "out"
                ],
                errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
            });
            this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
                allowedModifiers: [
                    "in",
                    "out",
                    "const"
                ],
                disallowedModifiers: [
                    "public",
                    "private",
                    "protected",
                    "readonly",
                    "declare",
                    "abstract",
                    "override"
                ],
                errorTemplate: TSErrors.InvalidModifierOnTypeParameter
            });
        }
        getScopeHandler() {
            return TypeScriptScopeHandler;
        }
        tsIsIdentifier() {
            return tokenIsIdentifier(this.state.type);
        }
        tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
        }
        tsNextTokenCanFollowModifier() {
            this.next();
            return this.tsTokenCanFollowModifier();
        }
        tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
            if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return undefined;
            const modifier = this.state.value;
            if (allowedModifiers.indexOf(modifier) !== -1) {
                if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) return undefined;
                if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return modifier;
            }
            return undefined;
        }
        tsParseModifiers({ allowedModifiers , disallowedModifiers , stopOnStartOfClassStaticBlock , errorTemplate =TSErrors.InvalidModifierOnTypeMember  }, modified) {
            const enforceOrder = (loc, modifier, before, after)=>{
                if (modifier === before && modified[after]) this.raise(TSErrors.InvalidModifiersOrder, {
                    at: loc,
                    orderedModifiers: [
                        before,
                        after
                    ]
                });
            };
            const incompatible = (loc, modifier, mod1, mod2)=>{
                if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) this.raise(TSErrors.IncompatibleModifiers, {
                    at: loc,
                    modifiers: [
                        mod1,
                        mod2
                    ]
                });
            };
            for(;;){
                const { startLoc  } = this.state;
                const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
                if (!modifier) break;
                if (tsIsAccessModifier(modifier)) {
                    if (modified.accessibility) this.raise(TSErrors.DuplicateAccessibilityModifier, {
                        at: startLoc,
                        modifier
                    });
                    else {
                        enforceOrder(startLoc, modifier, modifier, "override");
                        enforceOrder(startLoc, modifier, modifier, "static");
                        enforceOrder(startLoc, modifier, modifier, "readonly");
                        modified.accessibility = modifier;
                    }
                } else if (tsIsVarianceAnnotations(modifier)) {
                    if (modified[modifier]) this.raise(TSErrors.DuplicateModifier, {
                        at: startLoc,
                        modifier
                    });
                    modified[modifier] = true;
                    enforceOrder(startLoc, modifier, "in", "out");
                } else {
                    if (Object.hasOwnProperty.call(modified, modifier)) this.raise(TSErrors.DuplicateModifier, {
                        at: startLoc,
                        modifier
                    });
                    else {
                        enforceOrder(startLoc, modifier, "static", "readonly");
                        enforceOrder(startLoc, modifier, "static", "override");
                        enforceOrder(startLoc, modifier, "override", "readonly");
                        enforceOrder(startLoc, modifier, "abstract", "override");
                        incompatible(startLoc, modifier, "declare", "override");
                        incompatible(startLoc, modifier, "static", "abstract");
                    }
                    modified[modifier] = true;
                }
                if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) this.raise(errorTemplate, {
                    at: startLoc,
                    modifier
                });
            }
        }
        tsIsListTerminator(kind) {
            switch(kind){
                case "EnumMembers":
                case "TypeMembers":
                    return this.match(8);
                case "HeritageClauseElement":
                    return this.match(5);
                case "TupleElementTypes":
                    return this.match(3);
                case "TypeParametersOrArguments":
                    return this.match(48);
            }
        }
        tsParseList(kind, parseElement) {
            const result = [];
            while(!this.tsIsListTerminator(kind))result.push(parseElement());
            return result;
        }
        tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
            return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
        }
        tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
            const result = [];
            let trailingCommaPos = -1;
            for(;;){
                if (this.tsIsListTerminator(kind)) break;
                trailingCommaPos = -1;
                const element = parseElement();
                if (element == null) return undefined;
                result.push(element);
                if (this.eat(12)) {
                    trailingCommaPos = this.state.lastTokStart;
                    continue;
                }
                if (this.tsIsListTerminator(kind)) break;
                if (expectSuccess) this.expect(12);
                return undefined;
            }
            if (refTrailingCommaPos) refTrailingCommaPos.value = trailingCommaPos;
            return result;
        }
        tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
            if (!skipFirstToken) {
                if (bracket) this.expect(0);
                else this.expect(47);
            }
            const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
            if (bracket) this.expect(3);
            else this.expect(48);
            return result;
        }
        tsParseImportType() {
            const node = this.startNode();
            this.expect(83);
            this.expect(10);
            if (!this.match(131)) this.raise(TSErrors.UnsupportedImportTypeArgument, {
                at: this.state.startLoc
            });
            node.argument = super.parseExprAtom();
            this.expect(11);
            if (this.eat(16)) node.qualifier = this.tsParseEntityName();
            if (this.match(47)) node.typeParameters = this.tsParseTypeArguments();
            return this.finishNode(node, "TSImportType");
        }
        tsParseEntityName(allowReservedWords = true) {
            let entity = this.parseIdentifier(allowReservedWords);
            while(this.eat(16)){
                const node = this.startNodeAtNode(entity);
                node.left = entity;
                node.right = this.parseIdentifier(allowReservedWords);
                entity = this.finishNode(node, "TSQualifiedName");
            }
            return entity;
        }
        tsParseTypeReference() {
            const node = this.startNode();
            node.typeName = this.tsParseEntityName();
            if (!this.hasPrecedingLineBreak() && this.match(47)) node.typeParameters = this.tsParseTypeArguments();
            return this.finishNode(node, "TSTypeReference");
        }
        tsParseThisTypePredicate(lhs) {
            this.next();
            const node = this.startNodeAtNode(lhs);
            node.parameterName = lhs;
            node.typeAnnotation = this.tsParseTypeAnnotation(false);
            node.asserts = false;
            return this.finishNode(node, "TSTypePredicate");
        }
        tsParseThisTypeNode() {
            const node = this.startNode();
            this.next();
            return this.finishNode(node, "TSThisType");
        }
        tsParseTypeQuery() {
            const node = this.startNode();
            this.expect(87);
            if (this.match(83)) node.exprName = this.tsParseImportType();
            else node.exprName = this.tsParseEntityName();
            if (!this.hasPrecedingLineBreak() && this.match(47)) node.typeParameters = this.tsParseTypeArguments();
            return this.finishNode(node, "TSTypeQuery");
        }
        tsParseTypeParameter(parseModifiers) {
            const node = this.startNode();
            parseModifiers(node);
            node.name = this.tsParseTypeParameterName();
            node.constraint = this.tsEatThenParseType(81);
            node.default = this.tsEatThenParseType(29);
            return this.finishNode(node, "TSTypeParameter");
        }
        tsTryParseTypeParameters(parseModifiers) {
            if (this.match(47)) return this.tsParseTypeParameters(parseModifiers);
        }
        tsParseTypeParameters(parseModifiers) {
            const node = this.startNode();
            if (this.match(47) || this.match(140)) this.next();
            else this.unexpected();
            const refTrailingCommaPos = {
                value: -1
            };
            node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
            if (node.params.length === 0) this.raise(TSErrors.EmptyTypeParameters, {
                at: node
            });
            if (refTrailingCommaPos.value !== -1) this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
            return this.finishNode(node, "TSTypeParameterDeclaration");
        }
        tsFillSignature(returnToken, signature) {
            const returnTokenRequired = returnToken === 19;
            const paramsKey = "parameters";
            const returnTypeKey = "typeAnnotation";
            signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            this.expect(10);
            signature[paramsKey] = this.tsParseBindingListForSignature();
            if (returnTokenRequired) signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
            else if (this.match(returnToken)) signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
        tsParseBindingListForSignature() {
            const list = super.parseBindingList(11, 41, 2);
            for (const pattern of list){
                const { type  } = pattern;
                if (type === "AssignmentPattern" || type === "TSParameterProperty") this.raise(TSErrors.UnsupportedSignatureParameterKind, {
                    at: pattern,
                    type
                });
            }
            return list;
        }
        tsParseTypeMemberSemicolon() {
            if (!this.eat(12) && !this.isLineTerminator()) this.expect(13);
        }
        tsParseSignatureMember(kind, node) {
            this.tsFillSignature(14, node);
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(node, kind);
        }
        tsIsUnambiguouslyIndexSignature() {
            this.next();
            if (tokenIsIdentifier(this.state.type)) {
                this.next();
                return this.match(14);
            }
            return false;
        }
        tsTryParseIndexSignature(node) {
            if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
            this.expect(0);
            const id = this.parseIdentifier();
            id.typeAnnotation = this.tsParseTypeAnnotation();
            this.resetEndLocation(id);
            this.expect(3);
            node.parameters = [
                id
            ];
            const type = this.tsTryParseTypeAnnotation();
            if (type) node.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(node, "TSIndexSignature");
        }
        tsParsePropertyOrMethodSignature(node, readonly) {
            if (this.eat(17)) node.optional = true;
            const nodeAny = node;
            if (this.match(10) || this.match(47)) {
                if (readonly) this.raise(TSErrors.ReadonlyForMethodSignature, {
                    at: node
                });
                const method = nodeAny;
                if (method.kind && this.match(47)) this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
                    at: this.state.curPosition()
                });
                this.tsFillSignature(14, method);
                this.tsParseTypeMemberSemicolon();
                const paramsKey = "parameters";
                const returnTypeKey = "typeAnnotation";
                if (method.kind === "get") {
                    if (method[paramsKey].length > 0) {
                        this.raise(Errors.BadGetterArity, {
                            at: this.state.curPosition()
                        });
                        if (this.isThisParam(method[paramsKey][0])) this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                            at: this.state.curPosition()
                        });
                    }
                } else if (method.kind === "set") {
                    if (method[paramsKey].length !== 1) this.raise(Errors.BadSetterArity, {
                        at: this.state.curPosition()
                    });
                    else {
                        const firstParameter = method[paramsKey][0];
                        if (this.isThisParam(firstParameter)) this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                            at: this.state.curPosition()
                        });
                        if (firstParameter.type === "Identifier" && firstParameter.optional) this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                            at: this.state.curPosition()
                        });
                        if (firstParameter.type === "RestElement") this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                            at: this.state.curPosition()
                        });
                    }
                    if (method[returnTypeKey]) this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                        at: method[returnTypeKey]
                    });
                } else method.kind = "method";
                return this.finishNode(method, "TSMethodSignature");
            } else {
                const property = nodeAny;
                if (readonly) property.readonly = true;
                const type = this.tsTryParseTypeAnnotation();
                if (type) property.typeAnnotation = type;
                this.tsParseTypeMemberSemicolon();
                return this.finishNode(property, "TSPropertySignature");
            }
        }
        tsParseTypeMember() {
            const node = this.startNode();
            if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
            if (this.match(77)) {
                const id = this.startNode();
                this.next();
                if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
                else {
                    node.key = this.createIdentifier(id, "new");
                    return this.tsParsePropertyOrMethodSignature(node, false);
                }
            }
            this.tsParseModifiers({
                allowedModifiers: [
                    "readonly"
                ],
                disallowedModifiers: [
                    "declare",
                    "abstract",
                    "private",
                    "protected",
                    "public",
                    "static",
                    "override"
                ]
            }, node);
            const idx = this.tsTryParseIndexSignature(node);
            if (idx) return idx;
            super.parsePropertyName(node);
            if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
                node.kind = node.key.name;
                super.parsePropertyName(node);
            }
            return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
        }
        tsParseTypeLiteral() {
            const node = this.startNode();
            node.members = this.tsParseObjectTypeMembers();
            return this.finishNode(node, "TSTypeLiteral");
        }
        tsParseObjectTypeMembers() {
            this.expect(5);
            const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            this.expect(8);
            return members;
        }
        tsIsStartOfMappedType() {
            this.next();
            if (this.eat(53)) return this.isContextual(120);
            if (this.isContextual(120)) this.next();
            if (!this.match(0)) return false;
            this.next();
            if (!this.tsIsIdentifier()) return false;
            this.next();
            return this.match(58);
        }
        tsParseMappedTypeParameter() {
            const node = this.startNode();
            node.name = this.tsParseTypeParameterName();
            node.constraint = this.tsExpectThenParseType(58);
            return this.finishNode(node, "TSTypeParameter");
        }
        tsParseMappedType() {
            const node = this.startNode();
            this.expect(5);
            if (this.match(53)) {
                node.readonly = this.state.value;
                this.next();
                this.expectContextual(120);
            } else if (this.eatContextual(120)) node.readonly = true;
            this.expect(0);
            node.typeParameter = this.tsParseMappedTypeParameter();
            node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
            this.expect(3);
            if (this.match(53)) {
                node.optional = this.state.value;
                this.next();
                this.expect(17);
            } else if (this.eat(17)) node.optional = true;
            node.typeAnnotation = this.tsTryParseType();
            this.semicolon();
            this.expect(8);
            return this.finishNode(node, "TSMappedType");
        }
        tsParseTupleType() {
            const node = this.startNode();
            node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let seenOptionalElement = false;
            let labeledElements = null;
            node.elementTypes.forEach((elementNode)=>{
                var _labeledElements;
                const { type  } = elementNode;
                if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) this.raise(TSErrors.OptionalTypeBeforeRequired, {
                    at: elementNode
                });
                seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
                let checkType = type;
                if (type === "TSRestType") {
                    elementNode = elementNode.typeAnnotation;
                    checkType = elementNode.type;
                }
                const isLabeled = checkType === "TSNamedTupleMember";
                (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;
                if (labeledElements !== isLabeled) this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
                    at: elementNode
                });
            });
            return this.finishNode(node, "TSTupleType");
        }
        tsParseTupleElementType() {
            const { startLoc  } = this.state;
            const rest = this.eat(21);
            let labeled;
            let label;
            let optional;
            let type;
            const isWord = tokenIsKeywordOrIdentifier(this.state.type);
            const chAfterWord = isWord ? this.lookaheadCharCode() : null;
            if (chAfterWord === 58) {
                labeled = true;
                optional = false;
                label = this.parseIdentifier(true);
                this.expect(14);
                type = this.tsParseType();
            } else if (chAfterWord === 63) {
                optional = true;
                const startLoc = this.state.startLoc;
                const wordName = this.state.value;
                const typeOrLabel = this.tsParseNonArrayType();
                if (this.lookaheadCharCode() === 58) {
                    labeled = true;
                    label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
                    this.expect(17);
                    this.expect(14);
                    type = this.tsParseType();
                } else {
                    labeled = false;
                    type = typeOrLabel;
                    this.expect(17);
                }
            } else {
                type = this.tsParseType();
                optional = this.eat(17);
                labeled = this.eat(14);
            }
            if (labeled) {
                let labeledNode;
                if (label) {
                    labeledNode = this.startNodeAtNode(label);
                    labeledNode.optional = optional;
                    labeledNode.label = label;
                    labeledNode.elementType = type;
                    if (this.eat(17)) {
                        labeledNode.optional = true;
                        this.raise(TSErrors.TupleOptionalAfterType, {
                            at: this.state.lastTokStartLoc
                        });
                    }
                } else {
                    labeledNode = this.startNodeAtNode(type);
                    labeledNode.optional = optional;
                    this.raise(TSErrors.InvalidTupleMemberLabel, {
                        at: type
                    });
                    labeledNode.label = type;
                    labeledNode.elementType = this.tsParseType();
                }
                type = this.finishNode(labeledNode, "TSNamedTupleMember");
            } else if (optional) {
                const optionalTypeNode = this.startNodeAtNode(type);
                optionalTypeNode.typeAnnotation = type;
                type = this.finishNode(optionalTypeNode, "TSOptionalType");
            }
            if (rest) {
                const restNode = this.startNodeAt(startLoc);
                restNode.typeAnnotation = type;
                type = this.finishNode(restNode, "TSRestType");
            }
            return type;
        }
        tsParseParenthesizedType() {
            const node = this.startNode();
            this.expect(10);
            node.typeAnnotation = this.tsParseType();
            this.expect(11);
            return this.finishNode(node, "TSParenthesizedType");
        }
        tsParseFunctionOrConstructorType(type, abstract) {
            const node = this.startNode();
            if (type === "TSConstructorType") {
                node.abstract = !!abstract;
                if (abstract) this.next();
                this.next();
            }
            this.tsInAllowConditionalTypesContext(()=>this.tsFillSignature(19, node));
            return this.finishNode(node, type);
        }
        tsParseLiteralTypeNode() {
            const node = this.startNode();
            switch(this.state.type){
                case 132:
                case 133:
                case 131:
                case 85:
                case 86:
                    node.literal = super.parseExprAtom();
                    break;
                default:
                    this.unexpected();
            }
            return this.finishNode(node, "TSLiteralType");
        }
        tsParseTemplateLiteralType() {
            const node = this.startNode();
            node.literal = super.parseTemplate(false);
            return this.finishNode(node, "TSLiteralType");
        }
        parseTemplateSubstitution() {
            if (this.state.inType) return this.tsParseType();
            return super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
            const thisKeyword = this.tsParseThisTypeNode();
            if (this.isContextual(114) && !this.hasPrecedingLineBreak()) return this.tsParseThisTypePredicate(thisKeyword);
            else return thisKeyword;
        }
        tsParseNonArrayType() {
            switch(this.state.type){
                case 131:
                case 132:
                case 133:
                case 85:
                case 86:
                    return this.tsParseLiteralTypeNode();
                case 53:
                    if (this.state.value === "-") {
                        const node = this.startNode();
                        const nextToken = this.lookahead();
                        if (nextToken.type !== 132 && nextToken.type !== 133) this.unexpected();
                        node.literal = this.parseMaybeUnary();
                        return this.finishNode(node, "TSLiteralType");
                    }
                    break;
                case 78:
                    return this.tsParseThisTypeOrThisTypePredicate();
                case 87:
                    return this.tsParseTypeQuery();
                case 83:
                    return this.tsParseImportType();
                case 5:
                    return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                case 0:
                    return this.tsParseTupleType();
                case 10:
                    return this.tsParseParenthesizedType();
                case 25:
                case 24:
                    return this.tsParseTemplateLiteralType();
                default:
                    {
                        const { type  } = this.state;
                        if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                            const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {
                                const node = this.startNode();
                                this.next();
                                return this.finishNode(node, nodeType);
                            }
                            return this.tsParseTypeReference();
                        }
                    }
            }
            this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
            let type = this.tsParseNonArrayType();
            while(!this.hasPrecedingLineBreak() && this.eat(0))if (this.match(3)) {
                const node = this.startNodeAtNode(type);
                node.elementType = type;
                this.expect(3);
                type = this.finishNode(node, "TSArrayType");
            } else {
                const node = this.startNodeAtNode(type);
                node.objectType = type;
                node.indexType = this.tsParseType();
                this.expect(3);
                type = this.finishNode(node, "TSIndexedAccessType");
            }
            return type;
        }
        tsParseTypeOperator() {
            const node = this.startNode();
            const operator = this.state.value;
            this.next();
            node.operator = operator;
            node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
            if (operator === "readonly") this.tsCheckTypeAnnotationForReadOnly(node);
            return this.finishNode(node, "TSTypeOperator");
        }
        tsCheckTypeAnnotationForReadOnly(node) {
            switch(node.typeAnnotation.type){
                case "TSTupleType":
                case "TSArrayType":
                    return;
                default:
                    this.raise(TSErrors.UnexpectedReadonly, {
                        at: node
                    });
            }
        }
        tsParseInferType() {
            const node = this.startNode();
            this.expectContextual(113);
            const typeParameter = this.startNode();
            typeParameter.name = this.tsParseTypeParameterName();
            typeParameter.constraint = this.tsTryParse(()=>this.tsParseConstraintForInferType());
            node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
            return this.finishNode(node, "TSInferType");
        }
        tsParseConstraintForInferType() {
            if (this.eat(81)) {
                const constraint = this.tsInDisallowConditionalTypesContext(()=>this.tsParseType());
                if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return constraint;
            }
        }
        tsParseTypeOperatorOrHigher() {
            const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
            return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(()=>this.tsParseArrayTypeOrHigher());
        }
        tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
            const node = this.startNode();
            const hasLeadingOperator = this.eat(operator);
            const types = [];
            do types.push(parseConstituentType());
            while (this.eat(operator));
            if (types.length === 1 && !hasLeadingOperator) return types[0];
            node.types = types;
            return this.finishNode(node, kind);
        }
        tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
        }
        tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
        }
        tsIsStartOfFunctionType() {
            if (this.match(47)) return true;
            return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
        tsSkipParameterStart() {
            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                this.next();
                return true;
            }
            if (this.match(5)) {
                const { errors  } = this.state;
                const previousErrorCount = errors.length;
                try {
                    this.parseObjectLike(8, true);
                    return errors.length === previousErrorCount;
                } catch (_unused) {
                    return false;
                }
            }
            if (this.match(0)) {
                this.next();
                const { errors  } = this.state;
                const previousErrorCount = errors.length;
                try {
                    super.parseBindingList(3, 93, 1);
                    return errors.length === previousErrorCount;
                } catch (_unused2) {
                    return false;
                }
            }
            return false;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
            this.next();
            if (this.match(11) || this.match(21)) return true;
            if (this.tsSkipParameterStart()) {
                if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) return true;
                if (this.match(11)) {
                    this.next();
                    if (this.match(19)) return true;
                }
            }
            return false;
        }
        tsParseTypeOrTypePredicateAnnotation(returnToken) {
            return this.tsInType(()=>{
                const t = this.startNode();
                this.expect(returnToken);
                const node = this.startNode();
                const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                if (asserts && this.match(78)) {
                    let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
                    if (thisTypePredicate.type === "TSThisType") {
                        node.parameterName = thisTypePredicate;
                        node.asserts = true;
                        node.typeAnnotation = null;
                        thisTypePredicate = this.finishNode(node, "TSTypePredicate");
                    } else {
                        this.resetStartLocationFromNode(thisTypePredicate, node);
                        thisTypePredicate.asserts = true;
                    }
                    t.typeAnnotation = thisTypePredicate;
                    return this.finishNode(t, "TSTypeAnnotation");
                }
                const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                if (!typePredicateVariable) {
                    if (!asserts) return this.tsParseTypeAnnotation(false, t);
                    node.parameterName = this.parseIdentifier();
                    node.asserts = asserts;
                    node.typeAnnotation = null;
                    t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
                    return this.finishNode(t, "TSTypeAnnotation");
                }
                const type = this.tsParseTypeAnnotation(false);
                node.parameterName = typePredicateVariable;
                node.typeAnnotation = type;
                node.asserts = asserts;
                t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
                return this.finishNode(t, "TSTypeAnnotation");
            });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        tsTryParseTypeAnnotation() {
            if (this.match(14)) return this.tsParseTypeAnnotation();
        }
        tsTryParseType() {
            return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
            const id = this.parseIdentifier();
            if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {
                this.next();
                return id;
            }
        }
        tsParseTypePredicateAsserts() {
            if (this.state.type !== 107) return false;
            const containsEsc = this.state.containsEsc;
            this.next();
            if (!tokenIsIdentifier(this.state.type) && !this.match(78)) return false;
            if (containsEsc) this.raise(Errors.InvalidEscapedReservedWord, {
                at: this.state.lastTokStartLoc,
                reservedWord: "asserts"
            });
            return true;
        }
        tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
            this.tsInType(()=>{
                if (eatColon) this.expect(14);
                t.typeAnnotation = this.tsParseType();
            });
            return this.finishNode(t, "TSTypeAnnotation");
        }
        tsParseType() {
            assert(this.state.inType);
            const type = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return type;
            const node = this.startNodeAtNode(type);
            node.checkType = type;
            node.extendsType = this.tsInDisallowConditionalTypesContext(()=>this.tsParseNonConditionalType());
            this.expect(17);
            node.trueType = this.tsInAllowConditionalTypesContext(()=>this.tsParseType());
            this.expect(14);
            node.falseType = this.tsInAllowConditionalTypesContext(()=>this.tsParseType());
            return this.finishNode(node, "TSConditionalType");
        }
        isAbstractConstructorSignature() {
            return this.isContextual(122) && this.lookahead().type === 77;
        }
        tsParseNonConditionalType() {
            if (this.tsIsStartOfFunctionType()) return this.tsParseFunctionOrConstructorType("TSFunctionType");
            if (this.match(77)) return this.tsParseFunctionOrConstructorType("TSConstructorType");
            else if (this.isAbstractConstructorSignature()) return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
            return this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
            if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) this.raise(TSErrors.ReservedTypeAssertion, {
                at: this.state.startLoc
            });
            const node = this.startNode();
            node.typeAnnotation = this.tsInType(()=>{
                this.next();
                return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
            });
            this.expect(48);
            node.expression = this.parseMaybeUnary();
            return this.finishNode(node, "TSTypeAssertion");
        }
        tsParseHeritageClause(token) {
            const originalStartLoc = this.state.startLoc;
            const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", ()=>{
                const node = this.startNode();
                node.expression = this.tsParseEntityName();
                if (this.match(47)) node.typeParameters = this.tsParseTypeArguments();
                return this.finishNode(node, "TSExpressionWithTypeArguments");
            });
            if (!delimitedList.length) this.raise(TSErrors.EmptyHeritageClauseType, {
                at: originalStartLoc,
                token
            });
            return delimitedList;
        }
        tsParseInterfaceDeclaration(node, properties = {}) {
            if (this.hasFollowingLineBreak()) return null;
            this.expectContextual(127);
            if (properties.declare) node.declare = true;
            if (tokenIsIdentifier(this.state.type)) {
                node.id = this.parseIdentifier();
                this.checkIdentifier(node.id, BIND_TS_INTERFACE);
            } else {
                node.id = null;
                this.raise(TSErrors.MissingInterfaceName, {
                    at: this.state.startLoc
                });
            }
            node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            if (this.eat(81)) node.extends = this.tsParseHeritageClause("extends");
            const body = this.startNode();
            body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
            node.body = this.finishNode(body, "TSInterfaceBody");
            return this.finishNode(node, "TSInterfaceDeclaration");
        }
        tsParseTypeAliasDeclaration(node) {
            node.id = this.parseIdentifier();
            this.checkIdentifier(node.id, BIND_TS_TYPE);
            node.typeAnnotation = this.tsInType(()=>{
                node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
                this.expect(29);
                if (this.isContextual(112) && this.lookahead().type !== 16) {
                    const node = this.startNode();
                    this.next();
                    return this.finishNode(node, "TSIntrinsicKeyword");
                }
                return this.tsParseType();
            });
            this.semicolon();
            return this.finishNode(node, "TSTypeAliasDeclaration");
        }
        tsInNoContext(cb) {
            const oldContext = this.state.context;
            this.state.context = [
                oldContext[0]
            ];
            try {
                return cb();
            } finally{
                this.state.context = oldContext;
            }
        }
        tsInType(cb) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            try {
                return cb();
            } finally{
                this.state.inType = oldInType;
            }
        }
        tsInDisallowConditionalTypesContext(cb) {
            const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = true;
            try {
                return cb();
            } finally{
                this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
            }
        }
        tsInAllowConditionalTypesContext(cb) {
            const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = false;
            try {
                return cb();
            } finally{
                this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
            }
        }
        tsEatThenParseType(token) {
            if (this.match(token)) return this.tsNextThenParseType();
        }
        tsExpectThenParseType(token) {
            return this.tsInType(()=>{
                this.expect(token);
                return this.tsParseType();
            });
        }
        tsNextThenParseType() {
            return this.tsInType(()=>{
                this.next();
                return this.tsParseType();
            });
        }
        tsParseEnumMember() {
            const node = this.startNode();
            node.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
            if (this.eat(29)) node.initializer = super.parseMaybeAssignAllowIn();
            return this.finishNode(node, "TSEnumMember");
        }
        tsParseEnumDeclaration(node, properties = {}) {
            if (properties.const) node.const = true;
            if (properties.declare) node.declare = true;
            this.expectContextual(124);
            node.id = this.parseIdentifier();
            this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
            this.expect(5);
            node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
            this.expect(8);
            return this.finishNode(node, "TSEnumDeclaration");
        }
        tsParseModuleBlock() {
            const node = this.startNode();
            this.scope.enter(SCOPE_OTHER);
            this.expect(5);
            super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);
            this.scope.exit();
            return this.finishNode(node, "TSModuleBlock");
        }
        tsParseModuleOrNamespaceDeclaration(node, nested = false) {
            node.id = this.parseIdentifier();
            if (!nested) this.checkIdentifier(node.id, BIND_TS_NAMESPACE);
            if (this.eat(16)) {
                const inner = this.startNode();
                this.tsParseModuleOrNamespaceDeclaration(inner, true);
                node.body = inner;
            } else {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                node.body = this.tsParseModuleBlock();
                this.prodParam.exit();
                this.scope.exit();
            }
            return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseAmbientExternalModuleDeclaration(node) {
            if (this.isContextual(110)) {
                node.global = true;
                node.id = this.parseIdentifier();
            } else if (this.match(131)) node.id = super.parseStringLiteral(this.state.value);
            else this.unexpected();
            if (this.match(5)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                node.body = this.tsParseModuleBlock();
                this.prodParam.exit();
                this.scope.exit();
            } else this.semicolon();
            return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
            node.isExport = isExport || false;
            node.id = maybeDefaultIdentifier || this.parseIdentifier();
            this.checkIdentifier(node.id, BIND_FLAGS_TS_IMPORT);
            this.expect(29);
            const moduleReference = this.tsParseModuleReference();
            if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") this.raise(TSErrors.ImportAliasHasImportType, {
                at: moduleReference
            });
            node.moduleReference = moduleReference;
            this.semicolon();
            return this.finishNode(node, "TSImportEqualsDeclaration");
        }
        tsIsExternalModuleReference() {
            return this.isContextual(117) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
        tsParseExternalModuleReference() {
            const node = this.startNode();
            this.expectContextual(117);
            this.expect(10);
            if (!this.match(131)) this.unexpected();
            node.expression = super.parseExprAtom();
            this.expect(11);
            this.sawUnambiguousESM = true;
            return this.finishNode(node, "TSExternalModuleReference");
        }
        tsLookAhead(f) {
            const state = this.state.clone();
            const res = f();
            this.state = state;
            return res;
        }
        tsTryParseAndCatch(f) {
            const result = this.tryParse((abort)=>f() || abort());
            if (result.aborted || !result.node) return;
            if (result.error) this.state = result.failState;
            return result.node;
        }
        tsTryParse(f) {
            const state = this.state.clone();
            const result = f();
            if (result !== undefined && result !== false) return result;
            this.state = state;
        }
        tsTryParseDeclare(nany) {
            if (this.isLineTerminator()) return;
            let startType = this.state.type;
            let kind;
            if (this.isContextual(99)) {
                startType = 74;
                kind = "let";
            }
            return this.tsInAmbientContext(()=>{
                switch(startType){
                    case 68:
                        nany.declare = true;
                        return super.parseFunctionStatement(nany, false, false);
                    case 80:
                        nany.declare = true;
                        return this.parseClass(nany, true, false);
                    case 124:
                        return this.tsParseEnumDeclaration(nany, {
                            declare: true
                        });
                    case 110:
                        return this.tsParseAmbientExternalModuleDeclaration(nany);
                    case 75:
                    case 74:
                        if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                            nany.declare = true;
                            return this.parseVarStatement(nany, kind || this.state.value, true);
                        }
                        this.expect(75);
                        return this.tsParseEnumDeclaration(nany, {
                            const: true,
                            declare: true
                        });
                    case 127:
                        {
                            const result = this.tsParseInterfaceDeclaration(nany, {
                                declare: true
                            });
                            if (result) return result;
                        }
                    default:
                        if (tokenIsIdentifier(startType)) return this.tsParseDeclaration(nany, this.state.value, true, null);
                }
            });
        }
        tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
        }
        tsParseExpressionStatement(node, expr, decorators) {
            switch(expr.name){
                case "declare":
                    {
                        const declaration = this.tsTryParseDeclare(node);
                        if (declaration) declaration.declare = true;
                        return declaration;
                    }
                case "global":
                    if (this.match(5)) {
                        this.scope.enter(SCOPE_TS_MODULE);
                        this.prodParam.enter(PARAM);
                        const mod = node;
                        mod.global = true;
                        mod.id = expr;
                        mod.body = this.tsParseModuleBlock();
                        this.scope.exit();
                        this.prodParam.exit();
                        return this.finishNode(mod, "TSModuleDeclaration");
                    }
                    break;
                default:
                    return this.tsParseDeclaration(node, expr.name, false, decorators);
            }
        }
        tsParseDeclaration(node, value, next, decorators) {
            switch(value){
                case "abstract":
                    if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) return this.tsParseAbstractDeclaration(node, decorators);
                    break;
                case "module":
                    if (this.tsCheckLineTerminator(next)) {
                        if (this.match(131)) return this.tsParseAmbientExternalModuleDeclaration(node);
                        else if (tokenIsIdentifier(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(node);
                    }
                    break;
                case "namespace":
                    if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(node);
                    break;
                case "type":
                    if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) return this.tsParseTypeAliasDeclaration(node);
                    break;
            }
        }
        tsCheckLineTerminator(next) {
            if (next) {
                if (this.hasFollowingLineBreak()) return false;
                this.next();
                return true;
            }
            return !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(startLoc) {
            if (!this.match(47)) return;
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const res = this.tsTryParseAndCatch(()=>{
                const node = this.startNodeAt(startLoc);
                node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
                super.parseFunctionParams(node);
                node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
                this.expect(19);
                return node;
            });
            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
            if (!res) return;
            return super.parseArrowExpression(res, null, true);
        }
        tsParseTypeArgumentsInExpression() {
            if (this.reScan_lt() !== 47) return;
            return this.tsParseTypeArguments();
        }
        tsParseTypeArguments() {
            const node = this.startNode();
            node.params = this.tsInType(()=>this.tsInNoContext(()=>{
                    this.expect(47);
                    return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
                }));
            if (node.params.length === 0) this.raise(TSErrors.EmptyTypeArguments, {
                at: node
            });
            else if (!this.state.inType && this.curContext() === types.brace) this.reScan_lt_gt();
            this.expect(48);
            return this.finishNode(node, "TSTypeParameterInstantiation");
        }
        tsIsDeclarationStart() {
            return tokenIsTSDeclarationStart(this.state.type);
        }
        isExportDefaultSpecifier() {
            if (this.tsIsDeclarationStart()) return false;
            return super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(flags, decorators) {
            const startLoc = this.state.startLoc;
            const modified = {};
            this.tsParseModifiers({
                allowedModifiers: [
                    "public",
                    "private",
                    "protected",
                    "override",
                    "readonly"
                ]
            }, modified);
            const accessibility = modified.accessibility;
            const override = modified.override;
            const readonly = modified.readonly;
            if (!(flags & 4) && (accessibility || readonly || override)) this.raise(TSErrors.UnexpectedParameterModifier, {
                at: startLoc
            });
            const left = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(left, flags);
            const elt = this.parseMaybeDefault(left.loc.start, left);
            if (accessibility || readonly || override) {
                const pp = this.startNodeAt(startLoc);
                if (decorators.length) pp.decorators = decorators;
                if (accessibility) pp.accessibility = accessibility;
                if (readonly) pp.readonly = readonly;
                if (override) pp.override = override;
                if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") this.raise(TSErrors.UnsupportedParameterPropertyKind, {
                    at: pp
                });
                pp.parameter = elt;
                return this.finishNode(pp, "TSParameterProperty");
            }
            if (decorators.length) left.decorators = decorators;
            return elt;
        }
        isSimpleParameter(node) {
            return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
        }
        tsDisallowOptionalPattern(node) {
            for (const param of node.params)if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) this.raise(TSErrors.PatternIsOptional, {
                at: param
            });
        }
        setArrowFunctionParameters(node, params, trailingCommaLoc) {
            super.setArrowFunctionParameters(node, params, trailingCommaLoc);
            this.tsDisallowOptionalPattern(node);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
            if (this.match(14)) node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;
            if (bodilessType && !this.match(5) && this.isLineTerminator()) return this.finishNode(node, bodilessType);
            if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
                this.raise(TSErrors.DeclareFunctionHasImplementation, {
                    at: node
                });
                if (node.declare) return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
            }
            this.tsDisallowOptionalPattern(node);
            return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        registerFunctionStatementId(node) {
            if (!node.body && node.id) this.checkIdentifier(node.id, BIND_TS_AMBIENT);
            else super.registerFunctionStatementId(node);
        }
        tsCheckForInvalidTypeCasts(items) {
            items.forEach((node)=>{
                if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") this.raise(TSErrors.UnexpectedTypeAnnotation, {
                    at: node.typeAnnotation
                });
            });
        }
        toReferencedList(exprList, isInParens) {
            this.tsCheckForInvalidTypeCasts(exprList);
            return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
            if (node.type === "ArrayExpression") this.tsCheckForInvalidTypeCasts(node.elements);
            return node;
        }
        parseSubscript(base, startLoc, noCalls, state) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
                this.state.canStartJSXElement = false;
                this.next();
                const nonNullExpression = this.startNodeAt(startLoc);
                nonNullExpression.expression = base;
                return this.finishNode(nonNullExpression, "TSNonNullExpression");
            }
            let isOptionalCall = false;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
                if (noCalls) {
                    state.stop = true;
                    return base;
                }
                state.optionalChainMember = isOptionalCall = true;
                this.next();
            }
            if (this.match(47) || this.match(51)) {
                let missingParenErrorLoc;
                const result = this.tsTryParseAndCatch(()=>{
                    if (!noCalls && this.atPossibleAsyncArrow(base)) {
                        const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
                        if (asyncArrowFn) return asyncArrowFn;
                    }
                    const typeArguments = this.tsParseTypeArgumentsInExpression();
                    if (!typeArguments) return;
                    if (isOptionalCall && !this.match(10)) {
                        missingParenErrorLoc = this.state.curPosition();
                        return;
                    }
                    if (tokenIsTemplate(this.state.type)) {
                        const result = super.parseTaggedTemplateExpression(base, startLoc, state);
                        result.typeParameters = typeArguments;
                        return result;
                    }
                    if (!noCalls && this.eat(10)) {
                        const node = this.startNodeAt(startLoc);
                        node.callee = base;
                        node.arguments = this.parseCallExpressionArguments(11, false);
                        this.tsCheckForInvalidTypeCasts(node.arguments);
                        node.typeParameters = typeArguments;
                        if (state.optionalChainMember) node.optional = isOptionalCall;
                        return this.finishCallExpression(node, state.optionalChainMember);
                    }
                    const tokenType = this.state.type;
                    if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) return;
                    const node = this.startNodeAt(startLoc);
                    node.expression = base;
                    node.typeParameters = typeArguments;
                    return this.finishNode(node, "TSInstantiationExpression");
                });
                if (missingParenErrorLoc) this.unexpected(missingParenErrorLoc, 10);
                if (result) {
                    if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                        at: this.state.startLoc
                    });
                    return result;
                }
            }
            return super.parseSubscript(base, startLoc, noCalls, state);
        }
        parseNewCallee(node) {
            var _callee$extra;
            super.parseNewCallee(node);
            const { callee  } = node;
            if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
                node.typeParameters = callee.typeParameters;
                node.callee = callee.expression;
            }
        }
        parseExprOp(left, leftStartLoc, minPrec) {
            let isSatisfies;
            if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(118)))) {
                const node = this.startNodeAt(leftStartLoc);
                node.expression = left;
                node.typeAnnotation = this.tsInType(()=>{
                    this.next();
                    if (this.match(75)) {
                        if (isSatisfies) this.raise(Errors.UnexpectedKeyword, {
                            at: this.state.startLoc,
                            keyword: "const"
                        });
                        return this.tsParseTypeReference();
                    }
                    return this.tsParseType();
                });
                this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
                this.reScan_lt_gt();
                return this.parseExprOp(node, leftStartLoc, minPrec);
            }
            return super.parseExprOp(left, leftStartLoc, minPrec);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
            if (!this.state.isAmbientContext) super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
        checkImportReflection(node) {
            super.checkImportReflection(node);
            if (node.module && node.importKind !== "value") this.raise(TSErrors.ImportReflectionHasImportType, {
                at: node.specifiers[0].loc.start
            });
        }
        checkDuplicateExports() {}
        isPotentialImportPhase(isExport) {
            if (super.isPotentialImportPhase(isExport)) return true;
            if (this.isContextual(128)) {
                const ch = this.lookaheadCharCode();
                return isExport ? ch === 123 || ch === 42 : ch !== 61;
            }
            return !isExport && this.isContextual(87);
        }
        applyImportPhase(node, isExport, phase, loc) {
            super.applyImportPhase(node, isExport, phase, loc);
            if (isExport) node.exportKind = phase === "type" ? "type" : "value";
            else node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
        parseImport(node) {
            if (this.match(131)) {
                node.importKind = "value";
                return super.parseImport(node);
            }
            let importNode;
            if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
                node.importKind = "value";
                return this.tsParseImportEqualsDeclaration(node);
            } else if (this.isContextual(128)) {
                const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
                if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
                else importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
            } else importNode = super.parseImport(node);
            if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
                at: importNode
            });
            return importNode;
        }
        parseExport(node, decorators) {
            if (this.match(83)) {
                this.next();
                let maybeDefaultIdentifier = null;
                if (this.isContextual(128) && this.isPotentialImportPhase(false)) maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
                else node.importKind = "value";
                return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, true);
            } else if (this.eat(29)) {
                const assign = node;
                assign.expression = super.parseExpression();
                this.semicolon();
                this.sawUnambiguousESM = true;
                return this.finishNode(assign, "TSExportAssignment");
            } else if (this.eatContextual(93)) {
                const decl = node;
                this.expectContextual(126);
                decl.id = this.parseIdentifier();
                this.semicolon();
                return this.finishNode(decl, "TSNamespaceExportDeclaration");
            } else return super.parseExport(node, decorators);
        }
        isAbstractClass() {
            return this.isContextual(122) && this.lookahead().type === 80;
        }
        parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
                const cls = this.startNode();
                this.next();
                cls.abstract = true;
                return this.parseClass(cls, true, true);
            }
            if (this.match(127)) {
                const result = this.tsParseInterfaceDeclaration(this.startNode());
                if (result) return result;
            }
            return super.parseExportDefaultExpression();
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
            const { isAmbientContext  } = this.state;
            const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
            if (!isAmbientContext) return declaration;
            for (const { id , init  } of declaration.declarations){
                if (!init) continue;
                if (kind !== "const" || !!id.typeAnnotation) this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
                    at: init
                });
                else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                    at: init
                });
            }
            return declaration;
        }
        parseStatementContent(flags, decorators) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
                const node = this.startNode();
                this.expect(75);
                return this.tsParseEnumDeclaration(node, {
                    const: true
                });
            }
            if (this.isContextual(124)) return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(127)) {
                const result = this.tsParseInterfaceDeclaration(this.startNode());
                if (result) return result;
            }
            return super.parseStatementContent(flags, decorators);
        }
        parseAccessModifier() {
            return this.tsParseModifier([
                "public",
                "protected",
                "private"
            ]);
        }
        tsHasSomeModifiers(member, modifiers) {
            return modifiers.some((modifier)=>{
                if (tsIsAccessModifier(modifier)) return member.accessibility === modifier;
                return !!member[modifier];
            });
        }
        tsIsStartOfStaticBlocks() {
            return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(classBody, member, state) {
            const modifiers = [
                "declare",
                "private",
                "public",
                "protected",
                "override",
                "abstract",
                "readonly",
                "static"
            ];
            this.tsParseModifiers({
                allowedModifiers: modifiers,
                disallowedModifiers: [
                    "in",
                    "out"
                ],
                stopOnStartOfClassStaticBlock: true,
                errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
            }, member);
            const callParseClassMemberWithIsStatic = ()=>{
                if (this.tsIsStartOfStaticBlocks()) {
                    this.next();
                    this.next();
                    if (this.tsHasSomeModifiers(member, modifiers)) this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                        at: this.state.curPosition()
                    });
                    super.parseClassStaticBlock(classBody, member);
                } else this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
            };
            if (member.declare) this.tsInAmbientContext(callParseClassMemberWithIsStatic);
            else callParseClassMemberWithIsStatic();
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
            const idx = this.tsTryParseIndexSignature(member);
            if (idx) {
                classBody.body.push(idx);
                if (member.abstract) this.raise(TSErrors.IndexSignatureHasAbstract, {
                    at: member
                });
                if (member.accessibility) this.raise(TSErrors.IndexSignatureHasAccessibility, {
                    at: member,
                    modifier: member.accessibility
                });
                if (member.declare) this.raise(TSErrors.IndexSignatureHasDeclare, {
                    at: member
                });
                if (member.override) this.raise(TSErrors.IndexSignatureHasOverride, {
                    at: member
                });
                return;
            }
            if (!this.state.inAbstractClass && member.abstract) this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
                at: member
            });
            if (member.override) {
                if (!state.hadSuperClass) this.raise(TSErrors.OverrideNotInSubClass, {
                    at: member
                });
            }
            super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parsePostMemberNameModifiers(methodOrProp) {
            const optional = this.eat(17);
            if (optional) methodOrProp.optional = true;
            if (methodOrProp.readonly && this.match(10)) this.raise(TSErrors.ClassMethodHasReadonly, {
                at: methodOrProp
            });
            if (methodOrProp.declare && this.match(10)) this.raise(TSErrors.ClassMethodHasDeclare, {
                at: methodOrProp
            });
        }
        parseExpressionStatement(node, expr, decorators) {
            const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;
            return decl || super.parseExpressionStatement(node, expr, decorators);
        }
        shouldParseExportDeclaration() {
            if (this.tsIsDeclarationStart()) return true;
            return super.shouldParseExportDeclaration();
        }
        parseConditional(expr, startLoc, refExpressionErrors) {
            if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(expr, startLoc, refExpressionErrors);
            const result = this.tryParse(()=>super.parseConditional(expr, startLoc));
            if (!result.node) {
                if (result.error) super.setOptionalParametersError(refExpressionErrors, result.error);
                return expr;
            }
            if (result.error) this.state = result.failState;
            return result.node;
        }
        parseParenItem(node, startLoc) {
            node = super.parseParenItem(node, startLoc);
            if (this.eat(17)) {
                node.optional = true;
                this.resetEndLocation(node);
            }
            if (this.match(14)) {
                const typeCastNode = this.startNodeAt(startLoc);
                typeCastNode.expression = node;
                typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
                return this.finishNode(typeCastNode, "TSTypeCastExpression");
            }
            return node;
        }
        parseExportDeclaration(node) {
            if (!this.state.isAmbientContext && this.isContextual(123)) return this.tsInAmbientContext(()=>this.parseExportDeclaration(node));
            const startLoc = this.state.startLoc;
            const isDeclare = this.eatContextual(123);
            if (isDeclare && (this.isContextual(123) || !this.shouldParseExportDeclaration())) throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
                at: this.state.startLoc
            });
            const isIdentifier = tokenIsIdentifier(this.state.type);
            const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
            if (!declaration) return null;
            if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) node.exportKind = "type";
            if (isDeclare) {
                this.resetStartLocation(declaration, startLoc);
                declaration.declare = true;
            }
            return declaration;
        }
        parseClassId(node, isStatement, optionalId, bindingType) {
            if ((!isStatement || optionalId) && this.isContextual(111)) return;
            super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
            const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            if (typeParameters) node.typeParameters = typeParameters;
        }
        parseClassPropertyAnnotation(node) {
            if (!node.optional) {
                if (this.eat(35)) node.definite = true;
                else if (this.eat(17)) node.optional = true;
            }
            const type = this.tsTryParseTypeAnnotation();
            if (type) node.typeAnnotation = type;
        }
        parseClassProperty(node) {
            this.parseClassPropertyAnnotation(node);
            if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) this.raise(TSErrors.DeclareClassFieldHasInitializer, {
                at: this.state.startLoc
            });
            if (node.abstract && this.match(29)) {
                const { key  } = node;
                this.raise(TSErrors.AbstractPropertyHasInitializer, {
                    at: this.state.startLoc,
                    propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
                });
            }
            return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
            if (node.abstract) this.raise(TSErrors.PrivateElementHasAbstract, {
                at: node
            });
            if (node.accessibility) this.raise(TSErrors.PrivateElementHasAccessibility, {
                at: node,
                modifier: node.accessibility
            });
            this.parseClassPropertyAnnotation(node);
            return super.parseClassPrivateProperty(node);
        }
        parseClassAccessorProperty(node) {
            this.parseClassPropertyAnnotation(node);
            if (node.optional) this.raise(TSErrors.AccessorCannotBeOptional, {
                at: node
            });
            return super.parseClassAccessorProperty(node);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            if (typeParameters && isConstructor) this.raise(TSErrors.ConstructorHasTypeParameters, {
                at: typeParameters
            });
            const { declare =false , kind  } = method;
            if (declare && (kind === "get" || kind === "set")) this.raise(TSErrors.DeclareAccessor, {
                at: method,
                kind
            });
            if (typeParameters) method.typeParameters = typeParameters;
            super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            if (typeParameters) method.typeParameters = typeParameters;
            super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        declareClassPrivateMethodInScope(node, kind) {
            if (node.type === "TSDeclareMethod") return;
            if (node.type === "MethodDefinition" && !node.value.body) return;
            super.declareClassPrivateMethodInScope(node, kind);
        }
        parseClassSuper(node) {
            super.parseClassSuper(node);
            if (node.superClass && (this.match(47) || this.match(51))) node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
            if (this.eatContextual(111)) node.implements = this.tsParseHeritageClause("implements");
        }
        parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
            const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            if (typeParameters) prop.typeParameters = typeParameters;
            return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        }
        parseFunctionParams(node, isConstructor) {
            const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            if (typeParameters) node.typeParameters = typeParameters;
            super.parseFunctionParams(node, isConstructor);
        }
        parseVarId(decl, kind) {
            super.parseVarId(decl, kind);
            if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) decl.definite = true;
            const type = this.tsTryParseTypeAnnotation();
            if (type) {
                decl.id.typeAnnotation = type;
                this.resetEndLocation(decl.id);
            }
        }
        parseAsyncArrowFromCallExpression(node, call) {
            if (this.match(14)) node.returnType = this.tsParseTypeAnnotation();
            return super.parseAsyncArrowFromCallExpression(node, call);
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
            var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
            let state;
            let jsx;
            let typeCast;
            if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                state = this.state.clone();
                jsx = this.tryParse(()=>super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
                if (!jsx.error) return jsx.node;
                const { context  } = this.state;
                const currentContext = context[context.length - 1];
                if (currentContext === types.j_oTag || currentContext === types.j_expr) context.pop();
            }
            if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            if (!state || state === this.state) state = this.state.clone();
            let typeParameters;
            const arrow = this.tryParse((abort)=>{
                var _expr$extra, _typeParameters;
                typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
                const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) abort();
                if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) this.resetStartLocationFromNode(expr, typeParameters);
                expr.typeParameters = typeParameters;
                return expr;
            }, state);
            if (!arrow.error && !arrow.aborted) {
                if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
                return arrow.node;
            }
            if (!jsx) {
                assert(!this.hasPlugin("jsx"));
                typeCast = this.tryParse(()=>super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
                if (!typeCast.error) return typeCast.node;
            }
            if ((_jsx2 = jsx) != null && _jsx2.node) {
                this.state = jsx.failState;
                return jsx.node;
            }
            if (arrow.node) {
                this.state = arrow.failState;
                if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
                return arrow.node;
            }
            if ((_typeCast = typeCast) != null && _typeCast.node) {
                this.state = typeCast.failState;
                return typeCast.node;
            }
            throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
        }
        reportReservedArrowTypeParam(node) {
            var _node$extra;
            if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) this.raise(TSErrors.ReservedArrowTypeParam, {
                at: node
            });
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
            if (!this.hasPlugin("jsx") && this.match(47)) return this.tsParseTypeAssertion();
            return super.parseMaybeUnary(refExpressionErrors, sawUnary);
        }
        parseArrow(node) {
            if (this.match(14)) {
                const result = this.tryParse((abort)=>{
                    const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
                    if (this.canInsertSemicolon() || !this.match(19)) abort();
                    return returnType;
                });
                if (result.aborted) return;
                if (!result.thrown) {
                    if (result.error) this.state = result.failState;
                    node.returnType = result.node;
                }
            }
            return super.parseArrow(node);
        }
        parseAssignableListItemTypes(param, flags) {
            if (!(flags & 2)) return param;
            if (this.eat(17)) param.optional = true;
            const type = this.tsTryParseTypeAnnotation();
            if (type) param.typeAnnotation = type;
            this.resetEndLocation(param);
            return param;
        }
        isAssignable(node, isBinding) {
            switch(node.type){
                case "TSTypeCastExpression":
                    return this.isAssignable(node.expression, isBinding);
                case "TSParameterProperty":
                    return true;
                default:
                    return super.isAssignable(node, isBinding);
            }
        }
        toAssignable(node, isLHS = false) {
            switch(node.type){
                case "ParenthesizedExpression":
                    this.toAssignableParenthesizedExpression(node, isLHS);
                    break;
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                    if (isLHS) this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                        at: node
                    });
                    else this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                        at: node
                    });
                    this.toAssignable(node.expression, isLHS);
                    break;
                case "AssignmentExpression":
                    if (!isLHS && node.left.type === "TSTypeCastExpression") node.left = this.typeCastToParameter(node.left);
                default:
                    super.toAssignable(node, isLHS);
            }
        }
        toAssignableParenthesizedExpression(node, isLHS) {
            switch(node.expression.type){
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                case "ParenthesizedExpression":
                    this.toAssignable(node.expression, isLHS);
                    break;
                default:
                    super.toAssignable(node, isLHS);
            }
        }
        checkToRestConversion(node, allowPattern) {
            switch(node.type){
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSTypeAssertion":
                case "TSNonNullExpression":
                    this.checkToRestConversion(node.expression, false);
                    break;
                default:
                    super.checkToRestConversion(node, allowPattern);
            }
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
            return getOwn({
                TSTypeCastExpression: true,
                TSParameterProperty: "parameter",
                TSNonNullExpression: "expression",
                TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [
                    "expression",
                    true
                ],
                TSSatisfiesExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [
                    "expression",
                    true
                ],
                TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [
                    "expression",
                    true
                ]
            }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        parseBindingAtom() {
            if (this.state.type === 78) return this.parseIdentifier(true);
            return super.parseBindingAtom();
        }
        parseMaybeDecoratorArguments(expr) {
            if (this.match(47) || this.match(51)) {
                const typeArguments = this.tsParseTypeArgumentsInExpression();
                if (this.match(10)) {
                    const call = super.parseMaybeDecoratorArguments(expr);
                    call.typeParameters = typeArguments;
                    return call;
                }
                this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(expr);
        }
        checkCommaAfterRest(close) {
            if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
                this.next();
                return false;
            }
            return super.checkCommaAfterRest(close);
        }
        isClassMethod() {
            return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(startLoc, left) {
            const node = super.parseMaybeDefault(startLoc, left);
            if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) this.raise(TSErrors.TypeAnnotationAfterAssign, {
                at: node.typeAnnotation
            });
            return node;
        }
        getTokenFromCode(code) {
            if (this.state.inType) {
                if (code === 62) {
                    this.finishOp(48, 1);
                    return;
                }
                if (code === 60) {
                    this.finishOp(47, 1);
                    return;
                }
            }
            super.getTokenFromCode(code);
        }
        reScan_lt_gt() {
            const { type  } = this.state;
            if (type === 47) {
                this.state.pos -= 1;
                this.readToken_lt();
            } else if (type === 48) {
                this.state.pos -= 1;
                this.readToken_gt();
            }
        }
        reScan_lt() {
            const { type  } = this.state;
            if (type === 51) {
                this.state.pos -= 2;
                this.finishOp(47, 1);
                return 47;
            }
            return type;
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
            for(let i = 0; i < exprList.length; i++){
                const expr = exprList[i];
                if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") exprList[i] = this.typeCastToParameter(expr);
            }
            super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        typeCastToParameter(node) {
            node.expression.typeAnnotation = node.typeAnnotation;
            this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
            return node.expression;
        }
        shouldParseArrow(params) {
            if (this.match(14)) return params.every((expr)=>this.isAssignable(expr, true));
            return super.shouldParseArrow(params);
        }
        shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(node) {
            if (this.match(47) || this.match(51)) {
                const typeArguments = this.tsTryParseAndCatch(()=>this.tsParseTypeArgumentsInExpression());
                if (typeArguments) node.typeParameters = typeArguments;
            }
            return super.jsxParseOpeningElementAfterName(node);
        }
        getGetterSetterExpectedParamCount(method) {
            const baseCount = super.getGetterSetterExpectedParamCount(method);
            const params = this.getObjectOrClassMethodParams(method);
            const firstParam = params[0];
            const hasContextParam = firstParam && this.isThisParam(firstParam);
            return hasContextParam ? baseCount + 1 : baseCount;
        }
        parseCatchClauseParam() {
            const param = super.parseCatchClauseParam();
            const type = this.tsTryParseTypeAnnotation();
            if (type) {
                param.typeAnnotation = type;
                this.resetEndLocation(param);
            }
            return param;
        }
        tsInAmbientContext(cb) {
            const oldIsAmbientContext = this.state.isAmbientContext;
            this.state.isAmbientContext = true;
            try {
                return cb();
            } finally{
                this.state.isAmbientContext = oldIsAmbientContext;
            }
        }
        parseClass(node, isStatement, optionalId) {
            const oldInAbstractClass = this.state.inAbstractClass;
            this.state.inAbstractClass = !!node.abstract;
            try {
                return super.parseClass(node, isStatement, optionalId);
            } finally{
                this.state.inAbstractClass = oldInAbstractClass;
            }
        }
        tsParseAbstractDeclaration(node, decorators) {
            if (this.match(80)) {
                node.abstract = true;
                return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
            } else if (this.isContextual(127)) {
                if (!this.hasFollowingLineBreak()) {
                    node.abstract = true;
                    this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
                        at: node
                    });
                    return this.tsParseInterfaceDeclaration(node);
                }
            } else this.unexpected(null, 80);
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
            const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
            if (method.abstract) {
                const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
                if (hasBody) {
                    const { key  } = method;
                    this.raise(TSErrors.AbstractMethodHasImplementation, {
                        at: method,
                        methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
                    });
                }
            }
            return method;
        }
        tsParseTypeParameterName() {
            const typeName = this.parseIdentifier();
            return typeName.name;
        }
        shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
        }
        parse() {
            if (this.shouldParseAsAmbientContext()) this.state.isAmbientContext = true;
            return super.parse();
        }
        getExpression() {
            if (this.shouldParseAsAmbientContext()) this.state.isAmbientContext = true;
            return super.getExpression();
        }
        parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
            if (!isString && isMaybeTypeOnly) {
                this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
                return this.finishNode(node, "ExportSpecifier");
            }
            node.exportKind = "value";
            return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
            if (!importedIsString && isMaybeTypeOnly) {
                this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
                return this.finishNode(specifier, "ImportSpecifier");
            }
            specifier.importKind = "value";
            return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);
        }
        parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
            const leftOfAsKey = isImport ? "imported" : "local";
            const rightOfAsKey = isImport ? "local" : "exported";
            let leftOfAs = node[leftOfAsKey];
            let rightOfAs;
            let hasTypeSpecifier = false;
            let canParseAsKeyword = true;
            const loc = leftOfAs.loc.start;
            if (this.isContextual(93)) {
                const firstAs = this.parseIdentifier();
                if (this.isContextual(93)) {
                    const secondAs = this.parseIdentifier();
                    if (tokenIsKeywordOrIdentifier(this.state.type)) {
                        hasTypeSpecifier = true;
                        leftOfAs = firstAs;
                        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                        canParseAsKeyword = false;
                    } else {
                        rightOfAs = secondAs;
                        canParseAsKeyword = false;
                    }
                } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                    canParseAsKeyword = false;
                    rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                } else {
                    hasTypeSpecifier = true;
                    leftOfAs = firstAs;
                }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                hasTypeSpecifier = true;
                if (isImport) {
                    leftOfAs = this.parseIdentifier(true);
                    if (!this.isContextual(93)) this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
                } else leftOfAs = this.parseModuleExportName();
            }
            if (hasTypeSpecifier && isInTypeOnlyImportExport) this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
                at: loc
            });
            node[leftOfAsKey] = leftOfAs;
            node[rightOfAsKey] = rightOfAs;
            const kindKey = isImport ? "importKind" : "exportKind";
            node[kindKey] = hasTypeSpecifier ? "type" : "value";
            if (canParseAsKeyword && this.eatContextual(93)) node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            if (!node[rightOfAsKey]) node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
            if (isImport) this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);
        }
    };
function isPossiblyLiteralEnum(expression) {
    if (expression.type !== "MemberExpression") return false;
    const { computed , property  } = expression;
    if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) return false;
    return isUncomputedMemberExpressionChain(expression.object);
}
function isValidAmbientConstInitializer(expression, estree) {
    var _expression$extra;
    const { type  } = expression;
    if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) return false;
    if (estree) {
        if (type === "Literal") {
            const { value  } = expression;
            if (typeof value === "string" || typeof value === "boolean") return true;
        }
    } else {
        if (type === "StringLiteral" || type === "BooleanLiteral") return true;
    }
    if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) return true;
    if (type === "TemplateLiteral" && expression.expressions.length === 0) return true;
    if (isPossiblyLiteralEnum(expression)) return true;
    return false;
}
function isNumber(expression, estree) {
    if (estree) return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
    return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
}
function isNegativeNumber(expression, estree) {
    if (expression.type === "UnaryExpression") {
        const { operator , argument  } = expression;
        if (operator === "-" && isNumber(argument, estree)) return true;
    }
    return false;
}
function isUncomputedMemberExpressionChain(expression) {
    if (expression.type === "Identifier") return true;
    if (expression.type !== "MemberExpression" || expression.computed) return false;
    return isUncomputedMemberExpressionChain(expression.object);
}
const PlaceholderErrors = ParseErrorEnum`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
});
var placeholders = (superClass)=>class PlaceholdersParserMixin extends superClass {
        parsePlaceholder(expectedNode) {
            if (this.match(142)) {
                const node = this.startNode();
                this.next();
                this.assertNoSpace();
                node.name = super.parseIdentifier(true);
                this.assertNoSpace();
                this.expect(142);
                return this.finishPlaceholder(node, expectedNode);
            }
        }
        finishPlaceholder(node, expectedNode) {
            const isFinished = !!(node.expectedNode && node.type === "Placeholder");
            node.expectedNode = expectedNode;
            return isFinished ? node : this.finishNode(node, "Placeholder");
        }
        getTokenFromCode(code) {
            if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) this.finishOp(142, 2);
            else super.getTokenFromCode(code);
        }
        parseExprAtom(refExpressionErrors) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
        }
        parseIdentifier(liberal) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
            if (word !== undefined) super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
        parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
        }
        isValidLVal(type, isParenthesized, binding) {
            return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
        }
        toAssignable(node, isLHS) {
            if (node && node.type === "Placeholder" && node.expectedNode === "Expression") node.expectedNode = "Pattern";
            else super.toAssignable(node, isLHS);
        }
        chStartsBindingIdentifier(ch, pos) {
            if (super.chStartsBindingIdentifier(ch, pos)) return true;
            const nextToken = this.lookahead();
            if (nextToken.type === 142) return true;
            return false;
        }
        verifyBreakContinue(node, isBreak) {
            if (node.label && node.label.type === "Placeholder") return;
            super.verifyBreakContinue(node, isBreak);
        }
        parseExpressionStatement(node, expr) {
            if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) return super.parseExpressionStatement(node, expr);
            if (this.match(14)) {
                const stmt = node;
                stmt.label = this.finishPlaceholder(expr, "Identifier");
                this.next();
                stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
                return this.finishNode(stmt, "LabeledStatement");
            }
            this.semicolon();
            node.name = expr.name;
            return this.finishPlaceholder(node, "Statement");
        }
        parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
        }
        parseFunctionId(requireId) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
        }
        parseClass(node, isStatement, optionalId) {
            const type = isStatement ? "ClassDeclaration" : "ClassExpression";
            this.next();
            const oldStrict = this.state.strict;
            const placeholder = this.parsePlaceholder("Identifier");
            if (placeholder) {
                if (this.match(81) || this.match(142) || this.match(5)) node.id = placeholder;
                else if (optionalId || !isStatement) {
                    node.id = null;
                    node.body = this.finishPlaceholder(placeholder, "ClassBody");
                    return this.finishNode(node, type);
                } else throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
                    at: this.state.startLoc
                });
            } else this.parseClassId(node, isStatement, optionalId);
            super.parseClassSuper(node);
            node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
            return this.finishNode(node, type);
        }
        parseExport(node, decorators) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder) return super.parseExport(node, decorators);
            if (!this.isContextual(97) && !this.match(12)) {
                node.specifiers = [];
                node.source = null;
                node.declaration = this.finishPlaceholder(placeholder, "Declaration");
                return this.finishNode(node, "ExportNamedDeclaration");
            }
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            specifier.exported = placeholder;
            node.specifiers = [
                this.finishNode(specifier, "ExportDefaultSpecifier")
            ];
            return super.parseExport(node, decorators);
        }
        isExportDefaultSpecifier() {
            if (this.match(65)) {
                const next = this.nextTokenStart();
                if (this.isUnparsedContextual(next, "from")) {
                    if (this.input.startsWith(tokenLabelName(142), this.nextTokenStartSince(next + 4))) return true;
                }
            }
            return super.isExportDefaultSpecifier();
        }
        maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
            var _specifiers;
            if ((_specifiers = node.specifiers) != null && _specifiers.length) return true;
            return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        }
        checkExport(node) {
            const { specifiers  } = node;
            if (specifiers != null && specifiers.length) node.specifiers = specifiers.filter((node)=>node.exported.type === "Placeholder");
            super.checkExport(node);
            node.specifiers = specifiers;
        }
        parseImport(node) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder) return super.parseImport(node);
            node.specifiers = [];
            if (!this.isContextual(97) && !this.match(12)) {
                node.source = this.finishPlaceholder(placeholder, "StringLiteral");
                this.semicolon();
                return this.finishNode(node, "ImportDeclaration");
            }
            const specifier = this.startNodeAtNode(placeholder);
            specifier.local = placeholder;
            node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
            if (this.eat(12)) {
                const hasStarImport = this.maybeParseStarImportSpecifier(node);
                if (!hasStarImport) this.parseNamedImportSpecifiers(node);
            }
            this.expectContextual(97);
            node.source = this.parseImportSource();
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
        }
        assertNoSpace() {
            if (this.state.start > this.state.lastTokEndLoc.index) this.raise(PlaceholderErrors.UnexpectedSpace, {
                at: this.state.lastTokEndLoc
            });
        }
    };
var v8intrinsic = (superClass)=>class V8IntrinsicMixin extends superClass {
        parseV8Intrinsic() {
            if (this.match(54)) {
                const v8IntrinsicStartLoc = this.state.startLoc;
                const node = this.startNode();
                this.next();
                if (tokenIsIdentifier(this.state.type)) {
                    const name = this.parseIdentifierName();
                    const identifier = this.createIdentifier(node, name);
                    identifier.type = "V8IntrinsicIdentifier";
                    if (this.match(10)) return identifier;
                }
                this.unexpected(v8IntrinsicStartLoc);
            }
        }
        parseExprAtom(refExpressionErrors) {
            return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
        }
    };
function hasPlugin(plugins, expectedConfig) {
    const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [
        expectedConfig,
        {}
    ] : expectedConfig;
    const expectedKeys = Object.keys(expectedOptions);
    const expectedOptionsIsEmpty = expectedKeys.length === 0;
    return plugins.some((p)=>{
        if (typeof p === "string") return expectedOptionsIsEmpty && p === expectedName;
        else {
            const [pluginName, pluginOptions] = p;
            if (pluginName !== expectedName) return false;
            for (const key of expectedKeys){
                if (pluginOptions[key] !== expectedOptions[key]) return false;
            }
            return true;
        }
    });
}
function getPluginOption(plugins, name, option) {
    const plugin = plugins.find((plugin)=>{
        if (Array.isArray(plugin)) return plugin[0] === name;
        else return plugin === name;
    });
    if (plugin && Array.isArray(plugin) && plugin.length > 1) return plugin[1][option];
    return null;
}
const PIPELINE_PROPOSALS = [
    "minimal",
    "fsharp",
    "hack",
    "smart"
];
const TOPIC_TOKENS = [
    "^^",
    "@@",
    "^",
    "%",
    "#"
];
const RECORD_AND_TUPLE_SYNTAX_TYPES = [
    "hash",
    "bar"
];
function validatePlugins(plugins) {
    if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (hasPlugin(plugins, "pipelineOperator")) {
        const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
            const proposalList = PIPELINE_PROPOSALS.map((p)=>`"${p}"`).join(", ");
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const tupleSyntaxIsHash = hasPlugin(plugins, [
            "recordAndTuple",
            {
                syntaxType: "hash"
            }
        ]);
        if (proposal === "hack") {
            if (hasPlugin(plugins, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
            if (hasPlugin(plugins, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
            const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
            if (!TOPIC_TOKENS.includes(topicToken)) {
                const tokenList = TOPIC_TOKENS.map((t)=>`"${t}"`).join(", ");
                throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
            }
            if (topicToken === "#" && tupleSyntaxIsHash) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        } else if (proposal === "smart" && tupleSyntaxIsHash) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (hasPlugin(plugins, "moduleAttributes")) {
        if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes")) throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
        const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
        if (moduleAttributesVersionPluginOption !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes")) throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p)=>`'${p}'`).join(", "));
    if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
    }
}
const mixinPlugins = {
    estree,
    jsx,
    flow,
    typescript,
    v8intrinsic,
    placeholders
};
const mixinPluginNames = Object.keys(mixinPlugins);
const defaultOptions = {
    sourceType: "script",
    sourceFilename: undefined,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowNewTargetOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false,
    attachComment: true,
    annexB: true
};
function getOptions(opts) {
    if (opts && opts.annexB != null && opts.annexB !== false) throw new Error("The `annexB` option can only be set to `false`.");
    const options = {};
    for (const key of Object.keys(defaultOptions))options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
    return options;
}
class ExpressionParser extends LValParser {
    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) return;
        const key = prop.key;
        const name = key.type === "Identifier" ? key.name : key.value;
        if (name === "__proto__") {
            if (isRecord) {
                this.raise(Errors.RecordNoProto, {
                    at: key
                });
                return;
            }
            if (protoRef.used) {
                if (refExpressionErrors) {
                    if (refExpressionErrors.doubleProtoLoc === null) refExpressionErrors.doubleProtoLoc = key.loc.start;
                } else this.raise(Errors.DuplicateProto, {
                    at: key
                });
            }
            protoRef.used = true;
        }
    }
    shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    }
    getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(137)) this.unexpected();
        this.finalizeRemainingComments();
        expr.comments = this.state.comments;
        expr.errors = this.state.errors;
        if (this.options.tokens) expr.tokens = this.tokens;
        return expr;
    }
    parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) return this.disallowInAnd(()=>this.parseExpressionBase(refExpressionErrors));
        return this.allowInAnd(()=>this.parseExpressionBase(refExpressionErrors));
    }
    parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
            const node = this.startNodeAt(startLoc);
            node.expressions = [
                expr
            ];
            while(this.eat(12))node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
            this.toReferencedList(node.expressions);
            return this.finishNode(node, "SequenceExpression");
        }
        return expr;
    }
    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(()=>this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(()=>this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    setOptionalParametersError(refExpressionErrors, resultError) {
        var _resultError$loc;
        refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        if (this.isContextual(106)) {
            if (this.prodParam.hasYield) {
                let left = this.parseYield();
                if (afterLeftParse) left = afterLeftParse.call(this, left, startLoc);
                return left;
            }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) ownExpressionErrors = false;
        else {
            refExpressionErrors = new ExpressionErrors();
            ownExpressionErrors = true;
        }
        const { type  } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) this.state.potentialArrowAt = this.state.start;
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) left = afterLeftParse.call(this, left, startLoc);
        if (tokenIsAssignment(this.state.type)) {
            const node = this.startNodeAt(startLoc);
            const operator = this.state.value;
            node.operator = operator;
            if (this.match(29)) {
                this.toAssignable(left, true);
                node.left = left;
                const startIndex = startLoc.index;
                if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) refExpressionErrors.doubleProtoLoc = null;
                if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) refExpressionErrors.shorthandAssignLoc = null;
                if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
                    this.checkDestructuringPrivate(refExpressionErrors);
                    refExpressionErrors.privateKeyLoc = null;
                }
            } else node.left = left;
            this.next();
            node.right = this.parseMaybeAssign();
            this.checkLVal(left, {
                in: this.finishNode(node, "AssignmentExpression")
            });
            return node;
        } else if (ownExpressionErrors) this.checkExpressionErrors(refExpressionErrors, true);
        return left;
    }
    parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) return expr;
        return this.parseConditional(expr, startLoc, refExpressionErrors);
    }
    parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
            const node = this.startNodeAt(startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssignAllowIn();
            this.expect(14);
            node.alternate = this.parseMaybeAssign();
            return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
    }
    parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    }
    parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) return expr;
        return this.parseExprOp(expr, startLoc, -1);
    }
    parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
            const value = this.getPrivateNameSV(left);
            if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) this.raise(Errors.PrivateInExpectedIn, {
                at: left,
                identifierName: value
            });
            this.classScope.usePrivateName(value, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
            let prec = tokenOperatorPrecedence(op);
            if (prec > minPrec) {
                if (op === 39) {
                    this.expectPlugin("pipelineOperator");
                    if (this.state.inFSharpPipelineDirectBody) return left;
                    this.checkPipelineAtInfixOperator(left, leftStartLoc);
                }
                const node = this.startNodeAt(leftStartLoc);
                node.left = left;
                node.operator = this.state.value;
                const logical = op === 41 || op === 42;
                const coalesce = op === 40;
                if (coalesce) prec = tokenOperatorPrecedence(42);
                this.next();
                if (op === 39 && this.hasPlugin([
                    "pipelineOperator",
                    {
                        proposal: "minimal"
                    }
                ])) {
                    if (this.state.type === 96 && this.prodParam.hasAwait) throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                        at: this.state.startLoc
                    });
                }
                node.right = this.parseExprOpRightExpr(op, prec);
                const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
                const nextOp = this.state.type;
                if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) throw this.raise(Errors.MixingCoalesceWithLogical, {
                    at: this.state.startLoc
                });
                return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
            }
        }
        return left;
    }
    parseExprOpRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        switch(op){
            case 39:
                switch(this.getPluginOption("pipelineOperator", "proposal")){
                    case "hack":
                        return this.withTopicBindingContext(()=>{
                            return this.parseHackPipeBody();
                        });
                    case "smart":
                        return this.withTopicBindingContext(()=>{
                            if (this.prodParam.hasYield && this.isContextual(106)) throw this.raise(Errors.PipeBodyIsTighter, {
                                at: this.state.startLoc
                            });
                            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
                        });
                    case "fsharp":
                        return this.withSoloAwaitPermittingContext(()=>{
                            return this.parseFSharpPipelineBody(prec);
                        });
                }
            default:
                return this.parseExprOpBaseRightExpr(op, prec);
        }
    }
    parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
    }
    parseHackPipeBody() {
        var _body$extra;
        const { startLoc  } = this.state;
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) this.raise(Errors.PipeUnparenthesizedBody, {
            at: startLoc,
            type: body.type
        });
        if (!this.topicReferenceWasUsedInCurrentContext()) this.raise(Errors.PipeTopicUnused, {
            at: startLoc
        });
        return body;
    }
    checkExponentialAfterUnary(node) {
        if (this.match(57)) this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
            at: node.argument
        });
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.isAwaitAllowed()) {
            this.next();
            const expr = this.parseAwait(startLoc);
            if (!sawUnary) this.checkExponentialAfterUnary(expr);
            return expr;
        }
        const update = this.match(34);
        const node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
            node.operator = this.state.value;
            node.prefix = true;
            if (this.match(72)) this.expectPlugin("throwExpressions");
            const isDelete = this.match(89);
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refExpressionErrors, true);
            if (this.state.strict && isDelete) {
                const arg = node.argument;
                if (arg.type === "Identifier") this.raise(Errors.StrictDelete, {
                    at: node
                });
                else if (this.hasPropertyAsPrivateName(arg)) this.raise(Errors.DeletePrivateField, {
                    at: node
                });
            }
            if (!update) {
                if (!sawUnary) this.checkExponentialAfterUnary(node);
                return this.finishNode(node, "UnaryExpression");
            }
        }
        const expr = this.parseUpdate(node, update, refExpressionErrors);
        if (isAwait) {
            const { type  } = this.state;
            const startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
            if (startsExpr && !this.isAmbiguousAwait()) {
                this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
                    at: startLoc
                });
                return this.parseAwait(startLoc);
            }
        }
        return expr;
    }
    parseUpdate(node, update, refExpressionErrors) {
        if (update) {
            const updateExpressionNode = node;
            this.checkLVal(updateExpressionNode.argument, {
                in: this.finishNode(updateExpressionNode, "UpdateExpression")
            });
            return node;
        }
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
        while(tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()){
            const node = this.startNodeAt(startLoc);
            node.operator = this.state.value;
            node.prefix = false;
            node.argument = expr;
            this.next();
            this.checkLVal(expr, {
                in: expr = this.finishNode(node, "UpdateExpression")
            });
        }
        return expr;
    }
    parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) return expr;
        return this.parseSubscripts(expr, startLoc);
    }
    parseSubscripts(base, startLoc, noCalls) {
        const state = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
            stop: false
        };
        do {
            base = this.parseSubscript(base, startLoc, noCalls, state);
            state.maybeAsyncArrow = false;
        }while (!state.stop);
        return base;
    }
    parseSubscript(base, startLoc, noCalls, state) {
        const { type  } = this.state;
        if (!noCalls && type === 15) return this.parseBind(base, startLoc, noCalls, state);
        else if (tokenIsTemplate(type)) return this.parseTaggedTemplateExpression(base, startLoc, state);
        let optional = false;
        if (type === 18) {
            if (noCalls) {
                this.raise(Errors.OptionalChainingNoNew, {
                    at: this.state.startLoc
                });
                if (this.lookaheadCharCode() === 40) {
                    state.stop = true;
                    return base;
                }
            }
            state.optionalChainMember = optional = true;
            this.next();
        }
        if (!noCalls && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        else {
            const computed = this.eat(0);
            if (computed || optional || this.eat(16)) return this.parseMember(base, startLoc, state, computed, optional);
            else {
                state.stop = true;
                return base;
            }
        }
    }
    parseMember(base, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        node.computed = computed;
        if (computed) {
            node.property = this.parseExpression();
            this.expect(3);
        } else if (this.match(136)) {
            if (base.type === "Super") this.raise(Errors.SuperPrivateField, {
                at: startLoc
            });
            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
            node.property = this.parsePrivateName();
        } else node.property = this.parseIdentifier(true);
        if (state.optionalChainMember) {
            node.optional = optional;
            return this.finishNode(node, "OptionalMemberExpression");
        } else return this.finishNode(node, "MemberExpression");
    }
    parseBind(base, startLoc, noCalls, state) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
    }
    parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        const { maybeAsyncArrow , optionalChainMember  } = state;
        if (maybeAsyncArrow) {
            this.expressionScope.enter(newAsyncArrowScope());
            refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) node.optional = optional;
        if (optional) node.arguments = this.parseCallExpressionArguments(11);
        else node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
            state.stop = true;
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
            if (maybeAsyncArrow) {
                this.checkExpressionErrors(refExpressionErrors, true);
                this.expressionScope.exit();
            }
            this.toReferencedArguments(finishedNode);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
    }
    toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    }
    parseTaggedTemplateExpression(base, startLoc, state) {
        const node = this.startNodeAt(startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) this.raise(Errors.OptionalChainingNoTemplate, {
            at: startLoc
        });
        return this.finishNode(node, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
        if (!this.hasPlugin("importAssertions")) this.expectPlugin("importAttributes");
    }
    finishCallExpression(node, optional) {
        if (node.callee.type === "Import") {
            if (node.arguments.length === 2) {
                if (!this.hasPlugin("moduleAttributes")) this.expectImportAttributesPlugin();
            }
            if (node.arguments.length === 0 || node.arguments.length > 2) this.raise(Errors.ImportCallArity, {
                at: node,
                maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
            });
            else {
                for (const arg of node.arguments)if (arg.type === "SpreadElement") this.raise(Errors.ImportCallSpreadArgument, {
                    at: arg
                });
            }
        }
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while(!this.eat(close)){
            if (first) first = false;
            else {
                this.expect(12);
                if (this.match(close)) {
                    if (dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) this.raise(Errors.ImportCallArgumentTrailingComma, {
                        at: this.state.lastTokStartLoc
                    });
                    if (nodeForExtra) this.addTrailingCommaExtraToNode(nodeForExtra);
                    this.next();
                    break;
                }
            }
            elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
    }
    shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call.innerComments) setInnerComments(node, call.innerComments);
        if (call.callee.trailingComments) setInnerComments(node, call.callee.trailingComments);
        return node;
    }
    parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
    }
    parseExprAtom(refExpressionErrors) {
        let node;
        let decorators = null;
        const { type  } = this.state;
        switch(type){
            case 79:
                return this.parseSuper();
            case 83:
                node = this.startNode();
                this.next();
                if (this.match(16)) return this.parseImportMetaProperty(node);
                if (!this.match(10)) this.raise(Errors.UnsupportedImport, {
                    at: this.state.lastTokStartLoc
                });
                return this.finishNode(node, "Import");
            case 78:
                node = this.startNode();
                this.next();
                return this.finishNode(node, "ThisExpression");
            case 90:
                return this.parseDo(this.startNode(), false);
            case 56:
            case 31:
                this.readRegexp();
                return this.parseRegExpLiteral(this.state.value);
            case 132:
                return this.parseNumericLiteral(this.state.value);
            case 133:
                return this.parseBigIntLiteral(this.state.value);
            case 134:
                return this.parseDecimalLiteral(this.state.value);
            case 131:
                return this.parseStringLiteral(this.state.value);
            case 84:
                return this.parseNullLiteral();
            case 85:
                return this.parseBooleanLiteral(true);
            case 86:
                return this.parseBooleanLiteral(false);
            case 10:
                {
                    const canBeArrow = this.state.potentialArrowAt === this.state.start;
                    return this.parseParenAndDistinguishExpression(canBeArrow);
                }
            case 2:
            case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
            case 0:
                return this.parseArrayLike(3, true, false, refExpressionErrors);
            case 6:
            case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
            case 5:
                return this.parseObjectLike(8, false, false, refExpressionErrors);
            case 68:
                return this.parseFunctionOrFunctionSent();
            case 26:
                decorators = this.parseDecorators();
            case 80:
                return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
            case 77:
                return this.parseNewOrNewTarget();
            case 25:
            case 24:
                return this.parseTemplate(false);
            case 15:
                {
                    node = this.startNode();
                    this.next();
                    node.object = null;
                    const callee = node.callee = this.parseNoCallExpr();
                    if (callee.type === "MemberExpression") return this.finishNode(node, "BindExpression");
                    else throw this.raise(Errors.UnsupportedBind, {
                        at: callee
                    });
                }
            case 136:
                this.raise(Errors.PrivateInExpectedIn, {
                    at: this.state.startLoc,
                    identifierName: this.state.value
                });
                return this.parsePrivateName();
            case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
            case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
            case 37:
            case 38:
                return this.parseTopicReference("hack");
            case 44:
            case 54:
            case 27:
                {
                    const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
                    if (pipeProposal) return this.parseTopicReference(pipeProposal);
                    this.unexpected();
                    break;
                }
            case 47:
                {
                    const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
                    if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) this.expectOnePlugin([
                        "jsx",
                        "flow",
                        "typescript"
                    ]);
                    else this.unexpected();
                    break;
                }
            default:
                if (tokenIsIdentifier(type)) {
                    if (this.isContextual(125) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
                    const canBeArrow = this.state.potentialArrowAt === this.state.start;
                    const containsEsc = this.state.containsEsc;
                    const id = this.parseIdentifier();
                    if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                        const { type  } = this.state;
                        if (type === 68) {
                            this.resetPreviousNodeTrailingComments(id);
                            this.next();
                            return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                        } else if (tokenIsIdentifier(type)) {
                            if (this.lookaheadCharCode() === 61) return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                            else return id;
                        } else if (type === 90) {
                            this.resetPreviousNodeTrailingComments(id);
                            return this.parseDo(this.startNodeAtNode(id), true);
                        }
                    }
                    if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                        this.next();
                        return this.parseArrowExpression(this.startNodeAtNode(id), [
                            id
                        ], false);
                    }
                    return id;
                } else this.unexpected();
        }
    }
    parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
            this.state.type = topicTokenType;
            this.state.value = topicTokenValue;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
            return this.parseTopicReference(pipeProposal);
        } else this.unexpected();
    }
    parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType = this.state.type;
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
    }
    finishTopicReference(node, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
            const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
            if (!this.topicReferenceIsAllowedInCurrentContext()) this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
                at: startLoc
            });
            this.registerTopicReference();
            return this.finishNode(node, nodeType);
        } else throw this.raise(Errors.PipeTopicUnconfiguredToken, {
            at: startLoc,
            token: tokenLabelName(tokenType)
        });
    }
    testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch(pipeProposal){
            case "hack":
                return this.hasPlugin([
                    "pipelineOperator",
                    {
                        topicToken: tokenLabelName(tokenType)
                    }
                ]);
            case "smart":
                return tokenType === 27;
            default:
                throw this.raise(Errors.PipeTopicRequiresHackPipes, {
                    at: startLoc
                });
        }
    }
    parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [
            this.parseIdentifier()
        ];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) this.raise(Errors.LineTerminatorBeforeArrow, {
            at: this.state.curPosition()
        });
        this.expect(19);
        return this.parseArrowExpression(node, params, true);
    }
    parseDo(node, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) this.expectPlugin("asyncDoExpressions");
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
            this.prodParam.enter(PARAM_AWAIT);
            node.body = this.parseBlock();
            this.prodParam.exit();
        } else node.body = this.parseBlock();
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
    }
    parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) this.raise(Errors.SuperNotAllowed, {
            at: node
        });
        else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) this.raise(Errors.UnexpectedSuper, {
            at: node
        });
        if (!this.match(10) && !this.match(0) && !this.match(16)) this.raise(Errors.UnsupportedSuper, {
            at: node
        });
        return this.finishNode(node, "Super");
    }
    parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
            this.next();
            if (this.match(102)) this.expectPlugin("functionSent");
            else if (!this.hasPlugin("functionSent")) this.unexpected();
            return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
    }
    parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);
        if (node.property.name !== propertyName || containsEsc) this.raise(Errors.UnsupportedMetaProperty, {
            at: node.property,
            target: meta.name,
            onlyValidPropertyName: propertyName
        });
        return this.finishNode(node, "MetaProperty");
    }
    parseImportMetaProperty(node) {
        const id = this.createIdentifier(this.startNodeAtNode(node), "import");
        this.next();
        if (this.isContextual(100)) {
            if (!this.inModule) this.raise(Errors.ImportMetaOutsideModule, {
                at: id
            });
            this.sawUnambiguousESM = true;
        }
        return this.parseMetaProperty(node, id, "meta");
    }
    parseLiteralAtNode(value, type, node) {
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
    }
    parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
    }
    parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
    }
    parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
    }
    parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
    }
    parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
    }
    parseRegExpLiteral(value) {
        const node = this.parseLiteral(value.value, "RegExpLiteral");
        node.pattern = value.pattern;
        node.flags = value.flags;
        return node;
    }
    parseBooleanLiteral(value) {
        const node = this.startNode();
        node.value = value;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
    }
    parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
    }
    parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while(!this.match(11)){
            if (first) first = false;
            else {
                this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
                if (this.match(11)) {
                    optionalCommaStartLoc = this.state.startLoc;
                    break;
                }
            }
            if (this.match(21)) {
                const spreadNodeStartLoc = this.state.startLoc;
                spreadStartLoc = this.state.startLoc;
                exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
                if (!this.checkCommaAfterRest(41)) break;
            } else exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(arrowNode, exprList, false);
            return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) this.unexpected(this.state.lastTokStartLoc);
        if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc) this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
            val = this.startNodeAt(innerStartLoc);
            val.expressions = exprList;
            this.finishNode(val, "SequenceExpression");
            this.resetEndLocation(val, innerEndLoc);
        } else val = exprList[0];
        return this.wrapParenthesis(startLoc, val);
    }
    wrapParenthesis(startLoc, expression) {
        if (!this.options.createParenthesizedExpressions) {
            this.addExtra(expression, "parenthesized", true);
            this.addExtra(expression, "parenStart", startLoc.index);
            this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
            return expression;
        }
        const parenExpression = this.startNodeAt(startLoc);
        parenExpression.expression = expression;
        return this.finishNode(parenExpression, "ParenthesizedExpression");
    }
    shouldParseArrow(params) {
        return !this.canInsertSemicolon();
    }
    parseArrow(node) {
        if (this.eat(19)) return node;
    }
    parseParenItem(node, startLoc) {
        return node;
    }
    parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
            this.next();
            const metaProp = this.parseMetaProperty(node, meta, "target");
            if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) this.raise(Errors.UnexpectedNewTarget, {
                at: metaProp
            });
            return metaProp;
        }
        return this.parseNew(node);
    }
    parseNew(node) {
        this.parseNewCallee(node);
        if (this.eat(10)) {
            const args = this.parseExprList(11);
            this.toReferencedList(args);
            node.arguments = args;
        } else node.arguments = [];
        return this.finishNode(node, "NewExpression");
    }
    parseNewCallee(node) {
        node.callee = this.parseNoCallExpr();
        if (node.callee.type === "Import") this.raise(Errors.ImportCallNotNewExpression, {
            at: node.callee
        });
    }
    parseTemplateElement(isTagged) {
        const { start , startLoc , end , value  } = this.state;
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        if (value === null) {
            if (!isTagged) this.raise(Errors.InvalidEscapeSequenceTemplate, {
                at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
            });
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
            raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
            cooked: value === null ? null : value.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
    }
    parseTemplate(isTagged) {
        const node = this.startNode();
        node.expressions = [];
        let curElt = this.parseTemplateElement(isTagged);
        node.quasis = [
            curElt
        ];
        while(!curElt.tail){
            node.expressions.push(this.parseTemplateSubstitution());
            this.readTemplateContinuation();
            node.quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        return this.finishNode(node, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
        return this.parseExpression();
    }
    parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) this.expectPlugin("recordAndTuple");
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const propHash = Object.create(null);
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while(!this.match(close)){
            if (first) first = false;
            else {
                this.expect(12);
                if (this.match(close)) {
                    this.addTrailingCommaExtraToNode(node);
                    break;
                }
            }
            let prop;
            if (isPattern) prop = this.parseBindingProperty();
            else {
                prop = this.parsePropertyDefinition(refExpressionErrors);
                this.checkProto(prop, isRecord, propHash, refExpressionErrors);
            }
            if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") this.raise(Errors.InvalidRecordProperty, {
                at: prop
            });
            if (prop.shorthand) this.addExtra(prop, "shorthand", true);
            node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) type = "ObjectPattern";
        else if (isRecord) type = "RecordExpression";
        return this.finishNode(node, type);
    }
    addTrailingCommaExtraToNode(node) {
        this.addExtra(node, "trailingComma", this.state.lastTokStart);
        this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
            if (this.hasPlugin("decorators")) this.raise(Errors.UnsupportedPropertyDecorator, {
                at: this.state.startLoc
            });
            while(this.match(26))decorators.push(this.parseDecorator());
        }
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor = false;
        let startLoc;
        if (this.match(21)) {
            if (decorators.length) this.unexpected();
            return this.parseSpread();
        }
        if (decorators.length) {
            prop.decorators = decorators;
            decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) startLoc = this.state.startLoc;
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        const key = this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const keyName = key.name;
            if (keyName === "async" && !this.hasPrecedingLineBreak()) {
                isAsync = true;
                this.resetPreviousNodeTrailingComments(key);
                isGenerator = this.eat(55);
                this.parsePropertyName(prop);
            }
            if (keyName === "get" || keyName === "set") {
                isAccessor = true;
                this.resetPreviousNodeTrailingComments(key);
                prop.kind = keyName;
                if (this.match(55)) {
                    isGenerator = true;
                    this.raise(Errors.AccessorIsGenerator, {
                        at: this.state.curPosition(),
                        kind: keyName
                    });
                    this.next();
                }
                this.parsePropertyName(prop);
            }
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
    }
    getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(method) {
        return method.params;
    }
    checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
            at: method
        });
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") this.raise(Errors.BadSetterRestParameter, {
            at: method
        });
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
            const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
            this.checkGetterSetterParams(finishedProp);
            return finishedProp;
        }
        if (isAsync || isGenerator || this.match(10)) {
            if (isPattern) this.unexpected();
            prop.kind = "method";
            prop.method = true;
            return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
    }
    parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
            return this.finishNode(prop, "ObjectProperty");
        }
        if (!prop.computed && prop.key.type === "Identifier") {
            this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
            if (isPattern) prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
            else if (this.match(29)) {
                const shorthandAssignLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                    if (refExpressionErrors.shorthandAssignLoc === null) refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                } else this.raise(Errors.InvalidCoverInitializedName, {
                    at: shorthandAssignLoc
                });
                prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
            } else prop.value = cloneIdentifier(prop.key);
            prop.shorthand = true;
            return this.finishNode(prop, "ObjectProperty");
        }
    }
    parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (!node) this.unexpected();
        return node;
    }
    parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssignAllowIn();
            this.expect(3);
        } else {
            const { type , value  } = this.state;
            let key;
            if (tokenIsKeywordOrIdentifier(type)) key = this.parseIdentifier(true);
            else switch(type){
                case 132:
                    key = this.parseNumericLiteral(value);
                    break;
                case 131:
                    key = this.parseStringLiteral(value);
                    break;
                case 133:
                    key = this.parseBigIntLiteral(value);
                    break;
                case 134:
                    key = this.parseDecimalLiteral(value);
                    break;
                case 136:
                    {
                        const privateKeyLoc = this.state.startLoc;
                        if (refExpressionErrors != null) {
                            if (refExpressionErrors.privateKeyLoc === null) refExpressionErrors.privateKeyLoc = privateKeyLoc;
                        } else this.raise(Errors.UnexpectedPrivateField, {
                            at: privateKeyLoc
                        });
                        key = this.parsePrivateName();
                        break;
                    }
                default:
                    this.unexpected();
            }
            prop.key = key;
            if (type !== 136) prop.computed = false;
        }
        return prop.key;
    }
    initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = isAsync;
    }
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = isGenerator;
        this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) this.expectPlugin("recordAndTuple");
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
        let flags = functionFlags(isAsync, false);
        if (!this.match(5) && this.prodParam.hasIn) flags |= PARAM_IN;
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node.params = params;
    }
    parseFunctionBodyAndFinish(node, type, isMethod = false) {
        this.parseFunctionBody(node, false, isMethod);
        return this.finishNode(node, type);
    }
    parseFunctionBody(node, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
            node.body = this.parseMaybeAssign();
            this.checkParams(node, false, allowExpression, false);
        } else {
            const oldStrict = this.state.strict;
            const oldLabels = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
            node.body = this.parseBlock(true, false, (hasStrictModeDirective)=>{
                const nonSimple = !this.isSimpleParamList(node.params);
                if (hasStrictModeDirective && nonSimple) this.raise(Errors.IllegalLanguageModeDirective, {
                    at: (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node
                });
                const strictModeChanged = !oldStrict && this.state.strict;
                this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
                if (this.state.strict && node.id) this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);
            });
            this.prodParam.exit();
            this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
    }
    isSimpleParameter(node) {
        return node.type === "Identifier";
    }
    isSimpleParamList(params) {
        for(let i = 0, len = params.length; i < len; i++){
            if (!this.isSimpleParameter(params[i])) return false;
        }
        return true;
    }
    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates && new Set();
        const formalParameters = {
            type: "FormalParameters"
        };
        for (const param of node.params)this.checkLVal(param, {
            in: formalParameters,
            binding: BIND_VAR,
            checkClashes,
            strictModeChanged
        });
    }
    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while(!this.eat(close)){
            if (first) first = false;
            else {
                this.expect(12);
                if (this.match(close)) {
                    if (nodeForExtra) this.addTrailingCommaExtraToNode(nodeForExtra);
                    this.next();
                    break;
                }
            }
            elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
    }
    parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
            if (!allowEmpty) this.raise(Errors.UnexpectedToken, {
                at: this.state.curPosition(),
                unexpected: ","
            });
            elt = null;
        } else if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
            this.expectPlugin("partialApplication");
            if (!allowPlaceholder) this.raise(Errors.UnexpectedArgumentPlaceholder, {
                at: this.state.startLoc
            });
            const node = this.startNode();
            this.next();
            elt = this.finishNode(node, "ArgumentPlaceholder");
        } else elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        return elt;
    }
    parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(liberal);
        return this.createIdentifier(node, name);
    }
    createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, "Identifier");
    }
    parseIdentifierName(liberal) {
        let name;
        const { startLoc , type  } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) name = this.state.value;
        else this.unexpected();
        const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
            if (tokenIsKeyword) this.replaceToken(130);
        } else this.checkReservedWord(name, startLoc, tokenIsKeyword, false);
        this.next();
        return name;
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) return;
        if (!canBeReservedWord(word)) return;
        if (checkKeywords && isKeyword(word)) {
            this.raise(Errors.UnexpectedKeyword, {
                at: startLoc,
                keyword: word
            });
            return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
            this.raise(Errors.UnexpectedReservedWord, {
                at: startLoc,
                reservedWord: word
            });
            return;
        } else if (word === "yield") {
            if (this.prodParam.hasYield) {
                this.raise(Errors.YieldBindingIdentifier, {
                    at: startLoc
                });
                return;
            }
        } else if (word === "await") {
            if (this.prodParam.hasAwait) {
                this.raise(Errors.AwaitBindingIdentifier, {
                    at: startLoc
                });
                return;
            }
            if (this.scope.inStaticBlock) {
                this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
                    at: startLoc
                });
                return;
            }
            this.expressionScope.recordAsyncArrowParametersError({
                at: startLoc
            });
        } else if (word === "arguments") {
            if (this.scope.inClassAndNotInNonArrowFunction) {
                this.raise(Errors.ArgumentsInClass, {
                    at: startLoc
                });
                return;
            }
        }
    }
    isAwaitAllowed() {
        if (this.prodParam.hasAwait) return true;
        if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) return true;
        return false;
    }
    parseAwait(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
            at: node
        });
        if (this.eat(55)) this.raise(Errors.ObsoleteAwaitStar, {
            at: node
        });
        if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
            if (this.isAmbiguousAwait()) this.ambiguousScriptDifferentAst = true;
            else this.sawUnambiguousESM = true;
        }
        if (!this.state.soloAwait) node.argument = this.parseMaybeUnary(null, true);
        return this.finishNode(node, "AwaitExpression");
    }
    isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak()) return true;
        const { type  } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 101 && !this.state.containsEsc || type === 135 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
    }
    parseYield() {
        const node = this.startNode();
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
            at: node
        });
        this.next();
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
            delegating = this.eat(55);
            switch(this.state.type){
                case 13:
                case 137:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                    if (!delegating) break;
                default:
                    argument = this.parseMaybeAssign();
            }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
    }
    checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin([
            "pipelineOperator",
            {
                proposal: "smart"
            }
        ])) {
            if (left.type === "SequenceExpression") this.raise(Errors.PipelineHeadSequenceExpression, {
                at: leftStartLoc
            });
        }
    }
    parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
            const bodyNode = this.startNodeAt(startLoc);
            bodyNode.callee = childExpr;
            return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
            const bodyNode = this.startNodeAt(startLoc);
            this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
            bodyNode.expression = childExpr;
            return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
    }
    isSimpleReference(expression) {
        switch(expression.type){
            case "MemberExpression":
                return !expression.computed && this.isSimpleReference(expression.object);
            case "Identifier":
                return true;
            default:
                return false;
        }
    }
    checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) throw this.raise(Errors.PipelineBodyNoArrow, {
            at: this.state.startLoc
        });
        if (!this.topicReferenceWasUsedInCurrentContext()) this.raise(Errors.PipelineTopicUnused, {
            at: startLoc
        });
    }
    withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null
        };
        try {
            return callback();
        } finally{
            this.state.topicContext = outerContextTopicState;
        }
    }
    withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin([
            "pipelineOperator",
            {
                proposal: "smart"
            }
        ])) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {
                maxNumOfResolvableTopics: 0,
                maxTopicIndex: null
            };
            try {
                return callback();
            } finally{
                this.state.topicContext = outerContextTopicState;
            }
        } else return callback();
    }
    withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
            return callback();
        } finally{
            this.state.soloAwait = outerContextSoloAwaitState;
        }
    }
    allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = PARAM_IN & ~flags;
        if (prodParamToSet) {
            this.prodParam.enter(flags | PARAM_IN);
            try {
                return callback();
            } finally{
                this.prodParam.exit();
            }
        }
        return callback();
    }
    disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = PARAM_IN & flags;
        if (prodParamToClear) {
            this.prodParam.enter(flags & ~PARAM_IN);
            try {
                return callback();
            } finally{
                this.prodParam.exit();
            }
        }
        return callback();
    }
    registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
    }
    parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        if (!this.match(5)) this.unexpected(null, 5);
        const program = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
            node.body = this.parseProgram(program, 8, "module");
        } finally{
            revertScopes();
        }
        return this.finishNode(node, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(prop) {}
}
const loopLabel = {
    kind: "loop"
}, switchLabel = {
    kind: "switch"
};
const loneSurrogate = /[\uD800-\uDFFF]/u;
const keywordRelationalOperator = /in(?:stanceof)?/y;
function babel7CompatTokens(tokens, input) {
    for(let i = 0; i < tokens.length; i++){
        const token = tokens[i];
        const { type  } = token;
        if (typeof type === "number") {
            if (type === 136) {
                const { loc , start , value , end  } = token;
                const hashEndPos = start + 1;
                const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                tokens.splice(i, 1, new Token({
                    type: getExportedToken(27),
                    value: "#",
                    start: start,
                    end: hashEndPos,
                    startLoc: loc.start,
                    endLoc: hashEndLoc
                }), new Token({
                    type: getExportedToken(130),
                    value: value,
                    start: hashEndPos,
                    end: end,
                    startLoc: hashEndLoc,
                    endLoc: loc.end
                }));
                i++;
                continue;
            }
            if (tokenIsTemplate(type)) {
                const { loc , start , value , end  } = token;
                const backquoteEnd = start + 1;
                const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
                let startToken;
                if (input.charCodeAt(start) === 96) startToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start: start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                });
                else startToken = new Token({
                    type: getExportedToken(8),
                    value: "}",
                    start: start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                });
                let templateValue, templateElementEnd, templateElementEndLoc, endToken;
                if (type === 24) {
                    templateElementEnd = end - 1;
                    templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                    templateValue = value === null ? null : value.slice(1, -1);
                    endToken = new Token({
                        type: getExportedToken(22),
                        value: "`",
                        start: templateElementEnd,
                        end: end,
                        startLoc: templateElementEndLoc,
                        endLoc: loc.end
                    });
                } else {
                    templateElementEnd = end - 2;
                    templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                    templateValue = value === null ? null : value.slice(1, -2);
                    endToken = new Token({
                        type: getExportedToken(23),
                        value: "${",
                        start: templateElementEnd,
                        end: end,
                        startLoc: templateElementEndLoc,
                        endLoc: loc.end
                    });
                }
                tokens.splice(i, 1, startToken, new Token({
                    type: getExportedToken(20),
                    value: templateValue,
                    start: backquoteEnd,
                    end: templateElementEnd,
                    startLoc: backquoteEndLoc,
                    endLoc: templateElementEndLoc
                }), endToken);
                i += 2;
                continue;
            }
            token.type = getExportedToken(type);
        }
    }
    return tokens;
}
class StatementParser extends ExpressionParser {
    parseTopLevel(file, program) {
        file.program = this.parseProgram(program);
        file.comments = this.state.comments;
        if (this.options.tokens) file.tokens = babel7CompatTokens(this.tokens, this.input);
        return this.finishNode(file, "File");
    }
    parseProgram(program, end = 137, sourceType = this.options.sourceType) {
        program.sourceType = sourceType;
        program.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program, true, true, end);
        if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (const [localName, at] of Array.from(this.scope.undefinedExports))this.raise(Errors.ModuleExportUndefined, {
            at,
            localName
        });
        let finishedProgram;
        if (end === 137) finishedProgram = this.finishNode(program, "Program");
        else finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
        return finishedProgram;
    }
    stmtToDirective(stmt) {
        const directive = stmt;
        directive.type = "Directive";
        directive.value = directive.expression;
        delete directive.expression;
        const directiveLiteral = directive.value;
        const expressionValue = directiveLiteral.value;
        const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
        directiveLiteral.type = "DirectiveLiteral";
        return directive;
    }
    parseInterpreterDirective() {
        if (!this.match(28)) return null;
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
    }
    isLet() {
        if (!this.isContextual(99)) return false;
        return this.hasFollowingBindingAtom();
    }
    chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart(ch)) {
            keywordRelationalOperator.lastIndex = pos;
            if (keywordRelationalOperator.test(this.input)) {
                const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
                if (!isIdentifierChar(endCh) && endCh !== 92) return false;
            }
            return true;
        } else if (ch === 92) return true;
        else return false;
    }
    chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
    }
    hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
    }
    hasInLineFollowingBindingIdentifier() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifier(nextCh, next);
    }
    startsUsingForOf() {
        const { type , containsEsc  } = this.lookahead();
        if (type === 101 && !containsEsc) return false;
        else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
            this.expectPlugin("explicitResourceManagement");
            return true;
        }
    }
    startsAwaitUsing() {
        let next = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(next, "using")) {
            next = this.nextTokenInLineStartSince(next + 5);
            const nextCh = this.codePointAtPos(next);
            if (this.chStartsBindingIdentifier(nextCh, next)) {
                this.expectPlugin("explicitResourceManagement");
                return true;
            }
        }
        return false;
    }
    parseModuleItem() {
        return this.parseStatementLike(15);
    }
    parseStatementListItem() {
        return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        if (this.options.annexB && !this.state.strict) {
            flags |= 4;
            if (allowLabeledFunction) flags |= 8;
        }
        return this.parseStatementLike(flags);
    }
    parseStatement() {
        return this.parseStatementLike(0);
    }
    parseStatementLike(flags) {
        let decorators = null;
        if (this.match(26)) decorators = this.parseDecorators(true);
        return this.parseStatementContent(flags, decorators);
    }
    parseStatementContent(flags, decorators) {
        const starttype = this.state.type;
        const node = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        switch(starttype){
            case 60:
                return this.parseBreakContinueStatement(node, true);
            case 63:
                return this.parseBreakContinueStatement(node, false);
            case 64:
                return this.parseDebuggerStatement(node);
            case 90:
                return this.parseDoWhileStatement(node);
            case 91:
                return this.parseForStatement(node);
            case 68:
                if (this.lookaheadCharCode() === 46) break;
                if (!allowFunctionDeclaration) this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, {
                    at: this.state.startLoc
                });
                return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
            case 80:
                if (!allowDeclaration) this.unexpected();
                return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
            case 69:
                return this.parseIfStatement(node);
            case 70:
                return this.parseReturnStatement(node);
            case 71:
                return this.parseSwitchStatement(node);
            case 72:
                return this.parseThrowStatement(node);
            case 73:
                return this.parseTryStatement(node);
            case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing()) {
                    if (!this.isAwaitAllowed()) this.raise(Errors.AwaitUsingNotInAsyncContext, {
                        at: node
                    });
                    else if (!allowDeclaration) this.raise(Errors.UnexpectedLexicalDeclaration, {
                        at: node
                    });
                    this.next();
                    return this.parseVarStatement(node, "await using");
                }
                break;
            case 105:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) break;
                this.expectPlugin("explicitResourceManagement");
                if (!this.scope.inModule && this.scope.inTopLevel) this.raise(Errors.UnexpectedUsingDeclaration, {
                    at: this.state.startLoc
                });
                else if (!allowDeclaration) this.raise(Errors.UnexpectedLexicalDeclaration, {
                    at: this.state.startLoc
                });
                return this.parseVarStatement(node, "using");
            case 99:
                {
                    if (this.state.containsEsc) break;
                    const next = this.nextTokenStart();
                    const nextCh = this.codePointAtPos(next);
                    if (nextCh !== 91) {
                        if (!allowDeclaration && this.hasFollowingLineBreak()) break;
                        if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) break;
                    }
                }
            case 75:
                if (!allowDeclaration) this.raise(Errors.UnexpectedLexicalDeclaration, {
                    at: this.state.startLoc
                });
            case 74:
                {
                    const kind = this.state.value;
                    return this.parseVarStatement(node, kind);
                }
            case 92:
                return this.parseWhileStatement(node);
            case 76:
                return this.parseWithStatement(node);
            case 5:
                return this.parseBlock();
            case 13:
                return this.parseEmptyStatement(node);
            case 83:
                {
                    const nextTokenCharCode = this.lookaheadCharCode();
                    if (nextTokenCharCode === 40 || nextTokenCharCode === 46) break;
                }
            case 82:
                {
                    if (!this.options.allowImportExportEverywhere && !topLevel) this.raise(Errors.UnexpectedImportExport, {
                        at: this.state.startLoc
                    });
                    this.next();
                    let result;
                    if (starttype === 83) {
                        result = this.parseImport(node);
                        if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) this.sawUnambiguousESM = true;
                    } else {
                        result = this.parseExport(node, decorators);
                        if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") this.sawUnambiguousESM = true;
                    }
                    this.assertModuleNodeAllowed(result);
                    return result;
                }
            default:
                if (this.isAsyncFunction()) {
                    if (!allowDeclaration) this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                        at: this.state.startLoc
                    });
                    this.next();
                    return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
                }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) return this.parseLabeledStatement(node, maybeName, expr, flags);
        else return this.parseExpressionStatement(node, expr, decorators);
    }
    assertModuleNodeAllowed(node) {
        if (!this.options.allowImportExportEverywhere && !this.inModule) this.raise(Errors.ImportOutsideModule, {
            at: node
        });
    }
    decoratorsEnabledBeforeExport() {
        if (this.hasPlugin("decorators-legacy")) return true;
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
    }
    maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
            if (classNode.decorators && classNode.decorators.length > 0) {
                if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") this.raise(Errors.DecoratorsBeforeAfterExport, {
                    at: classNode.decorators[0]
                });
                classNode.decorators.unshift(...maybeDecorators);
            } else classNode.decorators = maybeDecorators;
            this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
            if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
    }
    canHaveLeadingDecorator() {
        return this.match(80);
    }
    parseDecorators(allowExport) {
        const decorators = [];
        do decorators.push(this.parseDecorator());
        while (this.match(26));
        if (this.match(82)) {
            if (!allowExport) this.unexpected();
            if (!this.decoratorsEnabledBeforeExport()) this.raise(Errors.DecoratorExportClass, {
                at: this.state.startLoc
            });
        } else if (!this.canHaveLeadingDecorator()) throw this.raise(Errors.UnexpectedLeadingDecorator, {
            at: this.state.startLoc
        });
        return decorators;
    }
    parseDecorator() {
        this.expectOnePlugin([
            "decorators",
            "decorators-legacy"
        ]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
            const startLoc = this.state.startLoc;
            let expr;
            if (this.match(10)) {
                const startLoc = this.state.startLoc;
                this.next();
                expr = this.parseExpression();
                this.expect(11);
                expr = this.wrapParenthesis(startLoc, expr);
                const paramsStartLoc = this.state.startLoc;
                node.expression = this.parseMaybeDecoratorArguments(expr);
                if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
                    at: paramsStartLoc
                });
            } else {
                expr = this.parseIdentifier(false);
                while(this.eat(16)){
                    const node = this.startNodeAt(startLoc);
                    node.object = expr;
                    if (this.match(136)) {
                        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                        node.property = this.parsePrivateName();
                    } else node.property = this.parseIdentifier(true);
                    node.computed = false;
                    expr = this.finishNode(node, "MemberExpression");
                }
                node.expression = this.parseMaybeDecoratorArguments(expr);
            }
        } else node.expression = this.parseExprSubscripts();
        return this.finishNode(node, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
        if (this.eat(10)) {
            const node = this.startNodeAtNode(expr);
            node.callee = expr;
            node.arguments = this.parseCallExpressionArguments(11, false);
            this.toReferencedList(node.arguments);
            return this.finishNode(node, "CallExpression");
        }
        return expr;
    }
    parseBreakContinueStatement(node, isBreak) {
        this.next();
        if (this.isLineTerminator()) node.label = null;
        else {
            node.label = this.parseIdentifier();
            this.semicolon();
        }
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(node, isBreak) {
        let i;
        for(i = 0; i < this.state.labels.length; ++i){
            const lab = this.state.labels[i];
            if (node.label == null || lab.name === node.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
                if (node.label && isBreak) break;
            }
        }
        if (i === this.state.labels.length) {
            const type = isBreak ? "BreakStatement" : "ContinueStatement";
            this.raise(Errors.IllegalBreakContinue, {
                at: node,
                type
            });
        }
    }
    parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
    }
    parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
    }
    parseDoWhileStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node, "DoWhileStatement");
    }
    parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isAwaitAllowed() && this.eatContextual(96)) awaitAt = this.state.lastTokStartLoc;
        this.scope.enter(SCOPE_OTHER);
        this.expect(10);
        if (this.match(13)) {
            if (awaitAt !== null) this.unexpected(awaitAt);
            return this.parseFor(node, null);
        }
        const startsWithLet = this.isContextual(99);
        {
            const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
            const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(105) && this.startsUsingForOf();
            const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
            if (this.match(74) || this.match(75) || isLetOrUsing) {
                const initNode = this.startNode();
                let kind;
                if (startsWithAwaitUsing) {
                    kind = "await using";
                    if (!this.isAwaitAllowed()) this.raise(Errors.AwaitUsingNotInAsyncContext, {
                        at: this.state.startLoc
                    });
                    this.next();
                } else kind = this.state.value;
                this.next();
                this.parseVar(initNode, true, kind);
                const init = this.finishNode(initNode, "VariableDeclaration");
                const isForIn = this.match(58);
                if (isForIn && starsWithUsingDeclaration) this.raise(Errors.ForInUsing, {
                    at: init
                });
                if ((isForIn || this.isContextual(101)) && init.declarations.length === 1) return this.parseForIn(node, init, awaitAt);
                if (awaitAt !== null) this.unexpected(awaitAt);
                return this.parseFor(node, init);
            }
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(101);
        if (isForOf) {
            if (startsWithLet) this.raise(Errors.ForOfLet, {
                at: init
            });
            if (awaitAt === null && startsWithAsync && init.type === "Identifier") this.raise(Errors.ForOfAsync, {
                at: init
            });
        }
        if (isForOf || this.match(58)) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.toAssignable(init, true);
            const type = isForOf ? "ForOfStatement" : "ForInStatement";
            this.checkLVal(init, {
                in: {
                    type
                }
            });
            return this.parseForIn(node, init, awaitAt);
        } else this.checkExpressionErrors(refExpressionErrors, true);
        if (awaitAt !== null) this.unexpected(awaitAt);
        return this.parseFor(node, init);
    }
    parseFunctionStatement(node, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
    }
    parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node, "IfStatement");
    }
    parseReturnStatement(node) {
        if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) this.raise(Errors.IllegalReturn, {
            at: this.state.startLoc
        });
        this.next();
        if (this.isLineTerminator()) node.argument = null;
        else {
            node.argument = this.parseExpression();
            this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
    }
    parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(SCOPE_OTHER);
        let cur;
        for(let sawDefault; !this.match(8);){
            if (this.match(61) || this.match(65)) {
                const isCase = this.match(61);
                if (cur) this.finishNode(cur, "SwitchCase");
                cases.push(cur = this.startNode());
                cur.consequent = [];
                this.next();
                if (isCase) cur.test = this.parseExpression();
                else {
                    if (sawDefault) this.raise(Errors.MultipleDefaultsInSwitch, {
                        at: this.state.lastTokStartLoc
                    });
                    sawDefault = true;
                    cur.test = null;
                }
                this.expect(14);
            } else if (cur) cur.consequent.push(this.parseStatementListItem());
            else this.unexpected();
        }
        this.scope.exit();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
    }
    parseThrowStatement(node) {
        this.next();
        if (this.hasPrecedingLineBreak()) this.raise(Errors.NewlineAfterThrow, {
            at: this.state.lastTokEndLoc
        });
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
    }
    parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === "Identifier" ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(param, {
            in: {
                type: "CatchClause"
            },
            binding: BIND_CATCH_PARAM
        });
        return param;
    }
    parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.match(62)) {
            const clause = this.startNode();
            this.next();
            if (this.match(10)) {
                this.expect(10);
                clause.param = this.parseCatchClauseParam();
                this.expect(11);
            } else {
                clause.param = null;
                this.scope.enter(SCOPE_OTHER);
            }
            clause.body = this.withSmartMixTopicForbiddingContext(()=>this.parseBlock(false, false));
            this.scope.exit();
            node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) this.raise(Errors.NoCatchOrFinally, {
            at: node
        });
        return this.finishNode(node, "TryStatement");
    }
    parseVarStatement(node, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
    }
    parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
    }
    parseWithStatement(node) {
        if (this.state.strict) this.raise(Errors.StrictWith, {
            at: this.state.startLoc
        });
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
        return this.finishNode(node, "WithStatement");
    }
    parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
    }
    parseLabeledStatement(node, maybeName, expr, flags) {
        for (const label of this.state.labels)if (label.name === maybeName) this.raise(Errors.LabelRedeclaration, {
            at: expr,
            labelName: maybeName
        });
        const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
        for(let i = this.state.labels.length - 1; i >= 0; i--){
            const label = this.state.labels[i];
            if (label.statementStart === node.start) {
                label.statementStart = this.state.start;
                label.kind = kind;
            } else break;
        }
        this.state.labels.push({
            name: maybeName,
            kind: kind,
            statementStart: this.state.start
        });
        node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
    }
    parseExpressionStatement(node, expr, decorators) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
    }
    parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) this.state.strictErrors.clear();
        this.expect(5);
        if (createNewLexicalScope) this.scope.enter(SCOPE_OTHER);
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) this.scope.exit();
        return this.finishNode(node, "BlockStatement");
    }
    isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    }
    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while(!this.match(end)){
            const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
            if (directives && !parsedNonDirective) {
                if (this.isValidDirective(stmt)) {
                    const directive = this.stmtToDirective(stmt);
                    directives.push(directive);
                    if (!hasStrictModeDirective && directive.value.value === "use strict") {
                        hasStrictModeDirective = true;
                        this.setStrict(true);
                    }
                    continue;
                }
                parsedNonDirective = true;
                this.state.strictErrors.clear();
            }
            body.push(stmt);
        }
        if (afterBlockParse) afterBlockParse.call(this, hasStrictModeDirective);
        if (!oldStrict) this.setStrict(false);
        this.next();
    }
    parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
    }
    parseForIn(node, init, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        if (isForIn) {
            if (awaitAt !== null) this.unexpected(awaitAt);
        } else node.await = awaitAt !== null;
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(Errors.ForInOfLoopInitializer, {
            at: init,
            type: isForIn ? "ForInStatement" : "ForOfStatement"
        });
        if (init.type === "AssignmentPattern") this.raise(Errors.InvalidLhs, {
            at: init,
            ancestor: {
                type: "ForStatement"
            }
        });
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(node, isFor, kind, allowMissingInitializer = false) {
        const declarations = node.declarations = [];
        node.kind = kind;
        for(;;){
            const decl = this.startNode();
            this.parseVarId(decl, kind);
            decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
            if (decl.init === null && !allowMissingInitializer) {
                if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) this.raise(Errors.DeclarationMissingInitializer, {
                    at: this.state.lastTokEndLoc,
                    kind: "destructuring"
                });
                else if (kind === "const" && !(this.match(58) || this.isContextual(101))) this.raise(Errors.DeclarationMissingInitializer, {
                    at: this.state.lastTokEndLoc,
                    kind: "const"
                });
            }
            declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(12)) break;
        }
        return node;
    }
    parseVarId(decl, kind) {
        const id = this.parseBindingAtom();
        this.checkLVal(id, {
            in: {
                type: "VariableDeclarator"
            },
            binding: kind === "var" ? BIND_VAR : BIND_LEXICAL
        });
        decl.id = id;
    }
    parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, 8);
    }
    parseFunction(node, flags = 0) {
        const hangingDeclaration = flags & 2;
        const isDeclaration = !!(flags & 1);
        const requireId = isDeclaration && !(flags & 4);
        const isAsync = !!(flags & 8);
        this.initFunction(node, isAsync);
        if (this.match(55)) {
            if (hangingDeclaration) this.raise(Errors.GeneratorInSingleStatementContext, {
                at: this.state.startLoc
            });
            this.next();
            node.generator = true;
        }
        if (isDeclaration) node.id = this.parseFunctionId(requireId);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(SCOPE_FUNCTION);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        if (!isDeclaration) node.id = this.parseFunctionId();
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(()=>{
            this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isDeclaration && !hangingDeclaration) this.registerFunctionStatementId(node);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
    }
    parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(node, isConstructor) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
        this.expressionScope.exit();
    }
    registerFunctionStatementId(node) {
        if (!node.id) return;
        this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);
    }
    parseClass(node, isStatement, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
        return this.match(10);
    }
    isNonstaticConstructor(method) {
        return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
    }
    parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
            hadConstructor: false,
            hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(()=>{
            while(!this.match(8)){
                if (this.eat(13)) {
                    if (decorators.length > 0) throw this.raise(Errors.DecoratorSemicolon, {
                        at: this.state.lastTokEndLoc
                    });
                    continue;
                }
                if (this.match(26)) {
                    decorators.push(this.parseDecorator());
                    continue;
                }
                const member = this.startNode();
                if (decorators.length) {
                    member.decorators = decorators;
                    this.resetStartLocationFromNode(member, decorators[0]);
                    decorators = [];
                }
                this.parseClassMember(classBody, member, state);
                if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) this.raise(Errors.DecoratorConstructor, {
                    at: member
                });
            }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) throw this.raise(Errors.TrailingDecorator, {
            at: this.state.startLoc
        });
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
    }
    parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
            const method = member;
            method.kind = "method";
            method.computed = false;
            method.key = key;
            method.static = false;
            this.pushClassMethod(classBody, method, false, false, false, false);
            return true;
        } else if (this.isClassProperty()) {
            const prop = member;
            prop.computed = false;
            prop.key = key;
            prop.static = false;
            classBody.body.push(this.parseClassProperty(prop));
            return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
    }
    parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual(104);
        if (isStatic) {
            if (this.parseClassMemberFromModifier(classBody, member)) return;
            if (this.eat(5)) {
                this.parseClassStaticBlock(classBody, member);
                return;
            }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        this.parsePropertyNamePrefixOperator(member);
        if (this.eat(55)) {
            method.kind = "method";
            const isPrivateName = this.match(136);
            this.parseClassElementName(method);
            if (isPrivateName) {
                this.pushClassPrivateMethod(classBody, privateMethod, true, false);
                return;
            }
            if (this.isNonstaticConstructor(publicMethod)) this.raise(Errors.ConstructorIsGenerator, {
                at: publicMethod.key
            });
            this.pushClassMethod(classBody, publicMethod, true, false, false, false);
            return;
        }
        const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
        const isPrivate = this.match(136);
        const key = this.parseClassElementName(member);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
            method.kind = "method";
            if (isPrivate) {
                this.pushClassPrivateMethod(classBody, privateMethod, false, false);
                return;
            }
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = false;
            if (isConstructor) {
                publicMethod.kind = "constructor";
                if (state.hadConstructor && !this.hasPlugin("typescript")) this.raise(Errors.DuplicateConstructor, {
                    at: key
                });
                if (isConstructor && this.hasPlugin("typescript") && member.override) this.raise(Errors.OverrideOnConstructor, {
                    at: key
                });
                state.hadConstructor = true;
                allowsDirectSuper = state.hadSuperClass;
            }
            this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
            if (isPrivate) this.pushClassPrivateProperty(classBody, privateProp);
            else this.pushClassProperty(classBody, publicProp);
        } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(55);
            if (publicMember.optional) this.unexpected(maybeQuestionTokenStartLoc);
            method.kind = "method";
            const isPrivate = this.match(136);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(publicMember);
            if (isPrivate) this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
            else {
                if (this.isNonstaticConstructor(publicMethod)) this.raise(Errors.ConstructorIsAsync, {
                    at: publicMethod.key
                });
                this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
            }
        } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(key);
            method.kind = key.name;
            const isPrivate = this.match(136);
            this.parseClassElementName(publicMethod);
            if (isPrivate) this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            else {
                if (this.isNonstaticConstructor(publicMethod)) this.raise(Errors.ConstructorIsAccessor, {
                    at: publicMethod.key
                });
                this.pushClassMethod(classBody, publicMethod, false, false, false, false);
            }
            this.checkGetterSetterParams(publicMethod);
        } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
            this.expectPlugin("decoratorAutoAccessors");
            this.resetPreviousNodeTrailingComments(key);
            const isPrivate = this.match(136);
            this.parseClassElementName(publicProp);
            this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);
        } else if (this.isLineTerminator()) {
            if (isPrivate) this.pushClassPrivateProperty(classBody, privateProp);
            else this.pushClassProperty(classBody, publicProp);
        } else this.unexpected();
    }
    parseClassElementName(member) {
        const { type , value  } = this.state;
        if ((type === 130 || type === 131) && member.static && value === "prototype") this.raise(Errors.StaticPrototype, {
            at: this.state.startLoc
        });
        if (type === 136) {
            if (value === "constructor") this.raise(Errors.ConstructorClassPrivateField, {
                at: this.state.startLoc
            });
            const key = this.parsePrivateName();
            member.key = key;
            return key;
        }
        return this.parsePropertyName(member);
    }
    parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(PARAM);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) this.raise(Errors.DecoratorStaticBlock, {
            at: member
        });
    }
    pushClassProperty(classBody, prop) {
        if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) this.raise(Errors.ConstructorClassField, {
            at: prop.key
        });
        classBody.body.push(this.parseClassProperty(prop));
    }
    pushClassPrivateProperty(classBody, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
    }
    pushClassAccessorProperty(classBody, prop, isPrivate) {
        if (!isPrivate && !prop.computed) {
            const key = prop.key;
            if (key.name === "constructor" || key.value === "constructor") this.raise(Errors.ConstructorClassField, {
                at: key
            });
        }
        const node = this.parseClassAccessorProperty(prop);
        classBody.body.push(node);
        if (isPrivate) this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
        this.declareClassPrivateMethodInScope(node, kind);
    }
    declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
    }
    parsePostMemberNameModifiers(methodOrProp) {}
    parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassPrivateProperty");
    }
    parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassProperty");
    }
    parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassAccessorProperty");
    }
    parseInitializer(node) {
        this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(PARAM);
        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
    }
    parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
        if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            if (isStatement) this.declareNameFromIdentifier(node.id, bindingType);
        } else {
            if (optionalId || !isStatement) node.id = null;
            else throw this.raise(Errors.MissingClassName, {
                at: this.state.startLoc
            });
        }
    }
    parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(node, decorators) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
        const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
            if (hasDefault) this.unexpected();
            if (decorators) throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
            });
            this.parseExportFrom(node, true);
            return this.finishNode(node, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) this.unexpected(null, 5);
        if (hasNamespace && parseAfterNamespace) this.unexpected(null, 97);
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
            hasDeclaration = false;
            if (decorators) throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
            });
            this.parseExportFrom(node, isFromRequired);
        } else hasDeclaration = this.maybeParseExportDeclaration(node);
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
            var _node2$declaration;
            const node2 = node;
            this.checkExport(node2, true, false, !!node2.source);
            if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") this.maybeTakeDecorators(decorators, node2.declaration, node2);
            else if (decorators) throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
            });
            return this.finishNode(node2, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
            const node2 = node;
            const decl = this.parseExportDefaultExpression();
            node2.declaration = decl;
            if (decl.type === "ClassDeclaration") this.maybeTakeDecorators(decorators, decl, node2);
            else if (decorators) throw this.raise(Errors.UnsupportedDecoratorExport, {
                at: node
            });
            this.checkExport(node2, true, true);
            return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        this.unexpected(null, 5);
    }
    eatExportStar(node) {
        return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
            const id = maybeDefaultIdentifier || this.parseIdentifier(true);
            const specifier = this.startNodeAtNode(id);
            specifier.exported = id;
            node.specifiers = [
                this.finishNode(specifier, "ExportDefaultSpecifier")
            ];
            return true;
        }
        return false;
    }
    maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
            if (!node.specifiers) node.specifiers = [];
            const specifier = this.startNodeAt(this.state.lastTokStartLoc);
            this.next();
            specifier.exported = this.parseModuleExportName();
            node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
            return true;
        }
        return false;
    }
    maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
            if (!node.specifiers) node.specifiers = [];
            const isTypeExport = node.exportKind === "type";
            node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
            node.source = null;
            node.declaration = null;
            if (this.hasPlugin("importAssertions")) node.assertions = [];
            return true;
        }
        return false;
    }
    maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
            node.specifiers = [];
            node.source = null;
            if (this.hasPlugin("importAssertions")) node.assertions = [];
            node.declaration = this.parseExportDeclaration(node);
            return true;
        }
        return false;
    }
    isAsyncFunction() {
        if (!this.isContextual(95)) return false;
        const next = this.nextTokenInLineStart();
        return this.isUnparsedContextual(next, "function");
    }
    parseExportDefaultExpression() {
        const expr = this.startNode();
        if (this.match(68)) {
            this.next();
            return this.parseFunction(expr, 5);
        } else if (this.isAsyncFunction()) {
            this.next();
            this.next();
            return this.parseFunction(expr, 13);
        }
        if (this.match(80)) return this.parseClass(expr, true, true);
        if (this.match(26)) {
            if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) this.raise(Errors.DecoratorBeforeExport, {
                at: this.state.startLoc
            });
            return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(Errors.UnsupportedDefaultExport, {
            at: this.state.startLoc
        });
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
    }
    parseExportDeclaration(node) {
        if (this.match(80)) {
            const node = this.parseClass(this.startNode(), true, false);
            return node;
        }
        return this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
        const { type  } = this.state;
        if (tokenIsIdentifier(type)) {
            if (type === 95 && !this.state.containsEsc || type === 99) return false;
            if ((type === 128 || type === 127) && !this.state.containsEsc) {
                const { type: nextType  } = this.lookahead();
                if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {
                    this.expectOnePlugin([
                        "flow",
                        "typescript"
                    ]);
                    return false;
                }
            }
        } else if (!this.match(65)) return false;
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) return true;
        if (this.match(65) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
            return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
    }
    parseExportFrom(node, expect) {
        if (this.eatContextual(97)) {
            node.source = this.parseImportSource();
            this.checkExport(node);
            this.maybeParseImportAttributes(node);
            this.checkJSONModuleImport(node);
        } else if (expect) this.unexpected();
        this.semicolon();
    }
    shouldParseExportDeclaration() {
        const { type  } = this.state;
        if (type === 26) {
            this.expectOnePlugin([
                "decorators",
                "decorators-legacy"
            ]);
            if (this.hasPlugin("decorators")) {
                if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) this.raise(Errors.DecoratorBeforeExport, {
                    at: this.state.startLoc
                });
                return true;
            }
        }
        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
            if (isDefault) {
                this.checkDuplicateExports(node, "default");
                if (this.hasPlugin("exportDefaultFrom")) {
                    var _declaration$extra;
                    const declaration = node.declaration;
                    if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) this.raise(Errors.ExportDefaultFromAsIdentifier, {
                        at: declaration
                    });
                }
            } else if (node.specifiers && node.specifiers.length) for (const specifier of node.specifiers){
                const { exported  } = specifier;
                const exportName = exported.type === "Identifier" ? exported.name : exported.value;
                this.checkDuplicateExports(specifier, exportName);
                if (!isFrom && specifier.local) {
                    const { local  } = specifier;
                    if (local.type !== "Identifier") this.raise(Errors.ExportBindingIsString, {
                        at: specifier,
                        localName: local.value,
                        exportName
                    });
                    else {
                        this.checkReservedWord(local.name, local.loc.start, true, false);
                        this.scope.checkLocalExport(local);
                    }
                }
            }
            else if (node.declaration) {
                if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
                    const id = node.declaration.id;
                    if (!id) throw new Error("Assertion failure");
                    this.checkDuplicateExports(node, id.name);
                } else if (node.declaration.type === "VariableDeclaration") for (const declaration of node.declaration.declarations)this.checkDeclaration(declaration.id);
            }
        }
    }
    checkDeclaration(node) {
        if (node.type === "Identifier") this.checkDuplicateExports(node, node.name);
        else if (node.type === "ObjectPattern") for (const prop of node.properties)this.checkDeclaration(prop);
        else if (node.type === "ArrayPattern") {
            for (const elem of node.elements)if (elem) this.checkDeclaration(elem);
        } else if (node.type === "ObjectProperty") this.checkDeclaration(node.value);
        else if (node.type === "RestElement") this.checkDeclaration(node.argument);
        else if (node.type === "AssignmentPattern") this.checkDeclaration(node.left);
    }
    checkDuplicateExports(node, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
            if (exportName === "default") this.raise(Errors.DuplicateDefaultExport, {
                at: node
            });
            else this.raise(Errors.DuplicateExport, {
                at: node,
                exportName
            });
        }
        this.exportedIdentifiers.add(exportName);
    }
    parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first = true;
        this.expect(5);
        while(!this.eat(8)){
            if (first) first = false;
            else {
                this.expect(12);
                if (this.eat(8)) break;
            }
            const isMaybeTypeOnly = this.isContextual(128);
            const isString = this.match(131);
            const node = this.startNode();
            node.local = this.parseModuleExportName();
            nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
    }
    parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) node.exported = this.parseModuleExportName();
        else if (isString) node.exported = cloneStringLiteral(node.local);
        else if (!node.exported) node.exported = cloneIdentifier(node.local);
        return this.finishNode(node, "ExportSpecifier");
    }
    parseModuleExportName() {
        if (this.match(131)) {
            const result = this.parseStringLiteral(this.state.value);
            const surrogate = result.value.match(loneSurrogate);
            if (surrogate) this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
                at: result,
                surrogateCharCode: surrogate[0].charCodeAt(0)
            });
            return result;
        }
        return this.parseIdentifier(true);
    }
    isJSONModuleImport(node) {
        if (node.assertions != null) return node.assertions.some(({ key , value  })=>{
            return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
        });
        return false;
    }
    checkImportReflection(node) {
        if (node.module) {
            var _node$assertions;
            if (node.specifiers.length !== 1 || node.specifiers[0].type !== "ImportDefaultSpecifier") this.raise(Errors.ImportReflectionNotBinding, {
                at: node.specifiers[0].loc.start
            });
            if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) this.raise(Errors.ImportReflectionHasAssertion, {
                at: node.specifiers[0].loc.start
            });
        }
    }
    checkJSONModuleImport(node) {
        if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
            const { specifiers  } = node;
            if (specifiers != null) {
                const nonDefaultNamedSpecifier = specifiers.find((specifier)=>{
                    let imported;
                    if (specifier.type === "ExportSpecifier") imported = specifier.local;
                    else if (specifier.type === "ImportSpecifier") imported = specifier.imported;
                    if (imported !== undefined) return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
                });
                if (nonDefaultNamedSpecifier !== undefined) this.raise(Errors.ImportJSONBindingNotDefault, {
                    at: nonDefaultNamedSpecifier.loc.start
                });
            }
        }
    }
    isPotentialImportPhase(isExport) {
        return !isExport && this.isContextual(125);
    }
    applyImportPhase(node, isExport, phase, loc) {
        if (isExport) return;
        if (phase === "module") {
            this.expectPlugin("importReflection", loc);
            node.module = true;
        } else if (this.hasPlugin("importReflection")) node.module = false;
    }
    parseMaybeImportPhase(node, isExport) {
        if (!this.isPotentialImportPhase(isExport)) {
            this.applyImportPhase(node, isExport, null);
            return null;
        }
        const phaseIdentifier = this.parseIdentifier(true);
        const { type  } = this.state;
        const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 97 || this.lookaheadCharCode() === 102 : type !== 12;
        if (isImportPhase) {
            this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
            this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
            return null;
        } else {
            this.applyImportPhase(node, isExport, null);
            return phaseIdentifier;
        }
    }
    isPrecedingIdImportPhase(phase) {
        const { type  } = this.state;
        return tokenIsIdentifier(type) ? type !== 97 || this.lookaheadCharCode() === 102 : type !== 12;
    }
    parseImport(node) {
        if (this.match(131)) return this.parseImportSourceAndAttributes(node);
        return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
    }
    parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
        node.specifiers = [];
        const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
        const parseNext = !hasDefault || this.eat(12);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual(97);
        return this.parseImportSourceAndAttributes(node);
    }
    parseImportSourceAndAttributes(node) {
        var _node$specifiers;
        (_node$specifiers = node.specifiers) != null ? _node$specifiers : node.specifiers = [];
        node.source = this.parseImportSource();
        this.maybeParseImportAttributes(node);
        this.checkImportReflection(node);
        this.checkJSONModuleImport(node);
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
    }
    parseImportSource() {
        if (!this.match(131)) this.unexpected();
        return this.parseExprAtom();
    }
    parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
    }
    finishImportSpecifier(specifier, type, bindingType = BIND_LEXICAL) {
        this.checkLVal(specifier.local, {
            in: {
                type
            },
            binding: bindingType
        });
        return this.finishNode(specifier, type);
    }
    parseImportAttributes() {
        this.expect(5);
        const attrs = [];
        const attrNames = new Set();
        do {
            if (this.match(8)) break;
            const node = this.startNode();
            const keyName = this.state.value;
            if (attrNames.has(keyName)) this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: this.state.startLoc,
                key: keyName
            });
            attrNames.add(keyName);
            if (this.match(131)) node.key = this.parseStringLiteral(keyName);
            else node.key = this.parseIdentifier(true);
            this.expect(14);
            if (!this.match(131)) throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
            });
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, "ImportAttribute"));
        }while (this.eat(12));
        this.expect(8);
        return attrs;
    }
    parseModuleAttributes() {
        const attrs = [];
        const attributes = new Set();
        do {
            const node = this.startNode();
            node.key = this.parseIdentifier(true);
            if (node.key.name !== "type") this.raise(Errors.ModuleAttributeDifferentFromType, {
                at: node.key
            });
            if (attributes.has(node.key.name)) this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: node.key,
                key: node.key.name
            });
            attributes.add(node.key.name);
            this.expect(14);
            if (!this.match(131)) throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
            });
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, "ImportAttribute"));
        }while (this.eat(12));
        return attrs;
    }
    maybeParseImportAttributes(node) {
        let attributes;
        let useWith = false;
        if (this.match(76)) {
            if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
            this.next();
            if (this.hasPlugin("moduleAttributes")) attributes = this.parseModuleAttributes();
            else {
                this.expectImportAttributesPlugin();
                attributes = this.parseImportAttributes();
            }
            useWith = true;
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
            if (this.hasPlugin("importAttributes")) {
                if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true) this.raise(Errors.ImportAttributesUseAssert, {
                    at: this.state.startLoc
                });
                this.addExtra(node, "deprecatedAssertSyntax", true);
            } else this.expectOnePlugin([
                "importAttributes",
                "importAssertions"
            ]);
            this.next();
            attributes = this.parseImportAttributes();
        } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) attributes = [];
        else {
            if (this.hasPlugin("moduleAttributes")) attributes = [];
            else return;
        }
        if (!useWith && this.hasPlugin("importAssertions")) node.assertions = attributes;
        else node.attributes = attributes;
    }
    maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
            const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
            specifier.local = maybeDefaultIdentifier;
            node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
            return true;
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
            return true;
        }
        return false;
    }
    maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
            const specifier = this.startNode();
            this.next();
            this.expectContextual(93);
            this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
            return true;
        }
        return false;
    }
    parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(5);
        while(!this.eat(8)){
            if (first) first = false;
            else {
                if (this.eat(14)) throw this.raise(Errors.DestructureNamedImport, {
                    at: this.state.startLoc
                });
                this.expect(12);
                if (this.eat(8)) break;
            }
            const specifier = this.startNode();
            const importedIsString = this.match(131);
            const isMaybeTypeOnly = this.isContextual(128);
            specifier.imported = this.parseModuleExportName();
            const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, undefined);
            node.specifiers.push(importSpecifier);
        }
    }
    parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93)) specifier.local = this.parseIdentifier();
        else {
            const { imported  } = specifier;
            if (importedIsString) throw this.raise(Errors.ImportBindingIsString, {
                at: specifier,
                importName: imported.value
            });
            this.checkReservedWord(imported.name, specifier.loc.start, true, true);
            if (!specifier.local) specifier.local = cloneIdentifier(imported);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
    }
    isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
    }
}
class Parser extends StatementParser {
    constructor(options, input){
        options = getOptions(options);
        super(options, input);
        this.options = options;
        this.initializeScopes();
        this.plugins = pluginsMap(this.options.plugins);
        this.filename = options.sourceFilename;
    }
    getScopeHandler() {
        return ScopeHandler;
    }
    parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program);
        file.errors = this.state.errors;
        return file;
    }
}
function pluginsMap(plugins) {
    const pluginMap = new Map();
    for (const plugin of plugins){
        const [name, options] = Array.isArray(plugin) ? plugin : [
            plugin,
            {}
        ];
        if (!pluginMap.has(name)) pluginMap.set(name, options || {});
    }
    return pluginMap;
}
function parse(input, options) {
    var _options;
    if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
            options.sourceType = "module";
            const parser = getParser(options, input);
            const ast = parser.parse();
            if (parser.sawUnambiguousESM) return ast;
            if (parser.ambiguousScriptDifferentAst) try {
                options.sourceType = "script";
                return getParser(options, input).parse();
            } catch (_unused) {}
            else ast.program.sourceType = "script";
            return ast;
        } catch (moduleError) {
            try {
                options.sourceType = "script";
                return getParser(options, input).parse();
            } catch (_unused2) {}
            throw moduleError;
        }
    } else return getParser(options, input).parse();
}
function parseExpression(input, options) {
    const parser = getParser(options, input);
    if (parser.options.strictMode) parser.state.strict = true;
    return parser.getExpression();
}
function generateExportedTokenTypes(internalTokenTypes) {
    const tokenTypes = {};
    for (const typeName of Object.keys(internalTokenTypes))tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);
    return tokenTypes;
}
const tokTypes = generateExportedTokenTypes(tt);
function getParser(options, input) {
    let cls = Parser;
    if (options != null && options.plugins) {
        validatePlugins(options.plugins);
        cls = getParserClass(options.plugins);
    }
    return new cls(options, input);
}
const parserClassCache = {};
function getParserClass(pluginsFromOptions) {
    const pluginList = mixinPluginNames.filter((name)=>hasPlugin(pluginsFromOptions, name));
    const key = pluginList.join("/");
    let cls = parserClassCache[key];
    if (!cls) {
        cls = Parser;
        for (const plugin of pluginList)cls = mixinPlugins[plugin](cls);
        parserClassCache[key] = cls;
    }
    return cls;
}
exports.parse = parse;
exports.parseExpression = parseExpression;
exports.tokTypes = tokTypes;

},{}],"hnm3y":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _exportNames = {
    react: true,
    assertNode: true,
    createTypeAnnotationBasedOnTypeof: true,
    createUnionTypeAnnotation: true,
    createFlowUnionType: true,
    createTSUnionType: true,
    cloneNode: true,
    clone: true,
    cloneDeep: true,
    cloneDeepWithoutLoc: true,
    cloneWithoutLoc: true,
    addComment: true,
    addComments: true,
    inheritInnerComments: true,
    inheritLeadingComments: true,
    inheritsComments: true,
    inheritTrailingComments: true,
    removeComments: true,
    ensureBlock: true,
    toBindingIdentifierName: true,
    toBlock: true,
    toComputedKey: true,
    toExpression: true,
    toIdentifier: true,
    toKeyAlias: true,
    toSequenceExpression: true,
    toStatement: true,
    valueToNode: true,
    appendToMemberExpression: true,
    inherits: true,
    prependToMemberExpression: true,
    removeProperties: true,
    removePropertiesDeep: true,
    removeTypeDuplicates: true,
    getBindingIdentifiers: true,
    getOuterBindingIdentifiers: true,
    traverse: true,
    traverseFast: true,
    shallowEqual: true,
    is: true,
    isBinding: true,
    isBlockScoped: true,
    isImmutable: true,
    isLet: true,
    isNode: true,
    isNodesEquivalent: true,
    isPlaceholderType: true,
    isReferenced: true,
    isScope: true,
    isSpecifierDefault: true,
    isType: true,
    isValidES3Identifier: true,
    isValidIdentifier: true,
    isVar: true,
    matchesPattern: true,
    validate: true,
    buildMatchMemberExpression: true,
    __internal__deprecationWarning: true
};
Object.defineProperty(exports, "__internal__deprecationWarning", {
    enumerable: true,
    get: function() {
        return _deprecationWarning.default;
    }
});
Object.defineProperty(exports, "addComment", {
    enumerable: true,
    get: function() {
        return _addComment.default;
    }
});
Object.defineProperty(exports, "addComments", {
    enumerable: true,
    get: function() {
        return _addComments.default;
    }
});
Object.defineProperty(exports, "appendToMemberExpression", {
    enumerable: true,
    get: function() {
        return _appendToMemberExpression.default;
    }
});
Object.defineProperty(exports, "assertNode", {
    enumerable: true,
    get: function() {
        return _assertNode.default;
    }
});
Object.defineProperty(exports, "buildMatchMemberExpression", {
    enumerable: true,
    get: function() {
        return _buildMatchMemberExpression.default;
    }
});
Object.defineProperty(exports, "clone", {
    enumerable: true,
    get: function() {
        return _clone.default;
    }
});
Object.defineProperty(exports, "cloneDeep", {
    enumerable: true,
    get: function() {
        return _cloneDeep.default;
    }
});
Object.defineProperty(exports, "cloneDeepWithoutLoc", {
    enumerable: true,
    get: function() {
        return _cloneDeepWithoutLoc.default;
    }
});
Object.defineProperty(exports, "cloneNode", {
    enumerable: true,
    get: function() {
        return _cloneNode.default;
    }
});
Object.defineProperty(exports, "cloneWithoutLoc", {
    enumerable: true,
    get: function() {
        return _cloneWithoutLoc.default;
    }
});
Object.defineProperty(exports, "createFlowUnionType", {
    enumerable: true,
    get: function() {
        return _createFlowUnionType.default;
    }
});
Object.defineProperty(exports, "createTSUnionType", {
    enumerable: true,
    get: function() {
        return _createTSUnionType.default;
    }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
    enumerable: true,
    get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
    }
});
Object.defineProperty(exports, "createUnionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _createFlowUnionType.default;
    }
});
Object.defineProperty(exports, "ensureBlock", {
    enumerable: true,
    get: function() {
        return _ensureBlock.default;
    }
});
Object.defineProperty(exports, "getBindingIdentifiers", {
    enumerable: true,
    get: function() {
        return _getBindingIdentifiers.default;
    }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
    enumerable: true,
    get: function() {
        return _getOuterBindingIdentifiers.default;
    }
});
Object.defineProperty(exports, "inheritInnerComments", {
    enumerable: true,
    get: function() {
        return _inheritInnerComments.default;
    }
});
Object.defineProperty(exports, "inheritLeadingComments", {
    enumerable: true,
    get: function() {
        return _inheritLeadingComments.default;
    }
});
Object.defineProperty(exports, "inheritTrailingComments", {
    enumerable: true,
    get: function() {
        return _inheritTrailingComments.default;
    }
});
Object.defineProperty(exports, "inherits", {
    enumerable: true,
    get: function() {
        return _inherits.default;
    }
});
Object.defineProperty(exports, "inheritsComments", {
    enumerable: true,
    get: function() {
        return _inheritsComments.default;
    }
});
Object.defineProperty(exports, "is", {
    enumerable: true,
    get: function() {
        return _is.default;
    }
});
Object.defineProperty(exports, "isBinding", {
    enumerable: true,
    get: function() {
        return _isBinding.default;
    }
});
Object.defineProperty(exports, "isBlockScoped", {
    enumerable: true,
    get: function() {
        return _isBlockScoped.default;
    }
});
Object.defineProperty(exports, "isImmutable", {
    enumerable: true,
    get: function() {
        return _isImmutable.default;
    }
});
Object.defineProperty(exports, "isLet", {
    enumerable: true,
    get: function() {
        return _isLet.default;
    }
});
Object.defineProperty(exports, "isNode", {
    enumerable: true,
    get: function() {
        return _isNode.default;
    }
});
Object.defineProperty(exports, "isNodesEquivalent", {
    enumerable: true,
    get: function() {
        return _isNodesEquivalent.default;
    }
});
Object.defineProperty(exports, "isPlaceholderType", {
    enumerable: true,
    get: function() {
        return _isPlaceholderType.default;
    }
});
Object.defineProperty(exports, "isReferenced", {
    enumerable: true,
    get: function() {
        return _isReferenced.default;
    }
});
Object.defineProperty(exports, "isScope", {
    enumerable: true,
    get: function() {
        return _isScope.default;
    }
});
Object.defineProperty(exports, "isSpecifierDefault", {
    enumerable: true,
    get: function() {
        return _isSpecifierDefault.default;
    }
});
Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
        return _isType.default;
    }
});
Object.defineProperty(exports, "isValidES3Identifier", {
    enumerable: true,
    get: function() {
        return _isValidES3Identifier.default;
    }
});
Object.defineProperty(exports, "isValidIdentifier", {
    enumerable: true,
    get: function() {
        return _isValidIdentifier.default;
    }
});
Object.defineProperty(exports, "isVar", {
    enumerable: true,
    get: function() {
        return _isVar.default;
    }
});
Object.defineProperty(exports, "matchesPattern", {
    enumerable: true,
    get: function() {
        return _matchesPattern.default;
    }
});
Object.defineProperty(exports, "prependToMemberExpression", {
    enumerable: true,
    get: function() {
        return _prependToMemberExpression.default;
    }
});
exports.react = void 0;
Object.defineProperty(exports, "removeComments", {
    enumerable: true,
    get: function() {
        return _removeComments.default;
    }
});
Object.defineProperty(exports, "removeProperties", {
    enumerable: true,
    get: function() {
        return _removeProperties.default;
    }
});
Object.defineProperty(exports, "removePropertiesDeep", {
    enumerable: true,
    get: function() {
        return _removePropertiesDeep.default;
    }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
    enumerable: true,
    get: function() {
        return _removeTypeDuplicates.default;
    }
});
Object.defineProperty(exports, "shallowEqual", {
    enumerable: true,
    get: function() {
        return _shallowEqual.default;
    }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
    enumerable: true,
    get: function() {
        return _toBindingIdentifierName.default;
    }
});
Object.defineProperty(exports, "toBlock", {
    enumerable: true,
    get: function() {
        return _toBlock.default;
    }
});
Object.defineProperty(exports, "toComputedKey", {
    enumerable: true,
    get: function() {
        return _toComputedKey.default;
    }
});
Object.defineProperty(exports, "toExpression", {
    enumerable: true,
    get: function() {
        return _toExpression.default;
    }
});
Object.defineProperty(exports, "toIdentifier", {
    enumerable: true,
    get: function() {
        return _toIdentifier.default;
    }
});
Object.defineProperty(exports, "toKeyAlias", {
    enumerable: true,
    get: function() {
        return _toKeyAlias.default;
    }
});
Object.defineProperty(exports, "toSequenceExpression", {
    enumerable: true,
    get: function() {
        return _toSequenceExpression.default;
    }
});
Object.defineProperty(exports, "toStatement", {
    enumerable: true,
    get: function() {
        return _toStatement.default;
    }
});
Object.defineProperty(exports, "traverse", {
    enumerable: true,
    get: function() {
        return _traverse.default;
    }
});
Object.defineProperty(exports, "traverseFast", {
    enumerable: true,
    get: function() {
        return _traverseFast.default;
    }
});
Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
        return _validate.default;
    }
});
Object.defineProperty(exports, "valueToNode", {
    enumerable: true,
    get: function() {
        return _valueToNode.default;
    }
});
var _isReactComponent = require("45e6912d973b64ff");
var _isCompatTag = require("bbfbdcd11484ee90");
var _buildChildren = require("1cbd745125e24317");
var _assertNode = require("56eb6e4fadc87141");
var _generated = require("ec9bc5762873e7df");
Object.keys(_generated).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated[key];
        }
    });
});
var _createTypeAnnotationBasedOnTypeof = require("71282f1f21cf37a6");
var _createFlowUnionType = require("499beb211f5aea95");
var _createTSUnionType = require("ab03c7553b487516");
var _generated2 = require("64ffed59dcef7d63");
Object.keys(_generated2).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated2[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated2[key];
        }
    });
});
var _uppercase = require("13586cfb0b495d37");
Object.keys(_uppercase).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _uppercase[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _uppercase[key];
        }
    });
});
var _cloneNode = require("e3378e97a85915c4");
var _clone = require("e865f924ee84e0b5");
var _cloneDeep = require("2f89470c01a67ece");
var _cloneDeepWithoutLoc = require("da828b6efe2da4a3");
var _cloneWithoutLoc = require("b36a0c52267f2bf0");
var _addComment = require("17272efd009e8c98");
var _addComments = require("bf9465b35614b667");
var _inheritInnerComments = require("8eb75f0b9158c968");
var _inheritLeadingComments = require("85ba38848561a611");
var _inheritsComments = require("4005714f3fb03c70");
var _inheritTrailingComments = require("d20d944768f73149");
var _removeComments = require("d4df03ba3b5cd6b9");
var _generated3 = require("626889ce431550c1");
Object.keys(_generated3).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated3[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated3[key];
        }
    });
});
var _constants = require("712997c36162f141");
Object.keys(_constants).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _constants[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _constants[key];
        }
    });
});
var _ensureBlock = require("ea89627a0bd91f4f");
var _toBindingIdentifierName = require("3a10c030d44d1c81");
var _toBlock = require("307ef4ac0d69dc09");
var _toComputedKey = require("8c015ca822160f35");
var _toExpression = require("86181438e9fc1a5f");
var _toIdentifier = require("54dfb1edd1437ce9");
var _toKeyAlias = require("2bee035eebab3fc9");
var _toSequenceExpression = require("aae695013013a67d");
var _toStatement = require("c7b8a05e7430cdf7");
var _valueToNode = require("ddeaccea763fcd38");
var _definitions = require("9a411f17bc9d984");
Object.keys(_definitions).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _definitions[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _definitions[key];
        }
    });
});
var _appendToMemberExpression = require("bbb89ea465abc13");
var _inherits = require("409c6cb9bf006517");
var _prependToMemberExpression = require("11d605274061041b");
var _removeProperties = require("c833c1f09d998cd0");
var _removePropertiesDeep = require("3c0e3d6c3d4e6e13");
var _removeTypeDuplicates = require("5a47f611038bc32c");
var _getBindingIdentifiers = require("d64b93ac3e9abd81");
var _getOuterBindingIdentifiers = require("15541c333d7b5ecd");
var _traverse = require("c7acec6ead7e22d6");
Object.keys(_traverse).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _traverse[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _traverse[key];
        }
    });
});
var _traverseFast = require("85b1ddd736539b81");
var _shallowEqual = require("70db01c3909cf926");
var _is = require("9b25faaeb76c364d");
var _isBinding = require("178ff5cc3b66598b");
var _isBlockScoped = require("eb2e1afc97f2f4a8");
var _isImmutable = require("437b1844d119fd68");
var _isLet = require("d12733349aef4d66");
var _isNode = require("20b0617be4deb161");
var _isNodesEquivalent = require("84600d6006257579");
var _isPlaceholderType = require("d27652db9a09a647");
var _isReferenced = require("bc68f636aed929a4");
var _isScope = require("5c6a406b49057e80");
var _isSpecifierDefault = require("f145b5a57ba31f05");
var _isType = require("f5adfd408225a10e");
var _isValidES3Identifier = require("ec6f3320cfd7f829");
var _isValidIdentifier = require("d2d85d8237f3f828");
var _isVar = require("114892dee4bed629");
var _matchesPattern = require("7ec34dbc5bad9018");
var _validate = require("5d95d6813640c3da");
var _buildMatchMemberExpression = require("c533a0cc6601179f");
var _generated4 = require("681971f794315140");
Object.keys(_generated4).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated4[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated4[key];
        }
    });
});
var _deprecationWarning = require("c91876ead7c5ed54");
const react = {
    isReactComponent: _isReactComponent.default,
    isCompatTag: _isCompatTag.default,
    buildChildren: _buildChildren.default
};
exports.react = react;

},{"45e6912d973b64ff":"lPFam","bbfbdcd11484ee90":"fLCOL","1cbd745125e24317":"fopPj","56eb6e4fadc87141":"aReY1","ec9bc5762873e7df":"ff7JR","71282f1f21cf37a6":"029ot","499beb211f5aea95":"ibg5t","ab03c7553b487516":"fgFzg","64ffed59dcef7d63":"fvX9A","13586cfb0b495d37":"5Eayz","e3378e97a85915c4":"dSpB5","e865f924ee84e0b5":"fR7E2","2f89470c01a67ece":"hCb55","da828b6efe2da4a3":"4fIeZ","b36a0c52267f2bf0":"f2GBU","17272efd009e8c98":"feFUq","bf9465b35614b667":"hkQTK","8eb75f0b9158c968":"9uTML","85ba38848561a611":"6bm0A","4005714f3fb03c70":"2fk6o","d20d944768f73149":"7p2Q8","d4df03ba3b5cd6b9":"ld5OA","626889ce431550c1":"4shEB","712997c36162f141":"dHy0S","ea89627a0bd91f4f":"fsDMl","3a10c030d44d1c81":"hoi4j","307ef4ac0d69dc09":"7jRMp","8c015ca822160f35":"9A3PE","86181438e9fc1a5f":"j2Ei2","54dfb1edd1437ce9":"bZr91","2bee035eebab3fc9":"2mp3d","aae695013013a67d":"dQ3Xe","c7b8a05e7430cdf7":"bdr8R","ddeaccea763fcd38":"7nKLb","9a411f17bc9d984":"32frq","bbb89ea465abc13":"3EoGP","409c6cb9bf006517":"c0pUW","11d605274061041b":"gltcL","c833c1f09d998cd0":"9jgoG","3c0e3d6c3d4e6e13":"6an75","5a47f611038bc32c":"jX5sp","d64b93ac3e9abd81":"jZjJ0","15541c333d7b5ecd":"bIpkE","c7acec6ead7e22d6":"fgXi5","85b1ddd736539b81":"1xVK0","70db01c3909cf926":"cmTeP","9b25faaeb76c364d":"1iNYH","178ff5cc3b66598b":"fYWFw","eb2e1afc97f2f4a8":"bwozb","437b1844d119fd68":"3MWUv","d12733349aef4d66":"9OjDp","20b0617be4deb161":"ldCSD","84600d6006257579":"btgKJ","d27652db9a09a647":"gZjtX","bc68f636aed929a4":"ic2HW","5c6a406b49057e80":"ddb3V","f145b5a57ba31f05":"gQ4Hx","f5adfd408225a10e":"8A4sW","ec6f3320cfd7f829":"iyBPq","d2d85d8237f3f828":"co3Ir","114892dee4bed629":"2trSd","7ec34dbc5bad9018":"7wZ4r","5d95d6813640c3da":"5qUw2","c533a0cc6601179f":"efOj2","681971f794315140":"lrUKn","c91876ead7c5ed54":"dnmbV"}],"lPFam":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _buildMatchMemberExpression = require("8347d035cb23caf7");
const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
var _default = isReactComponent;
exports.default = _default;

},{"8347d035cb23caf7":"efOj2"}],"efOj2":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = buildMatchMemberExpression;
var _matchesPattern = require("7a7082c21fc2cf4b");
function buildMatchMemberExpression(match, allowPartial) {
    const parts = match.split(".");
    return (member)=>(0, _matchesPattern.default)(member, parts, allowPartial);
}

},{"7a7082c21fc2cf4b":"7wZ4r"}],"7wZ4r":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = matchesPattern;
var _generated = require("c394928feaecdae6");
function matchesPattern(member, match, allowPartial) {
    if (!(0, _generated.isMemberExpression)(member)) return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node;
    for(node = member; (0, _generated.isMemberExpression)(node); node = node.object)nodes.push(node.property);
    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;
    for(let i = 0, j = nodes.length - 1; i < parts.length; i++, j--){
        const node = nodes[j];
        let value;
        if ((0, _generated.isIdentifier)(node)) value = node.name;
        else if ((0, _generated.isStringLiteral)(node)) value = node.value;
        else if ((0, _generated.isThisExpression)(node)) value = "this";
        else return false;
        if (parts[i] !== value) return false;
    }
    return true;
}

},{"c394928feaecdae6":"lrUKn"}],"lrUKn":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAccessor = isAccessor;
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isArrayExpression = isArrayExpression;
exports.isArrayPattern = isArrayPattern;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isAwaitExpression = isAwaitExpression;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isBinary = isBinary;
exports.isBinaryExpression = isBinaryExpression;
exports.isBindExpression = isBindExpression;
exports.isBlock = isBlock;
exports.isBlockParent = isBlockParent;
exports.isBlockStatement = isBlockStatement;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isClass = isClass;
exports.isClassAccessorProperty = isClassAccessorProperty;
exports.isClassBody = isClassBody;
exports.isClassDeclaration = isClassDeclaration;
exports.isClassExpression = isClassExpression;
exports.isClassImplements = isClassImplements;
exports.isClassMethod = isClassMethod;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassProperty = isClassProperty;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDecimalLiteral = isDecimalLiteral;
exports.isDeclaration = isDeclaration;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isDecorator = isDecorator;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isDoExpression = isDoExpression;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isEnumBody = isEnumBody;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isEnumMember = isEnumMember;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isExportSpecifier = isExportSpecifier;
exports.isExpression = isExpression;
exports.isExpressionStatement = isExpressionStatement;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFile = isFile;
exports.isFlow = isFlow;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isFlowType = isFlowType;
exports.isFor = isFor;
exports.isForInStatement = isForInStatement;
exports.isForOfStatement = isForOfStatement;
exports.isForStatement = isForStatement;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isFunctionParent = isFunctionParent;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isImmutable = isImmutable;
exports.isImport = isImport;
exports.isImportAttribute = isImportAttribute;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
exports.isImportSpecifier = isImportSpecifier;
exports.isIndexedAccessType = isIndexedAccessType;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isJSX = isJSX;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXFragment = isJSXFragment;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXText = isJSXText;
exports.isLVal = isLVal;
exports.isLabeledStatement = isLabeledStatement;
exports.isLiteral = isLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isLoop = isLoop;
exports.isMemberExpression = isMemberExpression;
exports.isMetaProperty = isMetaProperty;
exports.isMethod = isMethod;
exports.isMiscellaneous = isMiscellaneous;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isModuleExpression = isModuleExpression;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isNewExpression = isNewExpression;
exports.isNoop = isNoop;
exports.isNullLiteral = isNullLiteral;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteral = isNumberLiteral;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isNumericLiteral = isNumericLiteral;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMember = isObjectMember;
exports.isObjectMethod = isObjectMethod;
exports.isObjectPattern = isObjectPattern;
exports.isObjectProperty = isObjectProperty;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isPattern = isPattern;
exports.isPatternLike = isPatternLike;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPlaceholder = isPlaceholder;
exports.isPrivate = isPrivate;
exports.isPrivateName = isPrivateName;
exports.isProgram = isProgram;
exports.isProperty = isProperty;
exports.isPureish = isPureish;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isRecordExpression = isRecordExpression;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestElement = isRestElement;
exports.isRestProperty = isRestProperty;
exports.isReturnStatement = isReturnStatement;
exports.isScopable = isScopable;
exports.isSequenceExpression = isSequenceExpression;
exports.isSpreadElement = isSpreadElement;
exports.isSpreadProperty = isSpreadProperty;
exports.isStandardized = isStandardized;
exports.isStatement = isStatement;
exports.isStaticBlock = isStaticBlock;
exports.isStringLiteral = isStringLiteral;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSuper = isSuper;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSArrayType = isTSArrayType;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSBaseType = isTSBaseType;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSEntityName = isTSEntityName;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSImportType = isTSImportType;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSInferType = isTSInferType;
exports.isTSInstantiationExpression = isTSInstantiationExpression;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSMappedType = isTSMappedType;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSNamedTupleMember = isTSNamedTupleMember;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSRestType = isTSRestType;
exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSTupleType = isTSTupleType;
exports.isTSType = isTSType;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnionType = isTSUnionType;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isTerminatorless = isTerminatorless;
exports.isThisExpression = isThisExpression;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isThrowStatement = isThrowStatement;
exports.isTopicReference = isTopicReference;
exports.isTryStatement = isTryStatement;
exports.isTupleExpression = isTupleExpression;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isTypeScript = isTypeScript;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isUnaryExpression = isUnaryExpression;
exports.isUnaryLike = isUnaryLike;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isUpdateExpression = isUpdateExpression;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isWhile = isWhile;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isYieldExpression = isYieldExpression;
var _shallowEqual = require("422c9d38ada4dc1d");
var _deprecationWarning = require("1a14d9f6e7977c1d");
function isArrayExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrayExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAssignmentExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "AssignmentExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBinaryExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "BinaryExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInterpreterDirective(node, opts) {
    if (!node) return false;
    if (node.type !== "InterpreterDirective") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDirective(node, opts) {
    if (!node) return false;
    if (node.type !== "Directive") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "DirectiveLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBlockStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "BlockStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBreakStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "BreakStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isCallExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "CallExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isCatchClause(node, opts) {
    if (!node) return false;
    if (node.type !== "CatchClause") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isConditionalExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ConditionalExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isContinueStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ContinueStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDebuggerStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "DebuggerStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDoWhileStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "DoWhileStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEmptyStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "EmptyStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExpressionStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ExpressionStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFile(node, opts) {
    if (!node) return false;
    if (node.type !== "File") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isForInStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ForInStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isForStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ForStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isIdentifier(node, opts) {
    if (!node) return false;
    if (node.type !== "Identifier") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isIfStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "IfStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isLabeledStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "LabeledStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStringLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "StringLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNumericLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "NumericLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNullLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "NullLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBooleanLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "BooleanLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isRegExpLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "RegExpLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isLogicalExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "LogicalExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isMemberExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "MemberExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNewExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "NewExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isProgram(node, opts) {
    if (!node) return false;
    if (node.type !== "Program") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isRestElement(node, opts) {
    if (!node) return false;
    if (node.type !== "RestElement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isReturnStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ReturnStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSequenceExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "SequenceExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ParenthesizedExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSwitchCase(node, opts) {
    if (!node) return false;
    if (node.type !== "SwitchCase") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSwitchStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "SwitchStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isThisExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ThisExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isThrowStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ThrowStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTryStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "TryStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isUnaryExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "UnaryExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isUpdateExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "UpdateExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isVariableDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "VariableDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isVariableDeclarator(node, opts) {
    if (!node) return false;
    if (node.type !== "VariableDeclarator") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isWhileStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "WhileStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isWithStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "WithStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAssignmentPattern(node, opts) {
    if (!node) return false;
    if (node.type !== "AssignmentPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isArrayPattern(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrayPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrowFunctionExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassBody(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassBody") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportAllDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportDefaultDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportNamedDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isForOfStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ForOfStatement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportDefaultSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportNamespaceSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isMetaProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "MetaProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectPattern(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectPattern") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSpreadElement(node, opts) {
    if (!node) return false;
    if (node.type !== "SpreadElement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSuper(node, opts) {
    if (!node) return false;
    if (node.type !== "Super") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TaggedTemplateExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTemplateElement(node, opts) {
    if (!node) return false;
    if (node.type !== "TemplateElement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTemplateLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "TemplateLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isYieldExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "YieldExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAwaitExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "AwaitExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImport(node, opts) {
    if (!node) return false;
    if (node.type !== "Import") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBigIntLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "BigIntLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportNamespaceSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "OptionalMemberExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "OptionalCallExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassAccessorProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassAccessorProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassPrivateProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassPrivateMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPrivateName(node, opts) {
    if (!node) return false;
    if (node.type !== "PrivateName") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStaticBlock(node, opts) {
    if (!node) return false;
    if (node.type !== "StaticBlock") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "AnyTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrayTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "BooleanTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "BooleanLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NullLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClassImplements(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassImplements") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareClass(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareClass") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareFunction(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareFunction") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareInterface(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareInterface") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareModule(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareModule") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareModuleExports") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareTypeAlias") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareOpaqueType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareVariable(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareVariable") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareExportDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareExportAllDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclaredPredicate") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ExistsTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionTypeParam") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "GenericTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInferredPredicate(node, opts) {
    if (!node) return false;
    if (node.type !== "InferredPredicate") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInterfaceExtends(node, opts) {
    if (!node) return false;
    if (node.type !== "InterfaceExtends") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "InterfaceDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "InterfaceTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "IntersectionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "MixedTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "EmptyTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NullableTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NumberLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NumberTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeInternalSlot") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeCallProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeIndexer") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeSpreadProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isOpaqueType(node, opts) {
    if (!node) return false;
    if (node.type !== "OpaqueType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    if (node.type !== "QualifiedTypeIdentifier") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "StringLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "StringTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "SymbolTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ThisTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "TupleTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeofTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeAlias(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeAlias") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeCastExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeCastExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeParameter(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeParameter") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeParameterDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeParameterInstantiation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "UnionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isVariance(node, opts) {
    if (!node) return false;
    if (node.type !== "Variance") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "VoidTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumBooleanBody") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumNumberBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumNumberBody") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumStringBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumStringBody") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumSymbolBody") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumBooleanMember") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumNumberMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumNumberMember") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumStringMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumStringMember") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumDefaultedMember") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isIndexedAccessType(node, opts) {
    if (!node) return false;
    if (node.type !== "IndexedAccessType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isOptionalIndexedAccessType(node, opts) {
    if (!node) return false;
    if (node.type !== "OptionalIndexedAccessType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXAttribute(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXAttribute") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXClosingElement(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXClosingElement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXElement(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXElement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXEmptyExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXExpressionContainer") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXSpreadChild") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXIdentifier(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXIdentifier") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXMemberExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXNamespacedName") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXOpeningElement") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXSpreadAttribute") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXText(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXText") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXFragment(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXFragment") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXOpeningFragment") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXClosingFragment") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNoop(node, opts) {
    if (!node) return false;
    if (node.type !== "Noop") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPlaceholder(node, opts) {
    if (!node) return false;
    if (node.type !== "Placeholder") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    if (node.type !== "V8IntrinsicIdentifier") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    if (node.type !== "ArgumentPlaceholder") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBindExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "BindExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportAttribute(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportAttribute") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDecorator(node, opts) {
    if (!node) return false;
    if (node.type !== "Decorator") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDoExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "DoExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportDefaultSpecifier") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isRecordExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "RecordExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTupleExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TupleExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDecimalLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "DecimalLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isModuleExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ModuleExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTopicReference(node, opts) {
    if (!node) return false;
    if (node.type !== "TopicReference") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "PipelineTopicExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    if (node.type !== "PipelineBareFunction") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    if (node.type !== "PipelinePrimaryTopicReference") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSParameterProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "TSParameterProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    if (node.type !== "TSDeclareFunction") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "TSDeclareMethod") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSQualifiedName(node, opts) {
    if (!node) return false;
    if (node.type !== "TSQualifiedName") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSCallSignatureDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSConstructSignatureDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSPropertySignature(node, opts) {
    if (!node) return false;
    if (node.type !== "TSPropertySignature") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSMethodSignature(node, opts) {
    if (!node) return false;
    if (node.type !== "TSMethodSignature") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSIndexSignature(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIndexSignature") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSAnyKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSBooleanKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSBigIntKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIntrinsicKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNeverKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNullKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNullKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNumberKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSObjectKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSStringKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSStringKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSSymbolKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSUndefinedKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSUnknownKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSVoidKeyword") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSThisType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSThisType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSFunctionType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSFunctionType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSConstructorType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSConstructorType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeReference(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeReference") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypePredicate(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypePredicate") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeQuery(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeQuery") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSArrayType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSArrayType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTupleType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTupleType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSOptionalType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSOptionalType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSRestType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSRestType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNamedTupleMember") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSUnionType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSUnionType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSIntersectionType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIntersectionType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSConditionalType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSConditionalType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSInferType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInferType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSParenthesizedType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeOperator(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeOperator") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIndexedAccessType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSMappedType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSMappedType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSLiteralType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSLiteralType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    if (node.type !== "TSExpressionWithTypeArguments") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInterfaceDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInterfaceBody") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeAliasDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSInstantiationExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInstantiationExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSAsExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TSAsExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSSatisfiesExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TSSatisfiesExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeAssertion") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSEnumDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSEnumMember(node, opts) {
    if (!node) return false;
    if (node.type !== "TSEnumMember") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSModuleDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSModuleBlock(node, opts) {
    if (!node) return false;
    if (node.type !== "TSModuleBlock") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSImportType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSImportType") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSImportEqualsDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    if (node.type !== "TSExternalModuleReference") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNonNullExpression") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSExportAssignment(node, opts) {
    if (!node) return false;
    if (node.type !== "TSExportAssignment") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNamespaceExportDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeParameterInstantiation") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeParameterDeclaration") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeParameter(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeParameter") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStandardized(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
            break;
        case "Placeholder":
            switch(node.expectedNode){
                case "Identifier":
                case "StringLiteral":
                case "BlockStatement":
                case "ClassBody":
                    break;
                default:
                    return false;
            }
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExpression(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
            break;
        case "Placeholder":
            switch(node.expectedNode){
                case "Expression":
                case "Identifier":
                case "StringLiteral":
                    break;
                default:
                    return false;
            }
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBinary(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "BinaryExpression":
        case "LogicalExpression":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isScopable(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
            break;
        case "Placeholder":
            if (node.expectedNode === "BlockStatement") break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBlockParent(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
            break;
        case "Placeholder":
            if (node.expectedNode === "BlockStatement") break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBlock(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
            break;
        case "Placeholder":
            if (node.expectedNode === "BlockStatement") break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isStatement(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
            break;
        case "Placeholder":
            switch(node.expectedNode){
                case "Statement":
                case "Declaration":
                case "BlockStatement":
                    break;
                default:
                    return false;
            }
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTerminatorless(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isCompletionStatement(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isConditional(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ConditionalExpression":
        case "IfStatement":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isLoop(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isWhile(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "DoWhileStatement":
        case "WhileStatement":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExpressionWrapper(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFor(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isForXStatement(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ForInStatement":
        case "ForOfStatement":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunction(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFunctionParent(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPureish(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
            break;
        case "Placeholder":
            if (node.expectedNode === "StringLiteral") break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDeclaration(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
            break;
        case "Placeholder":
            if (node.expectedNode === "Declaration") break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPatternLike(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
            break;
        case "Placeholder":
            switch(node.expectedNode){
                case "Pattern":
                case "Identifier":
                    break;
                default:
                    return false;
            }
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isLVal(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
            break;
        case "Placeholder":
            switch(node.expectedNode){
                case "Pattern":
                case "Identifier":
                    break;
                default:
                    return false;
            }
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSEntityName(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "Identifier":
        case "TSQualifiedName":
            break;
        case "Placeholder":
            if (node.expectedNode === "Identifier") break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isLiteral(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
            break;
        case "Placeholder":
            if (node.expectedNode === "StringLiteral") break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImmutable(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral":
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXOpeningElement":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
        case "DecimalLiteral":
            break;
        case "Placeholder":
            if (node.expectedNode === "StringLiteral") break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isUserWhitespacable(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isMethod(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isObjectMember(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ObjectMethod":
        case "ObjectProperty":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isProperty(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isUnaryLike(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "UnaryExpression":
        case "SpreadElement":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPattern(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
            break;
        case "Placeholder":
            if (node.expectedNode === "Pattern") break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isClass(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ClassExpression":
        case "ClassDeclaration":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isImportOrExportDeclaration(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isExportDeclaration(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isModuleSpecifier(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAccessor(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ClassAccessorProperty":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isPrivate(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFlow(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFlowType(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFlowDeclaration(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isFlowPredicate(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "DeclaredPredicate":
        case "InferredPredicate":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumBody(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isEnumMember(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isJSX(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isMiscellaneous(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTypeScript(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSTypeElement(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSType(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isTSBaseType(node, opts) {
    if (!node) return false;
    switch(node.type){
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSLiteralType":
            break;
        default:
            return false;
    }
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isNumberLiteral(node, opts) {
    (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
    if (!node) return false;
    if (node.type !== "NumberLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isRegexLiteral(node, opts) {
    (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
    if (!node) return false;
    if (node.type !== "RegexLiteral") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isRestProperty(node, opts) {
    (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
    if (!node) return false;
    if (node.type !== "RestProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isSpreadProperty(node, opts) {
    (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
    if (!node) return false;
    if (node.type !== "SpreadProperty") return false;
    return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isModuleDeclaration(node, opts) {
    (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
    return isImportOrExportDeclaration(node, opts);
}

},{"422c9d38ada4dc1d":"cmTeP","1a14d9f6e7977c1d":"dnmbV"}],"cmTeP":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = shallowEqual;
function shallowEqual(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys){
        if (actual[key] !== expected[key]) return false;
    }
    return true;
}

},{}],"dnmbV":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = deprecationWarning;
const warnings = new Set();
function deprecationWarning(oldName, newName, prefix = "") {
    if (warnings.has(oldName)) return;
    warnings.add(oldName);
    const { internal , trace  } = captureShortStackTrace(1, 2);
    if (internal) return;
    console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`\n${trace}`);
}
function captureShortStackTrace(skip, length) {
    const { stackTraceLimit , prepareStackTrace  } = Error;
    let stackTrace;
    Error.stackTraceLimit = 1 + skip + length;
    Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
    };
    new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    if (!stackTrace) return {
        internal: false,
        trace: ""
    };
    const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
    return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace.map((frame)=>`    at ${frame}`).join("\n")
    };
}

},{}],"fLCOL":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isCompatTag;
function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
}

},{}],"fopPj":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = buildChildren;
var _generated = require("3cdcdfe93a740bab");
var _cleanJSXElementLiteralChild = require("943eab8e3c2aaeb9");
function buildChildren(node) {
    const elements = [];
    for(let i = 0; i < node.children.length; i++){
        let child = node.children[i];
        if ((0, _generated.isJSXText)(child)) {
            (0, _cleanJSXElementLiteralChild.default)(child, elements);
            continue;
        }
        if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
        if ((0, _generated.isJSXEmptyExpression)(child)) continue;
        elements.push(child);
    }
    return elements;
}

},{"3cdcdfe93a740bab":"lrUKn","943eab8e3c2aaeb9":"gSFf3"}],"gSFf3":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cleanJSXElementLiteralChild;
var _generated = require("e6a90223b102fca0");
var _ = require("59fe50648d8cfa42");
function cleanJSXElementLiteralChild(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for(let i = 0; i < lines.length; i++)if (lines[i].match(/[^ \t]/)) lastNonEmptyLine = i;
    let str = "";
    for(let i = 0; i < lines.length; i++){
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        if (!isLastLine) trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        if (trimmedLine) {
            if (!isLastNonEmptyLine) trimmedLine += " ";
            str += trimmedLine;
        }
    }
    if (str) args.push((0, _.inherits)((0, _generated.stringLiteral)(str), child));
}

},{"e6a90223b102fca0":"fvX9A","59fe50648d8cfa42":"hnm3y"}],"fvX9A":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.anyTypeAnnotation = anyTypeAnnotation;
exports.argumentPlaceholder = argumentPlaceholder;
exports.arrayExpression = arrayExpression;
exports.arrayPattern = arrayPattern;
exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.arrowFunctionExpression = arrowFunctionExpression;
exports.assignmentExpression = assignmentExpression;
exports.assignmentPattern = assignmentPattern;
exports.awaitExpression = awaitExpression;
exports.bigIntLiteral = bigIntLiteral;
exports.binaryExpression = binaryExpression;
exports.bindExpression = bindExpression;
exports.blockStatement = blockStatement;
exports.booleanLiteral = booleanLiteral;
exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.breakStatement = breakStatement;
exports.callExpression = callExpression;
exports.catchClause = catchClause;
exports.classAccessorProperty = classAccessorProperty;
exports.classBody = classBody;
exports.classDeclaration = classDeclaration;
exports.classExpression = classExpression;
exports.classImplements = classImplements;
exports.classMethod = classMethod;
exports.classPrivateMethod = classPrivateMethod;
exports.classPrivateProperty = classPrivateProperty;
exports.classProperty = classProperty;
exports.conditionalExpression = conditionalExpression;
exports.continueStatement = continueStatement;
exports.debuggerStatement = debuggerStatement;
exports.decimalLiteral = decimalLiteral;
exports.declareClass = declareClass;
exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.declareExportDeclaration = declareExportDeclaration;
exports.declareFunction = declareFunction;
exports.declareInterface = declareInterface;
exports.declareModule = declareModule;
exports.declareModuleExports = declareModuleExports;
exports.declareOpaqueType = declareOpaqueType;
exports.declareTypeAlias = declareTypeAlias;
exports.declareVariable = declareVariable;
exports.declaredPredicate = declaredPredicate;
exports.decorator = decorator;
exports.directive = directive;
exports.directiveLiteral = directiveLiteral;
exports.doExpression = doExpression;
exports.doWhileStatement = doWhileStatement;
exports.emptyStatement = emptyStatement;
exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.enumBooleanBody = enumBooleanBody;
exports.enumBooleanMember = enumBooleanMember;
exports.enumDeclaration = enumDeclaration;
exports.enumDefaultedMember = enumDefaultedMember;
exports.enumNumberBody = enumNumberBody;
exports.enumNumberMember = enumNumberMember;
exports.enumStringBody = enumStringBody;
exports.enumStringMember = enumStringMember;
exports.enumSymbolBody = enumSymbolBody;
exports.existsTypeAnnotation = existsTypeAnnotation;
exports.exportAllDeclaration = exportAllDeclaration;
exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.exportNamedDeclaration = exportNamedDeclaration;
exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.exportSpecifier = exportSpecifier;
exports.expressionStatement = expressionStatement;
exports.file = file;
exports.forInStatement = forInStatement;
exports.forOfStatement = forOfStatement;
exports.forStatement = forStatement;
exports.functionDeclaration = functionDeclaration;
exports.functionExpression = functionExpression;
exports.functionTypeAnnotation = functionTypeAnnotation;
exports.functionTypeParam = functionTypeParam;
exports.genericTypeAnnotation = genericTypeAnnotation;
exports.identifier = identifier;
exports.ifStatement = ifStatement;
exports.import = _import;
exports.importAttribute = importAttribute;
exports.importDeclaration = importDeclaration;
exports.importDefaultSpecifier = importDefaultSpecifier;
exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.importSpecifier = importSpecifier;
exports.indexedAccessType = indexedAccessType;
exports.inferredPredicate = inferredPredicate;
exports.interfaceDeclaration = interfaceDeclaration;
exports.interfaceExtends = interfaceExtends;
exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.interpreterDirective = interpreterDirective;
exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.jSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXText = exports.jsxText = jsxText;
exports.labeledStatement = labeledStatement;
exports.logicalExpression = logicalExpression;
exports.memberExpression = memberExpression;
exports.metaProperty = metaProperty;
exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.moduleExpression = moduleExpression;
exports.newExpression = newExpression;
exports.noop = noop;
exports.nullLiteral = nullLiteral;
exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.numberLiteral = NumberLiteral;
exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.numberTypeAnnotation = numberTypeAnnotation;
exports.numericLiteral = numericLiteral;
exports.objectExpression = objectExpression;
exports.objectMethod = objectMethod;
exports.objectPattern = objectPattern;
exports.objectProperty = objectProperty;
exports.objectTypeAnnotation = objectTypeAnnotation;
exports.objectTypeCallProperty = objectTypeCallProperty;
exports.objectTypeIndexer = objectTypeIndexer;
exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.objectTypeProperty = objectTypeProperty;
exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.opaqueType = opaqueType;
exports.optionalCallExpression = optionalCallExpression;
exports.optionalIndexedAccessType = optionalIndexedAccessType;
exports.optionalMemberExpression = optionalMemberExpression;
exports.parenthesizedExpression = parenthesizedExpression;
exports.pipelineBareFunction = pipelineBareFunction;
exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.pipelineTopicExpression = pipelineTopicExpression;
exports.placeholder = placeholder;
exports.privateName = privateName;
exports.program = program;
exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.recordExpression = recordExpression;
exports.regExpLiteral = regExpLiteral;
exports.regexLiteral = RegexLiteral;
exports.restElement = restElement;
exports.restProperty = RestProperty;
exports.returnStatement = returnStatement;
exports.sequenceExpression = sequenceExpression;
exports.spreadElement = spreadElement;
exports.spreadProperty = SpreadProperty;
exports.staticBlock = staticBlock;
exports.stringLiteral = stringLiteral;
exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.stringTypeAnnotation = stringTypeAnnotation;
exports.super = _super;
exports.switchCase = switchCase;
exports.switchStatement = switchStatement;
exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.taggedTemplateExpression = taggedTemplateExpression;
exports.templateElement = templateElement;
exports.templateLiteral = templateLiteral;
exports.thisExpression = thisExpression;
exports.thisTypeAnnotation = thisTypeAnnotation;
exports.throwStatement = throwStatement;
exports.topicReference = topicReference;
exports.tryStatement = tryStatement;
exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSArrayType = exports.tsArrayType = tsArrayType;
exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSImportType = exports.tsImportType = tsImportType;
exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSInferType = exports.tsInferType = tsInferType;
exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSMappedType = exports.tsMappedType = tsMappedType;
exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSRestType = exports.tsRestType = tsRestType;
exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSThisType = exports.tsThisType = tsThisType;
exports.tSTupleType = exports.tsTupleType = tsTupleType;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnionType = exports.tsUnionType = tsUnionType;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tupleExpression = tupleExpression;
exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.typeAlias = typeAlias;
exports.typeAnnotation = typeAnnotation;
exports.typeCastExpression = typeCastExpression;
exports.typeParameter = typeParameter;
exports.typeParameterDeclaration = typeParameterDeclaration;
exports.typeParameterInstantiation = typeParameterInstantiation;
exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.unaryExpression = unaryExpression;
exports.unionTypeAnnotation = unionTypeAnnotation;
exports.updateExpression = updateExpression;
exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.variableDeclaration = variableDeclaration;
exports.variableDeclarator = variableDeclarator;
exports.variance = variance;
exports.voidTypeAnnotation = voidTypeAnnotation;
exports.whileStatement = whileStatement;
exports.withStatement = withStatement;
exports.yieldExpression = yieldExpression;
var _validateNode = require("61c4c62970579602");
var _deprecationWarning = require("ed2d88fdfa80c818");
function arrayExpression(elements = []) {
    return (0, _validateNode.default)({
        type: "ArrayExpression",
        elements
    });
}
function assignmentExpression(operator, left, right) {
    return (0, _validateNode.default)({
        type: "AssignmentExpression",
        operator,
        left,
        right
    });
}
function binaryExpression(operator, left, right) {
    return (0, _validateNode.default)({
        type: "BinaryExpression",
        operator,
        left,
        right
    });
}
function interpreterDirective(value) {
    return (0, _validateNode.default)({
        type: "InterpreterDirective",
        value
    });
}
function directive(value) {
    return (0, _validateNode.default)({
        type: "Directive",
        value
    });
}
function directiveLiteral(value) {
    return (0, _validateNode.default)({
        type: "DirectiveLiteral",
        value
    });
}
function blockStatement(body, directives = []) {
    return (0, _validateNode.default)({
        type: "BlockStatement",
        body,
        directives
    });
}
function breakStatement(label = null) {
    return (0, _validateNode.default)({
        type: "BreakStatement",
        label
    });
}
function callExpression(callee, _arguments) {
    return (0, _validateNode.default)({
        type: "CallExpression",
        callee,
        arguments: _arguments
    });
}
function catchClause(param = null, body) {
    return (0, _validateNode.default)({
        type: "CatchClause",
        param,
        body
    });
}
function conditionalExpression(test, consequent, alternate) {
    return (0, _validateNode.default)({
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
    });
}
function continueStatement(label = null) {
    return (0, _validateNode.default)({
        type: "ContinueStatement",
        label
    });
}
function debuggerStatement() {
    return {
        type: "DebuggerStatement"
    };
}
function doWhileStatement(test, body) {
    return (0, _validateNode.default)({
        type: "DoWhileStatement",
        test,
        body
    });
}
function emptyStatement() {
    return {
        type: "EmptyStatement"
    };
}
function expressionStatement(expression) {
    return (0, _validateNode.default)({
        type: "ExpressionStatement",
        expression
    });
}
function file(program, comments = null, tokens = null) {
    return (0, _validateNode.default)({
        type: "File",
        program,
        comments,
        tokens
    });
}
function forInStatement(left, right, body) {
    return (0, _validateNode.default)({
        type: "ForInStatement",
        left,
        right,
        body
    });
}
function forStatement(init = null, test = null, update = null, body) {
    return (0, _validateNode.default)({
        type: "ForStatement",
        init,
        test,
        update,
        body
    });
}
function functionDeclaration(id = null, params, body, generator = false, async = false) {
    return (0, _validateNode.default)({
        type: "FunctionDeclaration",
        id,
        params,
        body,
        generator,
        async
    });
}
function functionExpression(id = null, params, body, generator = false, async = false) {
    return (0, _validateNode.default)({
        type: "FunctionExpression",
        id,
        params,
        body,
        generator,
        async
    });
}
function identifier(name) {
    return (0, _validateNode.default)({
        type: "Identifier",
        name
    });
}
function ifStatement(test, consequent, alternate = null) {
    return (0, _validateNode.default)({
        type: "IfStatement",
        test,
        consequent,
        alternate
    });
}
function labeledStatement(label, body) {
    return (0, _validateNode.default)({
        type: "LabeledStatement",
        label,
        body
    });
}
function stringLiteral(value) {
    return (0, _validateNode.default)({
        type: "StringLiteral",
        value
    });
}
function numericLiteral(value) {
    return (0, _validateNode.default)({
        type: "NumericLiteral",
        value
    });
}
function nullLiteral() {
    return {
        type: "NullLiteral"
    };
}
function booleanLiteral(value) {
    return (0, _validateNode.default)({
        type: "BooleanLiteral",
        value
    });
}
function regExpLiteral(pattern, flags = "") {
    return (0, _validateNode.default)({
        type: "RegExpLiteral",
        pattern,
        flags
    });
}
function logicalExpression(operator, left, right) {
    return (0, _validateNode.default)({
        type: "LogicalExpression",
        operator,
        left,
        right
    });
}
function memberExpression(object, property, computed = false, optional = null) {
    return (0, _validateNode.default)({
        type: "MemberExpression",
        object,
        property,
        computed,
        optional
    });
}
function newExpression(callee, _arguments) {
    return (0, _validateNode.default)({
        type: "NewExpression",
        callee,
        arguments: _arguments
    });
}
function program(body, directives = [], sourceType = "script", interpreter = null) {
    return (0, _validateNode.default)({
        type: "Program",
        body,
        directives,
        sourceType,
        interpreter,
        sourceFile: null
    });
}
function objectExpression(properties) {
    return (0, _validateNode.default)({
        type: "ObjectExpression",
        properties
    });
}
function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
    return (0, _validateNode.default)({
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async
    });
}
function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
    return (0, _validateNode.default)({
        type: "ObjectProperty",
        key,
        value,
        computed,
        shorthand,
        decorators
    });
}
function restElement(argument) {
    return (0, _validateNode.default)({
        type: "RestElement",
        argument
    });
}
function returnStatement(argument = null) {
    return (0, _validateNode.default)({
        type: "ReturnStatement",
        argument
    });
}
function sequenceExpression(expressions) {
    return (0, _validateNode.default)({
        type: "SequenceExpression",
        expressions
    });
}
function parenthesizedExpression(expression) {
    return (0, _validateNode.default)({
        type: "ParenthesizedExpression",
        expression
    });
}
function switchCase(test = null, consequent) {
    return (0, _validateNode.default)({
        type: "SwitchCase",
        test,
        consequent
    });
}
function switchStatement(discriminant, cases) {
    return (0, _validateNode.default)({
        type: "SwitchStatement",
        discriminant,
        cases
    });
}
function thisExpression() {
    return {
        type: "ThisExpression"
    };
}
function throwStatement(argument) {
    return (0, _validateNode.default)({
        type: "ThrowStatement",
        argument
    });
}
function tryStatement(block, handler = null, finalizer = null) {
    return (0, _validateNode.default)({
        type: "TryStatement",
        block,
        handler,
        finalizer
    });
}
function unaryExpression(operator, argument, prefix = true) {
    return (0, _validateNode.default)({
        type: "UnaryExpression",
        operator,
        argument,
        prefix
    });
}
function updateExpression(operator, argument, prefix = false) {
    return (0, _validateNode.default)({
        type: "UpdateExpression",
        operator,
        argument,
        prefix
    });
}
function variableDeclaration(kind, declarations) {
    return (0, _validateNode.default)({
        type: "VariableDeclaration",
        kind,
        declarations
    });
}
function variableDeclarator(id, init = null) {
    return (0, _validateNode.default)({
        type: "VariableDeclarator",
        id,
        init
    });
}
function whileStatement(test, body) {
    return (0, _validateNode.default)({
        type: "WhileStatement",
        test,
        body
    });
}
function withStatement(object, body) {
    return (0, _validateNode.default)({
        type: "WithStatement",
        object,
        body
    });
}
function assignmentPattern(left, right) {
    return (0, _validateNode.default)({
        type: "AssignmentPattern",
        left,
        right
    });
}
function arrayPattern(elements) {
    return (0, _validateNode.default)({
        type: "ArrayPattern",
        elements
    });
}
function arrowFunctionExpression(params, body, async = false) {
    return (0, _validateNode.default)({
        type: "ArrowFunctionExpression",
        params,
        body,
        async,
        expression: null
    });
}
function classBody(body) {
    return (0, _validateNode.default)({
        type: "ClassBody",
        body
    });
}
function classExpression(id = null, superClass = null, body, decorators = null) {
    return (0, _validateNode.default)({
        type: "ClassExpression",
        id,
        superClass,
        body,
        decorators
    });
}
function classDeclaration(id, superClass = null, body, decorators = null) {
    return (0, _validateNode.default)({
        type: "ClassDeclaration",
        id,
        superClass,
        body,
        decorators
    });
}
function exportAllDeclaration(source) {
    return (0, _validateNode.default)({
        type: "ExportAllDeclaration",
        source
    });
}
function exportDefaultDeclaration(declaration) {
    return (0, _validateNode.default)({
        type: "ExportDefaultDeclaration",
        declaration
    });
}
function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
    return (0, _validateNode.default)({
        type: "ExportNamedDeclaration",
        declaration,
        specifiers,
        source
    });
}
function exportSpecifier(local, exported) {
    return (0, _validateNode.default)({
        type: "ExportSpecifier",
        local,
        exported
    });
}
function forOfStatement(left, right, body, _await = false) {
    return (0, _validateNode.default)({
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
    });
}
function importDeclaration(specifiers, source) {
    return (0, _validateNode.default)({
        type: "ImportDeclaration",
        specifiers,
        source
    });
}
function importDefaultSpecifier(local) {
    return (0, _validateNode.default)({
        type: "ImportDefaultSpecifier",
        local
    });
}
function importNamespaceSpecifier(local) {
    return (0, _validateNode.default)({
        type: "ImportNamespaceSpecifier",
        local
    });
}
function importSpecifier(local, imported) {
    return (0, _validateNode.default)({
        type: "ImportSpecifier",
        local,
        imported
    });
}
function metaProperty(meta, property) {
    return (0, _validateNode.default)({
        type: "MetaProperty",
        meta,
        property
    });
}
function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
    return (0, _validateNode.default)({
        type: "ClassMethod",
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async
    });
}
function objectPattern(properties) {
    return (0, _validateNode.default)({
        type: "ObjectPattern",
        properties
    });
}
function spreadElement(argument) {
    return (0, _validateNode.default)({
        type: "SpreadElement",
        argument
    });
}
function _super() {
    return {
        type: "Super"
    };
}
function taggedTemplateExpression(tag, quasi) {
    return (0, _validateNode.default)({
        type: "TaggedTemplateExpression",
        tag,
        quasi
    });
}
function templateElement(value, tail = false) {
    return (0, _validateNode.default)({
        type: "TemplateElement",
        value,
        tail
    });
}
function templateLiteral(quasis, expressions) {
    return (0, _validateNode.default)({
        type: "TemplateLiteral",
        quasis,
        expressions
    });
}
function yieldExpression(argument = null, delegate = false) {
    return (0, _validateNode.default)({
        type: "YieldExpression",
        argument,
        delegate
    });
}
function awaitExpression(argument) {
    return (0, _validateNode.default)({
        type: "AwaitExpression",
        argument
    });
}
function _import() {
    return {
        type: "Import"
    };
}
function bigIntLiteral(value) {
    return (0, _validateNode.default)({
        type: "BigIntLiteral",
        value
    });
}
function exportNamespaceSpecifier(exported) {
    return (0, _validateNode.default)({
        type: "ExportNamespaceSpecifier",
        exported
    });
}
function optionalMemberExpression(object, property, computed = false, optional) {
    return (0, _validateNode.default)({
        type: "OptionalMemberExpression",
        object,
        property,
        computed,
        optional
    });
}
function optionalCallExpression(callee, _arguments, optional) {
    return (0, _validateNode.default)({
        type: "OptionalCallExpression",
        callee,
        arguments: _arguments,
        optional
    });
}
function classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
    return (0, _validateNode.default)({
        type: "ClassProperty",
        key,
        value,
        typeAnnotation,
        decorators,
        computed,
        static: _static
    });
}
function classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
    return (0, _validateNode.default)({
        type: "ClassAccessorProperty",
        key,
        value,
        typeAnnotation,
        decorators,
        computed,
        static: _static
    });
}
function classPrivateProperty(key, value = null, decorators = null, _static = false) {
    return (0, _validateNode.default)({
        type: "ClassPrivateProperty",
        key,
        value,
        decorators,
        static: _static
    });
}
function classPrivateMethod(kind = "method", key, params, body, _static = false) {
    return (0, _validateNode.default)({
        type: "ClassPrivateMethod",
        kind,
        key,
        params,
        body,
        static: _static
    });
}
function privateName(id) {
    return (0, _validateNode.default)({
        type: "PrivateName",
        id
    });
}
function staticBlock(body) {
    return (0, _validateNode.default)({
        type: "StaticBlock",
        body
    });
}
function anyTypeAnnotation() {
    return {
        type: "AnyTypeAnnotation"
    };
}
function arrayTypeAnnotation(elementType) {
    return (0, _validateNode.default)({
        type: "ArrayTypeAnnotation",
        elementType
    });
}
function booleanTypeAnnotation() {
    return {
        type: "BooleanTypeAnnotation"
    };
}
function booleanLiteralTypeAnnotation(value) {
    return (0, _validateNode.default)({
        type: "BooleanLiteralTypeAnnotation",
        value
    });
}
function nullLiteralTypeAnnotation() {
    return {
        type: "NullLiteralTypeAnnotation"
    };
}
function classImplements(id, typeParameters = null) {
    return (0, _validateNode.default)({
        type: "ClassImplements",
        id,
        typeParameters
    });
}
function declareClass(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
        type: "DeclareClass",
        id,
        typeParameters,
        extends: _extends,
        body
    });
}
function declareFunction(id) {
    return (0, _validateNode.default)({
        type: "DeclareFunction",
        id
    });
}
function declareInterface(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
        type: "DeclareInterface",
        id,
        typeParameters,
        extends: _extends,
        body
    });
}
function declareModule(id, body, kind = null) {
    return (0, _validateNode.default)({
        type: "DeclareModule",
        id,
        body,
        kind
    });
}
function declareModuleExports(typeAnnotation) {
    return (0, _validateNode.default)({
        type: "DeclareModuleExports",
        typeAnnotation
    });
}
function declareTypeAlias(id, typeParameters = null, right) {
    return (0, _validateNode.default)({
        type: "DeclareTypeAlias",
        id,
        typeParameters,
        right
    });
}
function declareOpaqueType(id, typeParameters = null, supertype = null) {
    return (0, _validateNode.default)({
        type: "DeclareOpaqueType",
        id,
        typeParameters,
        supertype
    });
}
function declareVariable(id) {
    return (0, _validateNode.default)({
        type: "DeclareVariable",
        id
    });
}
function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
    return (0, _validateNode.default)({
        type: "DeclareExportDeclaration",
        declaration,
        specifiers,
        source
    });
}
function declareExportAllDeclaration(source) {
    return (0, _validateNode.default)({
        type: "DeclareExportAllDeclaration",
        source
    });
}
function declaredPredicate(value) {
    return (0, _validateNode.default)({
        type: "DeclaredPredicate",
        value
    });
}
function existsTypeAnnotation() {
    return {
        type: "ExistsTypeAnnotation"
    };
}
function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
    return (0, _validateNode.default)({
        type: "FunctionTypeAnnotation",
        typeParameters,
        params,
        rest,
        returnType
    });
}
function functionTypeParam(name = null, typeAnnotation) {
    return (0, _validateNode.default)({
        type: "FunctionTypeParam",
        name,
        typeAnnotation
    });
}
function genericTypeAnnotation(id, typeParameters = null) {
    return (0, _validateNode.default)({
        type: "GenericTypeAnnotation",
        id,
        typeParameters
    });
}
function inferredPredicate() {
    return {
        type: "InferredPredicate"
    };
}
function interfaceExtends(id, typeParameters = null) {
    return (0, _validateNode.default)({
        type: "InterfaceExtends",
        id,
        typeParameters
    });
}
function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
        type: "InterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
    });
}
function interfaceTypeAnnotation(_extends = null, body) {
    return (0, _validateNode.default)({
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body
    });
}
function intersectionTypeAnnotation(types) {
    return (0, _validateNode.default)({
        type: "IntersectionTypeAnnotation",
        types
    });
}
function mixedTypeAnnotation() {
    return {
        type: "MixedTypeAnnotation"
    };
}
function emptyTypeAnnotation() {
    return {
        type: "EmptyTypeAnnotation"
    };
}
function nullableTypeAnnotation(typeAnnotation) {
    return (0, _validateNode.default)({
        type: "NullableTypeAnnotation",
        typeAnnotation
    });
}
function numberLiteralTypeAnnotation(value) {
    return (0, _validateNode.default)({
        type: "NumberLiteralTypeAnnotation",
        value
    });
}
function numberTypeAnnotation() {
    return {
        type: "NumberTypeAnnotation"
    };
}
function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
    return (0, _validateNode.default)({
        type: "ObjectTypeAnnotation",
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact
    });
}
function objectTypeInternalSlot(id, value, optional, _static, method) {
    return (0, _validateNode.default)({
        type: "ObjectTypeInternalSlot",
        id,
        value,
        optional,
        static: _static,
        method
    });
}
function objectTypeCallProperty(value) {
    return (0, _validateNode.default)({
        type: "ObjectTypeCallProperty",
        value,
        static: null
    });
}
function objectTypeIndexer(id = null, key, value, variance = null) {
    return (0, _validateNode.default)({
        type: "ObjectTypeIndexer",
        id,
        key,
        value,
        variance,
        static: null
    });
}
function objectTypeProperty(key, value, variance = null) {
    return (0, _validateNode.default)({
        type: "ObjectTypeProperty",
        key,
        value,
        variance,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
    });
}
function objectTypeSpreadProperty(argument) {
    return (0, _validateNode.default)({
        type: "ObjectTypeSpreadProperty",
        argument
    });
}
function opaqueType(id, typeParameters = null, supertype = null, impltype) {
    return (0, _validateNode.default)({
        type: "OpaqueType",
        id,
        typeParameters,
        supertype,
        impltype
    });
}
function qualifiedTypeIdentifier(id, qualification) {
    return (0, _validateNode.default)({
        type: "QualifiedTypeIdentifier",
        id,
        qualification
    });
}
function stringLiteralTypeAnnotation(value) {
    return (0, _validateNode.default)({
        type: "StringLiteralTypeAnnotation",
        value
    });
}
function stringTypeAnnotation() {
    return {
        type: "StringTypeAnnotation"
    };
}
function symbolTypeAnnotation() {
    return {
        type: "SymbolTypeAnnotation"
    };
}
function thisTypeAnnotation() {
    return {
        type: "ThisTypeAnnotation"
    };
}
function tupleTypeAnnotation(types) {
    return (0, _validateNode.default)({
        type: "TupleTypeAnnotation",
        types
    });
}
function typeofTypeAnnotation(argument) {
    return (0, _validateNode.default)({
        type: "TypeofTypeAnnotation",
        argument
    });
}
function typeAlias(id, typeParameters = null, right) {
    return (0, _validateNode.default)({
        type: "TypeAlias",
        id,
        typeParameters,
        right
    });
}
function typeAnnotation(typeAnnotation) {
    return (0, _validateNode.default)({
        type: "TypeAnnotation",
        typeAnnotation
    });
}
function typeCastExpression(expression, typeAnnotation) {
    return (0, _validateNode.default)({
        type: "TypeCastExpression",
        expression,
        typeAnnotation
    });
}
function typeParameter(bound = null, _default = null, variance = null) {
    return (0, _validateNode.default)({
        type: "TypeParameter",
        bound,
        default: _default,
        variance,
        name: null
    });
}
function typeParameterDeclaration(params) {
    return (0, _validateNode.default)({
        type: "TypeParameterDeclaration",
        params
    });
}
function typeParameterInstantiation(params) {
    return (0, _validateNode.default)({
        type: "TypeParameterInstantiation",
        params
    });
}
function unionTypeAnnotation(types) {
    return (0, _validateNode.default)({
        type: "UnionTypeAnnotation",
        types
    });
}
function variance(kind) {
    return (0, _validateNode.default)({
        type: "Variance",
        kind
    });
}
function voidTypeAnnotation() {
    return {
        type: "VoidTypeAnnotation"
    };
}
function enumDeclaration(id, body) {
    return (0, _validateNode.default)({
        type: "EnumDeclaration",
        id,
        body
    });
}
function enumBooleanBody(members) {
    return (0, _validateNode.default)({
        type: "EnumBooleanBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
    });
}
function enumNumberBody(members) {
    return (0, _validateNode.default)({
        type: "EnumNumberBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
    });
}
function enumStringBody(members) {
    return (0, _validateNode.default)({
        type: "EnumStringBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
    });
}
function enumSymbolBody(members) {
    return (0, _validateNode.default)({
        type: "EnumSymbolBody",
        members,
        hasUnknownMembers: null
    });
}
function enumBooleanMember(id) {
    return (0, _validateNode.default)({
        type: "EnumBooleanMember",
        id,
        init: null
    });
}
function enumNumberMember(id, init) {
    return (0, _validateNode.default)({
        type: "EnumNumberMember",
        id,
        init
    });
}
function enumStringMember(id, init) {
    return (0, _validateNode.default)({
        type: "EnumStringMember",
        id,
        init
    });
}
function enumDefaultedMember(id) {
    return (0, _validateNode.default)({
        type: "EnumDefaultedMember",
        id
    });
}
function indexedAccessType(objectType, indexType) {
    return (0, _validateNode.default)({
        type: "IndexedAccessType",
        objectType,
        indexType
    });
}
function optionalIndexedAccessType(objectType, indexType) {
    return (0, _validateNode.default)({
        type: "OptionalIndexedAccessType",
        objectType,
        indexType,
        optional: null
    });
}
function jsxAttribute(name, value = null) {
    return (0, _validateNode.default)({
        type: "JSXAttribute",
        name,
        value
    });
}
function jsxClosingElement(name) {
    return (0, _validateNode.default)({
        type: "JSXClosingElement",
        name
    });
}
function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
    return (0, _validateNode.default)({
        type: "JSXElement",
        openingElement,
        closingElement,
        children,
        selfClosing
    });
}
function jsxEmptyExpression() {
    return {
        type: "JSXEmptyExpression"
    };
}
function jsxExpressionContainer(expression) {
    return (0, _validateNode.default)({
        type: "JSXExpressionContainer",
        expression
    });
}
function jsxSpreadChild(expression) {
    return (0, _validateNode.default)({
        type: "JSXSpreadChild",
        expression
    });
}
function jsxIdentifier(name) {
    return (0, _validateNode.default)({
        type: "JSXIdentifier",
        name
    });
}
function jsxMemberExpression(object, property) {
    return (0, _validateNode.default)({
        type: "JSXMemberExpression",
        object,
        property
    });
}
function jsxNamespacedName(namespace, name) {
    return (0, _validateNode.default)({
        type: "JSXNamespacedName",
        namespace,
        name
    });
}
function jsxOpeningElement(name, attributes, selfClosing = false) {
    return (0, _validateNode.default)({
        type: "JSXOpeningElement",
        name,
        attributes,
        selfClosing
    });
}
function jsxSpreadAttribute(argument) {
    return (0, _validateNode.default)({
        type: "JSXSpreadAttribute",
        argument
    });
}
function jsxText(value) {
    return (0, _validateNode.default)({
        type: "JSXText",
        value
    });
}
function jsxFragment(openingFragment, closingFragment, children) {
    return (0, _validateNode.default)({
        type: "JSXFragment",
        openingFragment,
        closingFragment,
        children
    });
}
function jsxOpeningFragment() {
    return {
        type: "JSXOpeningFragment"
    };
}
function jsxClosingFragment() {
    return {
        type: "JSXClosingFragment"
    };
}
function noop() {
    return {
        type: "Noop"
    };
}
function placeholder(expectedNode, name) {
    return (0, _validateNode.default)({
        type: "Placeholder",
        expectedNode,
        name
    });
}
function v8IntrinsicIdentifier(name) {
    return (0, _validateNode.default)({
        type: "V8IntrinsicIdentifier",
        name
    });
}
function argumentPlaceholder() {
    return {
        type: "ArgumentPlaceholder"
    };
}
function bindExpression(object, callee) {
    return (0, _validateNode.default)({
        type: "BindExpression",
        object,
        callee
    });
}
function importAttribute(key, value) {
    return (0, _validateNode.default)({
        type: "ImportAttribute",
        key,
        value
    });
}
function decorator(expression) {
    return (0, _validateNode.default)({
        type: "Decorator",
        expression
    });
}
function doExpression(body, async = false) {
    return (0, _validateNode.default)({
        type: "DoExpression",
        body,
        async
    });
}
function exportDefaultSpecifier(exported) {
    return (0, _validateNode.default)({
        type: "ExportDefaultSpecifier",
        exported
    });
}
function recordExpression(properties) {
    return (0, _validateNode.default)({
        type: "RecordExpression",
        properties
    });
}
function tupleExpression(elements = []) {
    return (0, _validateNode.default)({
        type: "TupleExpression",
        elements
    });
}
function decimalLiteral(value) {
    return (0, _validateNode.default)({
        type: "DecimalLiteral",
        value
    });
}
function moduleExpression(body) {
    return (0, _validateNode.default)({
        type: "ModuleExpression",
        body
    });
}
function topicReference() {
    return {
        type: "TopicReference"
    };
}
function pipelineTopicExpression(expression) {
    return (0, _validateNode.default)({
        type: "PipelineTopicExpression",
        expression
    });
}
function pipelineBareFunction(callee) {
    return (0, _validateNode.default)({
        type: "PipelineBareFunction",
        callee
    });
}
function pipelinePrimaryTopicReference() {
    return {
        type: "PipelinePrimaryTopicReference"
    };
}
function tsParameterProperty(parameter) {
    return (0, _validateNode.default)({
        type: "TSParameterProperty",
        parameter
    });
}
function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
    return (0, _validateNode.default)({
        type: "TSDeclareFunction",
        id,
        typeParameters,
        params,
        returnType
    });
}
function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
    return (0, _validateNode.default)({
        type: "TSDeclareMethod",
        decorators,
        key,
        typeParameters,
        params,
        returnType
    });
}
function tsQualifiedName(left, right) {
    return (0, _validateNode.default)({
        type: "TSQualifiedName",
        left,
        right
    });
}
function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
    return (0, _validateNode.default)({
        type: "TSCallSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation
    });
}
function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
    return (0, _validateNode.default)({
        type: "TSConstructSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation
    });
}
function tsPropertySignature(key, typeAnnotation = null, initializer = null) {
    return (0, _validateNode.default)({
        type: "TSPropertySignature",
        key,
        typeAnnotation,
        initializer,
        kind: null
    });
}
function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {
    return (0, _validateNode.default)({
        type: "TSMethodSignature",
        key,
        typeParameters,
        parameters,
        typeAnnotation,
        kind: null
    });
}
function tsIndexSignature(parameters, typeAnnotation = null) {
    return (0, _validateNode.default)({
        type: "TSIndexSignature",
        parameters,
        typeAnnotation
    });
}
function tsAnyKeyword() {
    return {
        type: "TSAnyKeyword"
    };
}
function tsBooleanKeyword() {
    return {
        type: "TSBooleanKeyword"
    };
}
function tsBigIntKeyword() {
    return {
        type: "TSBigIntKeyword"
    };
}
function tsIntrinsicKeyword() {
    return {
        type: "TSIntrinsicKeyword"
    };
}
function tsNeverKeyword() {
    return {
        type: "TSNeverKeyword"
    };
}
function tsNullKeyword() {
    return {
        type: "TSNullKeyword"
    };
}
function tsNumberKeyword() {
    return {
        type: "TSNumberKeyword"
    };
}
function tsObjectKeyword() {
    return {
        type: "TSObjectKeyword"
    };
}
function tsStringKeyword() {
    return {
        type: "TSStringKeyword"
    };
}
function tsSymbolKeyword() {
    return {
        type: "TSSymbolKeyword"
    };
}
function tsUndefinedKeyword() {
    return {
        type: "TSUndefinedKeyword"
    };
}
function tsUnknownKeyword() {
    return {
        type: "TSUnknownKeyword"
    };
}
function tsVoidKeyword() {
    return {
        type: "TSVoidKeyword"
    };
}
function tsThisType() {
    return {
        type: "TSThisType"
    };
}
function tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {
    return (0, _validateNode.default)({
        type: "TSFunctionType",
        typeParameters,
        parameters,
        typeAnnotation
    });
}
function tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {
    return (0, _validateNode.default)({
        type: "TSConstructorType",
        typeParameters,
        parameters,
        typeAnnotation
    });
}
function tsTypeReference(typeName, typeParameters = null) {
    return (0, _validateNode.default)({
        type: "TSTypeReference",
        typeName,
        typeParameters
    });
}
function tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {
    return (0, _validateNode.default)({
        type: "TSTypePredicate",
        parameterName,
        typeAnnotation,
        asserts
    });
}
function tsTypeQuery(exprName, typeParameters = null) {
    return (0, _validateNode.default)({
        type: "TSTypeQuery",
        exprName,
        typeParameters
    });
}
function tsTypeLiteral(members) {
    return (0, _validateNode.default)({
        type: "TSTypeLiteral",
        members
    });
}
function tsArrayType(elementType) {
    return (0, _validateNode.default)({
        type: "TSArrayType",
        elementType
    });
}
function tsTupleType(elementTypes) {
    return (0, _validateNode.default)({
        type: "TSTupleType",
        elementTypes
    });
}
function tsOptionalType(typeAnnotation) {
    return (0, _validateNode.default)({
        type: "TSOptionalType",
        typeAnnotation
    });
}
function tsRestType(typeAnnotation) {
    return (0, _validateNode.default)({
        type: "TSRestType",
        typeAnnotation
    });
}
function tsNamedTupleMember(label, elementType, optional = false) {
    return (0, _validateNode.default)({
        type: "TSNamedTupleMember",
        label,
        elementType,
        optional
    });
}
function tsUnionType(types) {
    return (0, _validateNode.default)({
        type: "TSUnionType",
        types
    });
}
function tsIntersectionType(types) {
    return (0, _validateNode.default)({
        type: "TSIntersectionType",
        types
    });
}
function tsConditionalType(checkType, extendsType, trueType, falseType) {
    return (0, _validateNode.default)({
        type: "TSConditionalType",
        checkType,
        extendsType,
        trueType,
        falseType
    });
}
function tsInferType(typeParameter) {
    return (0, _validateNode.default)({
        type: "TSInferType",
        typeParameter
    });
}
function tsParenthesizedType(typeAnnotation) {
    return (0, _validateNode.default)({
        type: "TSParenthesizedType",
        typeAnnotation
    });
}
function tsTypeOperator(typeAnnotation) {
    return (0, _validateNode.default)({
        type: "TSTypeOperator",
        typeAnnotation,
        operator: null
    });
}
function tsIndexedAccessType(objectType, indexType) {
    return (0, _validateNode.default)({
        type: "TSIndexedAccessType",
        objectType,
        indexType
    });
}
function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
    return (0, _validateNode.default)({
        type: "TSMappedType",
        typeParameter,
        typeAnnotation,
        nameType
    });
}
function tsLiteralType(literal) {
    return (0, _validateNode.default)({
        type: "TSLiteralType",
        literal
    });
}
function tsExpressionWithTypeArguments(expression, typeParameters = null) {
    return (0, _validateNode.default)({
        type: "TSExpressionWithTypeArguments",
        expression,
        typeParameters
    });
}
function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
        type: "TSInterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
    });
}
function tsInterfaceBody(body) {
    return (0, _validateNode.default)({
        type: "TSInterfaceBody",
        body
    });
}
function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
    return (0, _validateNode.default)({
        type: "TSTypeAliasDeclaration",
        id,
        typeParameters,
        typeAnnotation
    });
}
function tsInstantiationExpression(expression, typeParameters = null) {
    return (0, _validateNode.default)({
        type: "TSInstantiationExpression",
        expression,
        typeParameters
    });
}
function tsAsExpression(expression, typeAnnotation) {
    return (0, _validateNode.default)({
        type: "TSAsExpression",
        expression,
        typeAnnotation
    });
}
function tsSatisfiesExpression(expression, typeAnnotation) {
    return (0, _validateNode.default)({
        type: "TSSatisfiesExpression",
        expression,
        typeAnnotation
    });
}
function tsTypeAssertion(typeAnnotation, expression) {
    return (0, _validateNode.default)({
        type: "TSTypeAssertion",
        typeAnnotation,
        expression
    });
}
function tsEnumDeclaration(id, members) {
    return (0, _validateNode.default)({
        type: "TSEnumDeclaration",
        id,
        members
    });
}
function tsEnumMember(id, initializer = null) {
    return (0, _validateNode.default)({
        type: "TSEnumMember",
        id,
        initializer
    });
}
function tsModuleDeclaration(id, body) {
    return (0, _validateNode.default)({
        type: "TSModuleDeclaration",
        id,
        body
    });
}
function tsModuleBlock(body) {
    return (0, _validateNode.default)({
        type: "TSModuleBlock",
        body
    });
}
function tsImportType(argument, qualifier = null, typeParameters = null) {
    return (0, _validateNode.default)({
        type: "TSImportType",
        argument,
        qualifier,
        typeParameters
    });
}
function tsImportEqualsDeclaration(id, moduleReference) {
    return (0, _validateNode.default)({
        type: "TSImportEqualsDeclaration",
        id,
        moduleReference,
        isExport: null
    });
}
function tsExternalModuleReference(expression) {
    return (0, _validateNode.default)({
        type: "TSExternalModuleReference",
        expression
    });
}
function tsNonNullExpression(expression) {
    return (0, _validateNode.default)({
        type: "TSNonNullExpression",
        expression
    });
}
function tsExportAssignment(expression) {
    return (0, _validateNode.default)({
        type: "TSExportAssignment",
        expression
    });
}
function tsNamespaceExportDeclaration(id) {
    return (0, _validateNode.default)({
        type: "TSNamespaceExportDeclaration",
        id
    });
}
function tsTypeAnnotation(typeAnnotation) {
    return (0, _validateNode.default)({
        type: "TSTypeAnnotation",
        typeAnnotation
    });
}
function tsTypeParameterInstantiation(params) {
    return (0, _validateNode.default)({
        type: "TSTypeParameterInstantiation",
        params
    });
}
function tsTypeParameterDeclaration(params) {
    return (0, _validateNode.default)({
        type: "TSTypeParameterDeclaration",
        params
    });
}
function tsTypeParameter(constraint = null, _default = null, name) {
    return (0, _validateNode.default)({
        type: "TSTypeParameter",
        constraint,
        default: _default,
        name
    });
}
function NumberLiteral(value) {
    (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
    return numericLiteral(value);
}
function RegexLiteral(pattern, flags = "") {
    (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
    return regExpLiteral(pattern, flags);
}
function RestProperty(argument) {
    (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
    return restElement(argument);
}
function SpreadProperty(argument) {
    (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
    return spreadElement(argument);
}

},{"61c4c62970579602":"9HfcL","ed2d88fdfa80c818":"dnmbV"}],"9HfcL":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = validateNode;
var _validate = require("c4a0427860df2b4e");
var _ = require("5fc6188b5b9b1bc4");
function validateNode(node) {
    const keys = _.BUILDER_KEYS[node.type];
    for (const key of keys)(0, _validate.default)(node, key, node[key]);
    return node;
}

},{"c4a0427860df2b4e":"5qUw2","5fc6188b5b9b1bc4":"hnm3y"}],"5qUw2":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = validate;
exports.validateChild = validateChild;
exports.validateField = validateField;
var _definitions = require("e68fe5621f942457");
function validate(node, key, val) {
    if (!node) return;
    const fields = _definitions.NODE_FIELDS[node.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
}
function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
}
function validateChild(node, key, val) {
    if (val == null) return;
    const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
    if (!validate) return;
    validate(node, key, val);
}

},{"e68fe5621f942457":"32frq"}],"32frq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ALIAS_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.ALIAS_KEYS;
    }
});
Object.defineProperty(exports, "BUILDER_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.BUILDER_KEYS;
    }
});
Object.defineProperty(exports, "DEPRECATED_ALIASES", {
    enumerable: true,
    get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
    }
});
Object.defineProperty(exports, "DEPRECATED_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.DEPRECATED_KEYS;
    }
});
Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
    }
});
Object.defineProperty(exports, "NODE_FIELDS", {
    enumerable: true,
    get: function() {
        return _utils.NODE_FIELDS;
    }
});
Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
    enumerable: true,
    get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
    }
});
exports.TYPES = void 0;
Object.defineProperty(exports, "VISITOR_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.VISITOR_KEYS;
    }
});
var _toFastProperties = require("fa4c528dcd833681");
require("98ee41378ea590bd");
require("f2fed694ad3224d9");
require("ec26d6e1078151f1");
require("8ebed6c1ccfcfdd3");
require("e7b83e4c878e595f");
require("f7e34500b5a59709");
var _utils = require("cc5e0454b7f895a4");
var _placeholders = require("11ccb025b66a203f");
var _deprecatedAliases = require("cee77e87ad7b0a76");
Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias)=>{
    _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
});
_toFastProperties(_utils.VISITOR_KEYS);
_toFastProperties(_utils.ALIAS_KEYS);
_toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
_toFastProperties(_utils.NODE_FIELDS);
_toFastProperties(_utils.BUILDER_KEYS);
_toFastProperties(_utils.DEPRECATED_KEYS);
_toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
_toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
const TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
exports.TYPES = TYPES;

},{"fa4c528dcd833681":"2vFUG","98ee41378ea590bd":"gbyBi","f2fed694ad3224d9":"4aIsr","ec26d6e1078151f1":"5evAz","8ebed6c1ccfcfdd3":"1jcc6","e7b83e4c878e595f":"fsZ4g","f7e34500b5a59709":"4gqhI","cc5e0454b7f895a4":"5ByWg","11ccb025b66a203f":"azLWK","cee77e87ad7b0a76":"apAJV"}],"2vFUG":[function(require,module,exports) {
"use strict";
let fastProto = null;
// Creates an object with permanently fast properties in V8. See Toon Verwaest's
// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62
// for more details. Use %HasFastProperties(object) and the Node.js flag
// --allow-natives-syntax to check whether an object has fast properties.
function FastObject(o) {
    // A prototype object will have "fast properties" enabled once it is checked
    // against the inline property cache of a function, e.g. fastProto.property:
    // https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63
    if (fastProto !== null && typeof fastProto.property) {
        const result = fastProto;
        fastProto = FastObject.prototype = null;
        return result;
    }
    fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
    return new FastObject;
}
// Initialize the inline property cache of FastObject
FastObject();
module.exports = function toFastproperties(o) {
    return FastObject(o);
};

},{}],"gbyBi":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
var _is = require("1cbbf027a3b11931");
var _isValidIdentifier = require("e969de64df14bf2a");
var _helperValidatorIdentifier = require("8ea5d29fc0e31037");
var _helperStringParser = require("2e30d9922d343729");
var _constants = require("e0ae1d7945a8069e");
var _utils = require("254f60056bb01e3d");
const defineType = (0, _utils.defineAliasedType)("Standardized");
defineType("ArrayExpression", {
    fields: {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
            default: []
        }
    },
    visitor: [
        "elements"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("AssignmentExpression", {
    fields: {
        operator: {
            validate: function() {
                return (0, _utils.assertValueType)("string");
            }()
        },
        left: {
            validate: (0, _utils.assertNodeType)("LVal")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    builder: [
        "operator",
        "left",
        "right"
    ],
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("BinaryExpression", {
    builder: [
        "operator",
        "left",
        "right"
    ],
    fields: {
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
        },
        left: {
            validate: function() {
                const expression = (0, _utils.assertNodeType)("Expression");
                const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
                const validator = Object.assign(function(node, key, val) {
                    const validator = node.operator === "in" ? inOp : expression;
                    validator(node, key, val);
                }, {
                    oneOfNodeTypes: [
                        "Expression",
                        "PrivateName"
                    ]
                });
                return validator;
            }()
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Binary",
        "Expression"
    ]
});
defineType("InterpreterDirective", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("Directive", {
    visitor: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
    }
});
defineType("DirectiveLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("BlockStatement", {
    builder: [
        "body",
        "directives"
    ],
    visitor: [
        "directives",
        "body"
    ],
    fields: {
        directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
        },
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "Block",
        "Statement"
    ]
});
defineType("BreakStatement", {
    visitor: [
        "label"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        }
    },
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ]
});
defineType("CallExpression", {
    visitor: [
        "callee",
        "arguments",
        "typeParameters",
        "typeArguments"
    ],
    builder: [
        "callee",
        "arguments"
    ],
    aliases: [
        "Expression"
    ],
    fields: Object.assign({
        callee: {
            validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
        },
        arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
    }, {
        optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
        }
    }, {
        typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
        }
    })
});
defineType("CatchClause", {
    visitor: [
        "param",
        "body"
    ],
    fields: {
        param: {
            validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    },
    aliases: [
        "Scopable",
        "BlockParent"
    ]
});
defineType("ConditionalExpression", {
    visitor: [
        "test",
        "consequent",
        "alternate"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression",
        "Conditional"
    ]
});
defineType("ContinueStatement", {
    visitor: [
        "label"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        }
    },
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ]
});
defineType("DebuggerStatement", {
    aliases: [
        "Statement"
    ]
});
defineType("DoWhileStatement", {
    visitor: [
        "test",
        "body"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    },
    aliases: [
        "Statement",
        "BlockParent",
        "Loop",
        "While",
        "Scopable"
    ]
});
defineType("EmptyStatement", {
    aliases: [
        "Statement"
    ]
});
defineType("ExpressionStatement", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Statement",
        "ExpressionWrapper"
    ]
});
defineType("File", {
    builder: [
        "program",
        "comments",
        "tokens"
    ],
    visitor: [
        "program"
    ],
    fields: {
        program: {
            validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
            validate: Object.assign(()=>{}, {
                each: {
                    oneOfNodeTypes: [
                        "CommentBlock",
                        "CommentLine"
                    ]
                }
            }),
            optional: true
        },
        tokens: {
            validate: (0, _utils.assertEach)(Object.assign(()=>{}, {
                type: "any"
            })),
            optional: true
        }
    }
});
defineType("ForInStatement", {
    visitor: [
        "left",
        "right",
        "body"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement"
    ],
    fields: {
        left: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("ForStatement", {
    visitor: [
        "init",
        "test",
        "update",
        "body"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop"
    ],
    fields: {
        init: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
            optional: true
        },
        test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        update: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
const functionCommon = ()=>({
        params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
        },
        generator: {
            default: false
        },
        async: {
            default: false
        }
    });
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = ()=>({
        returnType: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
        }
    });
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = ()=>Object.assign({}, functionCommon(), {
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        }
    });
exports.functionDeclarationCommon = functionDeclarationCommon;
defineType("FunctionDeclaration", {
    builder: [
        "id",
        "params",
        "body",
        "generator",
        "async"
    ],
    visitor: [
        "id",
        "params",
        "body",
        "returnType",
        "typeParameters"
    ],
    fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
            validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
            optional: true
        }
    }),
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Statement",
        "Pureish",
        "Declaration"
    ],
    validate: function() {
        return ()=>{};
    }()
});
defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish"
    ],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
            validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
            optional: true
        }
    })
});
const patternLikeCommon = ()=>({
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    });
exports.patternLikeCommon = patternLikeCommon;
defineType("Identifier", {
    builder: [
        "name"
    ],
    visitor: [
        "typeAnnotation",
        "decorators"
    ],
    aliases: [
        "Expression",
        "PatternLike",
        "LVal",
        "TSEntityName"
    ],
    fields: Object.assign({}, patternLikeCommon(), {
        name: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "string"
            }))
        }
    }),
    validate (parent, key, node) {
        return;
    }
});
defineType("IfStatement", {
    visitor: [
        "test",
        "consequent",
        "alternate"
    ],
    aliases: [
        "Statement",
        "Conditional"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
            validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("LabeledStatement", {
    visitor: [
        "label",
        "body"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("StringLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("NumericLiteral", {
    builder: [
        "value"
    ],
    deprecatedAlias: "NumberLiteral",
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("number")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("NullLiteral", {
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("BooleanLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("boolean")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("RegExpLiteral", {
    builder: [
        "pattern",
        "flags"
    ],
    deprecatedAlias: "RegexLiteral",
    aliases: [
        "Expression",
        "Pureish",
        "Literal"
    ],
    fields: {
        pattern: {
            validate: (0, _utils.assertValueType)("string")
        },
        flags: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "string"
            })),
            default: ""
        }
    }
});
defineType("LogicalExpression", {
    builder: [
        "operator",
        "left",
        "right"
    ],
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Binary",
        "Expression"
    ],
    fields: {
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
        },
        left: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("MemberExpression", {
    builder: [
        "object",
        "property",
        "computed",
        "optional"
    ],
    visitor: [
        "object",
        "property"
    ],
    aliases: [
        "Expression",
        "LVal"
    ],
    fields: Object.assign({
        object: {
            validate: (0, _utils.assertNodeType)("Expression", "Super")
        },
        property: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "PrivateName"
                ];
                return validator;
            }()
        },
        computed: {
            default: false
        }
    }, {
        optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
        }
    })
});
defineType("NewExpression", {
    inherits: "CallExpression"
});
defineType("Program", {
    visitor: [
        "directives",
        "body"
    ],
    builder: [
        "body",
        "directives",
        "sourceType",
        "interpreter"
    ],
    fields: {
        sourceFile: {
            validate: (0, _utils.assertValueType)("string")
        },
        sourceType: {
            validate: (0, _utils.assertOneOf)("script", "module"),
            default: "script"
        },
        interpreter: {
            validate: (0, _utils.assertNodeType)("InterpreterDirective"),
            default: null,
            optional: true
        },
        directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
        },
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "Block"
    ]
});
defineType("ObjectExpression", {
    visitor: [
        "properties"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
    }
});
defineType("ObjectMethod", {
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "generator",
        "async"
    ],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
            validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, {
            default: "method"
        }),
        computed: {
            default: false
        },
        key: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral",
                    "BigIntLiteral"
                ];
                return validator;
            }()
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }),
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "UserWhitespacable",
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "ObjectMember"
    ]
});
defineType("ObjectProperty", {
    builder: [
        "key",
        "value",
        "computed",
        "shorthand",
        "decorators"
    ],
    fields: {
        computed: {
            default: false
        },
        key: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator = Object.assign(function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                }, {
                    oneOfNodeTypes: [
                        "Expression",
                        "Identifier",
                        "StringLiteral",
                        "NumericLiteral",
                        "BigIntLiteral",
                        "DecimalLiteral",
                        "PrivateName"
                    ]
                });
                return validator;
            }()
        },
        value: {
            validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "boolean"
            }), function(node, key, val) {
                return;
            }),
            default: false
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    },
    visitor: [
        "key",
        "value",
        "decorators"
    ],
    aliases: [
        "UserWhitespacable",
        "Property",
        "ObjectMember"
    ],
    validate: function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node) {
            return;
        };
    }()
});
defineType("RestElement", {
    visitor: [
        "argument",
        "typeAnnotation"
    ],
    builder: [
        "argument"
    ],
    aliases: [
        "LVal",
        "PatternLike"
    ],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon(), {
        argument: {
            validate: (0, _utils.assertNodeType)("LVal")
        }
    }),
    validate (parent, key) {
        return;
    }
});
defineType("ReturnStatement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        }
    }
});
defineType("SequenceExpression", {
    visitor: [
        "expressions"
    ],
    fields: {
        expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
        }
    },
    aliases: [
        "Expression"
    ]
});
defineType("ParenthesizedExpression", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Expression",
        "ExpressionWrapper"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("SwitchCase", {
    visitor: [
        "test",
        "consequent"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        consequent: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    }
});
defineType("SwitchStatement", {
    visitor: [
        "discriminant",
        "cases"
    ],
    aliases: [
        "Statement",
        "BlockParent",
        "Scopable"
    ],
    fields: {
        discriminant: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
        }
    }
});
defineType("ThisExpression", {
    aliases: [
        "Expression"
    ]
});
defineType("ThrowStatement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("TryStatement", {
    visitor: [
        "block",
        "handler",
        "finalizer"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        block: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
                return;
            }, {
                oneOfNodeTypes: [
                    "BlockStatement"
                ]
            }))
        },
        handler: {
            optional: true,
            validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
            optional: true,
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }
});
defineType("UnaryExpression", {
    builder: [
        "operator",
        "argument",
        "prefix"
    ],
    fields: {
        prefix: {
            default: true
        },
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
        }
    },
    visitor: [
        "argument"
    ],
    aliases: [
        "UnaryLike",
        "Expression"
    ]
});
defineType("UpdateExpression", {
    builder: [
        "operator",
        "argument",
        "prefix"
    ],
    fields: {
        prefix: {
            default: false
        },
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
        }
    },
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("VariableDeclaration", {
    builder: [
        "kind",
        "declarations"
    ],
    visitor: [
        "declarations"
    ],
    aliases: [
        "Statement",
        "Declaration"
    ],
    fields: {
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        kind: {
            validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
        },
        declarations: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
        }
    },
    validate (parent, key, node) {
        return;
    }
});
defineType("VariableDeclarator", {
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: {
            validate: function() {
                return (0, _utils.assertNodeType)("LVal");
            }()
        },
        definite: {
            optional: true,
            validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("WhileStatement", {
    visitor: [
        "test",
        "body"
    ],
    aliases: [
        "Statement",
        "BlockParent",
        "Loop",
        "While",
        "Scopable"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("WithStatement", {
    visitor: [
        "object",
        "body"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("AssignmentPattern", {
    visitor: [
        "left",
        "right",
        "decorators"
    ],
    builder: [
        "left",
        "right"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({}, patternLikeCommon(), {
        left: {
            validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    })
});
defineType("ArrayPattern", {
    visitor: [
        "elements",
        "typeAnnotation"
    ],
    builder: [
        "elements"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({}, patternLikeCommon(), {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
        }
    })
});
defineType("ArrowFunctionExpression", {
    builder: [
        "params",
        "body",
        "async"
    ],
    visitor: [
        "params",
        "body",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish"
    ],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
            validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        },
        predicate: {
            validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
            optional: true
        }
    })
});
defineType("ClassBody", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
        }
    }
});
defineType("ClassExpression", {
    builder: [
        "id",
        "superClass",
        "body",
        "decorators"
    ],
    visitor: [
        "id",
        "body",
        "superClass",
        "mixins",
        "typeParameters",
        "superTypeParameters",
        "implements",
        "decorators"
    ],
    aliases: [
        "Scopable",
        "Class",
        "Expression"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        },
        implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
        }
    }
});
defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: [
        "Scopable",
        "Class",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        },
        implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
        },
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        abstract: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    },
    validate: function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
            return;
        };
    }()
});
defineType("ExportAllDeclaration", {
    builder: [
        "source"
    ],
    visitor: [
        "source",
        "attributes",
        "assertions"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
        attributes: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        }
    }
});
defineType("ExportDefaultDeclaration", {
    visitor: [
        "declaration"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        declaration: {
            validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    }
});
defineType("ExportNamedDeclaration", {
    builder: [
        "declaration",
        "specifiers",
        "source"
    ],
    visitor: [
        "declaration",
        "specifiers",
        "source",
        "attributes",
        "assertions"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        declaration: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
                return;
            }, {
                oneOfNodeTypes: [
                    "Declaration"
                ]
            }), function(node, key, val) {
                return;
            })
        },
        attributes: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
            default: [],
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
                const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
                const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
                return sourced;
            }()))
        },
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral"),
            optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
});
defineType("ExportSpecifier", {
    visitor: [
        "local",
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
        }
    }
});
defineType("ForOfStatement", {
    visitor: [
        "left",
        "right",
        "body"
    ],
    builder: [
        "left",
        "right",
        "body",
        "await"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement"
    ],
    fields: {
        left: {
            validate: function() {
                return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }()
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
            default: false
        }
    }
});
defineType("ImportDeclaration", {
    builder: [
        "specifiers",
        "source"
    ],
    visitor: [
        "specifiers",
        "source",
        "attributes",
        "assertions"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration"
    ],
    fields: {
        attributes: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        module: {
            optional: true,
            validate: (0, _utils.assertValueType)("boolean")
        },
        specifiers: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
        }
    }
});
defineType("ImportDefaultSpecifier", {
    visitor: [
        "local"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("ImportNamespaceSpecifier", {
    visitor: [
        "local"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("ImportSpecifier", {
    visitor: [
        "local",
        "imported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
        }
    }
});
defineType("MetaProperty", {
    visitor: [
        "meta",
        "property"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        meta: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
                return;
            }, {
                oneOfNodeTypes: [
                    "Identifier"
                ]
            }))
        },
        property: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
const classMethodOrPropertyCommon = ()=>({
        abstract: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        accessibility: {
            validate: (0, _utils.assertOneOf)("public", "private", "protected"),
            optional: true
        },
        static: {
            default: false
        },
        override: {
            default: false
        },
        computed: {
            default: false
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        key: {
            validate: (0, _utils.chain)(function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
                const computed = (0, _utils.assertNodeType)("Expression");
                return function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
            }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
        }
    });
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = ()=>Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
        params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
        },
        kind: {
            validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
            default: "method"
        },
        access: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    });
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
defineType("ClassMethod", {
    aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method"
    ],
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "static",
        "generator",
        "async"
    ],
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
defineType("ObjectPattern", {
    visitor: [
        "properties",
        "typeAnnotation",
        "decorators"
    ],
    builder: [
        "properties"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({}, patternLikeCommon(), {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
        }
    })
});
defineType("SpreadElement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "UnaryLike"
    ],
    deprecatedAlias: "SpreadProperty",
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("Super", {
    aliases: [
        "Expression"
    ]
});
defineType("TaggedTemplateExpression", {
    visitor: [
        "tag",
        "quasi",
        "typeParameters"
    ],
    builder: [
        "tag",
        "quasi"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        tag: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
            validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("TemplateElement", {
    builder: [
        "value",
        "tail"
    ],
    fields: {
        value: {
            validate: (0, _utils.chain)((0, _utils.assertShape)({
                raw: {
                    validate: (0, _utils.assertValueType)("string")
                },
                cooked: {
                    validate: (0, _utils.assertValueType)("string"),
                    optional: true
                }
            }), function templateElementCookedValidator(node) {
                const raw = node.value.raw;
                let unterminatedCalled = false;
                const error = ()=>{
                    throw new Error("Internal @babel/types error.");
                };
                const { str , firstInvalidLoc  } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
                    unterminated () {
                        unterminatedCalled = true;
                    },
                    strictNumericEscape: error,
                    invalidEscapeSequence: error,
                    numericSeparatorInEscapeSequence: error,
                    unexpectedNumericSeparator: error,
                    invalidDigit: error,
                    invalidCodePoint: error
                });
                if (!unterminatedCalled) throw new Error("Invalid raw");
                node.value.cooked = firstInvalidLoc ? null : str;
            })
        },
        tail: {
            default: false
        }
    }
});
defineType("TemplateLiteral", {
    visitor: [
        "quasis",
        "expressions"
    ],
    aliases: [
        "Expression",
        "Literal"
    ],
    fields: {
        quasis: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
        },
        expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
                if (node.quasis.length !== val.length + 1) throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
            })
        }
    }
});
defineType("YieldExpression", {
    builder: [
        "argument",
        "delegate"
    ],
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression",
        "Terminatorless"
    ],
    fields: {
        delegate: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "boolean"
            })),
            default: false
        },
        argument: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("AwaitExpression", {
    builder: [
        "argument"
    ],
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression",
        "Terminatorless"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("Import", {
    aliases: [
        "Expression"
    ]
});
defineType("BigIntLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("ExportNamespaceSpecifier", {
    visitor: [
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("OptionalMemberExpression", {
    builder: [
        "object",
        "property",
        "computed",
        "optional"
    ],
    visitor: [
        "object",
        "property"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator = Object.assign(function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                }, {
                    oneOfNodeTypes: [
                        "Expression",
                        "Identifier"
                    ]
                });
                return validator;
            }()
        },
        computed: {
            default: false
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean")
        }
    }
});
defineType("OptionalCallExpression", {
    visitor: [
        "callee",
        "arguments",
        "typeParameters",
        "typeArguments"
    ],
    builder: [
        "callee",
        "arguments",
        "optional"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        callee: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean")
        },
        typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("ClassProperty", {
    visitor: [
        "key",
        "value",
        "typeAnnotation",
        "decorators"
    ],
    builder: [
        "key",
        "value",
        "typeAnnotation",
        "decorators",
        "computed",
        "static"
    ],
    aliases: [
        "Property"
    ],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
        }
    })
});
defineType("ClassAccessorProperty", {
    visitor: [
        "key",
        "value",
        "typeAnnotation",
        "decorators"
    ],
    builder: [
        "key",
        "value",
        "typeAnnotation",
        "decorators",
        "computed",
        "static"
    ],
    aliases: [
        "Property",
        "Accessor"
    ],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
            validate: (0, _utils.chain)(function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
                const computed = (0, _utils.assertNodeType)("Expression");
                return function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
            }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
        },
        value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
        }
    })
});
defineType("ClassPrivateProperty", {
    visitor: [
        "key",
        "value",
        "decorators",
        "typeAnnotation"
    ],
    builder: [
        "key",
        "value",
        "decorators",
        "static"
    ],
    aliases: [
        "Property",
        "Private"
    ],
    fields: {
        key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        static: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
        }
    }
});
defineType("ClassPrivateMethod", {
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "static"
    ],
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "Private"
    ],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
            validate: (0, _utils.assertOneOf)("get", "set", "method"),
            default: "method"
        },
        key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
defineType("PrivateName", {
    visitor: [
        "id"
    ],
    aliases: [
        "Private"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("StaticBlock", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "FunctionParent"
    ]
});

},{"1cbbf027a3b11931":"1iNYH","e969de64df14bf2a":"co3Ir","8ea5d29fc0e31037":"jsf1q","2e30d9922d343729":"wvm2q","e0ae1d7945a8069e":"dHy0S","254f60056bb01e3d":"5ByWg"}],"1iNYH":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = is;
var _shallowEqual = require("3b3c51f4c91cb1a6");
var _isType = require("3b1dc8d56ac1c7f0");
var _isPlaceholderType = require("c3e04b2fb742ea44");
var _definitions = require("738b852a0a386778");
function is(type, node, opts) {
    if (!node) return false;
    const matches = (0, _isType.default)(node.type, type);
    if (!matches) {
        if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) return (0, _isPlaceholderType.default)(node.expectedNode, type);
        return false;
    }
    if (typeof opts === "undefined") return true;
    else return (0, _shallowEqual.default)(node, opts);
}

},{"3b3c51f4c91cb1a6":"cmTeP","3b1dc8d56ac1c7f0":"8A4sW","c3e04b2fb742ea44":"gZjtX","738b852a0a386778":"32frq"}],"8A4sW":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isType;
var _definitions = require("bbca16df02d964af");
function isType(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (_definitions.ALIAS_KEYS[targetType]) return false;
    const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases) {
        if (aliases[0] === nodeType) return true;
        for (const alias of aliases){
            if (nodeType === alias) return true;
        }
    }
    return false;
}

},{"bbca16df02d964af":"32frq"}],"gZjtX":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isPlaceholderType;
var _definitions = require("af91b24ecd2e1574");
function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases) for (const alias of aliases){
        if (targetType === alias) return true;
    }
    return false;
}

},{"af91b24ecd2e1574":"32frq"}],"co3Ir":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isValidIdentifier;
var _helperValidatorIdentifier = require("fc1232f6454c0fd3");
function isValidIdentifier(name, reserved = true) {
    if (typeof name !== "string") return false;
    if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) return false;
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
}

},{"fc1232f6454c0fd3":"jsf1q"}],"jsf1q":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierChar;
    }
});
Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierName;
    }
});
Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierStart;
    }
});
Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function() {
        return _keyword.isKeyword;
    }
});
Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isReservedWord;
    }
});
Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
    }
});
Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictBindReservedWord;
    }
});
Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictReservedWord;
    }
});
var _identifier = require("9095f8c387aae4b6");
var _keyword = require("837ae8c43edf8a54");

},{"9095f8c387aae4b6":"jTlHj","837ae8c43edf8a54":"2y8rb"}],"jTlHj":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierName = isIdentifierName;
exports.isIdentifierStart = isIdentifierStart;
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
let nonASCIIidentifierChars = "‌‍\xb7̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    68,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    349,
    41,
    7,
    1,
    79,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    20,
    1,
    64,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    16,
    0,
    2,
    12,
    2,
    33,
    125,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1071,
    18,
    5,
    4026,
    582,
    8634,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    689,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    43,
    8,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    16,
    0,
    30,
    2,
    3,
    0,
    15,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    7,
    5,
    262,
    61,
    147,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    485,
    27,
    757,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4153,
    7,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
    1507,
    4938,
    6,
    4191
];
const astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    370,
    1,
    81,
    2,
    71,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    3,
    0,
    158,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    10,
    1,
    2,
    0,
    49,
    6,
    4,
    4,
    14,
    9,
    5351,
    0,
    7,
    14,
    13835,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    1014,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4706,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    101,
    0,
    161,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    499,
    13,
    983,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
];
function isInAstralSet(code, set) {
    let pos = 0x10000;
    for(let i = 0, length = set.length; i < length; i += 2){
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
    }
    return false;
}
function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
function isIdentifierName(name) {
    let isFirst = true;
    for(let i = 0; i < name.length; i++){
        let cp = name.charCodeAt(i);
        if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
            const trail = name.charCodeAt(++i);
            if ((trail & 0xfc00) === 0xdc00) cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
        if (isFirst) {
            isFirst = false;
            if (!isIdentifierStart(cp)) return false;
        } else if (!isIdentifierChar(cp)) return false;
    }
    return !isFirst;
}

},{}],"2y8rb":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isKeyword = isKeyword;
exports.isReservedWord = isReservedWord;
exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
exports.isStrictBindReservedWord = isStrictBindReservedWord;
exports.isStrictReservedWord = isStrictReservedWord;
const reservedWords = {
    keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ],
    strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ],
    strictBind: [
        "eval",
        "arguments"
    ]
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
    return keywords.has(word);
}

},{}],"wvm2q":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readCodePoint = readCodePoint;
exports.readInt = readInt;
exports.readStringContents = readStringContents;
var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
};
const forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([
        46,
        66,
        69,
        79,
        95,
        98,
        101,
        111
    ]),
    hex: new Set([
        46,
        88,
        95,
        120
    ])
};
const isAllowedNumericSeparatorSibling = {
    bin: (ch)=>ch === 48 || ch === 49,
    oct: (ch)=>ch >= 48 && ch <= 55,
    dec: (ch)=>ch >= 48 && ch <= 57,
    hex: (ch)=>ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
};
function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const { length  } = input;
    for(;;){
        if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
        }
        if (ch === 92) {
            out += input.slice(chunkStart, pos);
            const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
            if (res.ch === null && !firstInvalidLoc) firstInvalidLoc = {
                pos,
                lineStart,
                curLine
            };
            else out += res.ch;
            ({ pos , lineStart , curLine  } = res);
            chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
        } else if (ch === 10 || ch === 13) {
            if (type === "template") {
                out += input.slice(chunkStart, pos) + "\n";
                ++pos;
                if (ch === 13 && input.charCodeAt(pos) === 10) ++pos;
                ++curLine;
                chunkStart = lineStart = pos;
            } else errors.unterminated(initialPos, initialLineStart, initialCurLine);
        } else ++pos;
    }
    return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
    };
}
function isStringEnd(type, ch, input, pos) {
    if (type === "template") return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    return ch === (type === "double" ? 34 : 39);
}
function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch)=>({
            pos,
            ch,
            lineStart,
            curLine
        });
    const ch = input.charCodeAt(pos++);
    switch(ch){
        case 110:
            return res("\n");
        case 114:
            return res("\r");
        case 120:
            {
                let code;
                ({ code , pos  } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
                return res(code === null ? null : String.fromCharCode(code));
            }
        case 117:
            {
                let code;
                ({ code , pos  } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
                return res(code === null ? null : String.fromCodePoint(code));
            }
        case 116:
            return res("	");
        case 98:
            return res("\b");
        case 118:
            return res("\v");
        case 102:
            return res("\f");
        case 13:
            if (input.charCodeAt(pos) === 10) ++pos;
        case 10:
            lineStart = pos;
            ++curLine;
        case 8232:
        case 8233:
            return res("");
        case 56:
        case 57:
            if (inTemplate) return res(null);
            else errors.strictNumericEscape(pos - 1, lineStart, curLine);
        default:
            if (ch >= 48 && ch <= 55) {
                const startPos = pos - 1;
                const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
                let octalStr = match[0];
                let octal = parseInt(octalStr, 8);
                if (octal > 255) {
                    octalStr = octalStr.slice(0, -1);
                    octal = parseInt(octalStr, 8);
                }
                pos += octalStr.length - 1;
                const next = input.charCodeAt(pos);
                if (octalStr !== "0" || next === 56 || next === 57) {
                    if (inTemplate) return res(null);
                    else errors.strictNumericEscape(startPos, lineStart, curLine);
                }
                return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
    }
}
function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n;
    ({ n , pos  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    if (n === null) {
        if (throwOnInvalid) errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        else pos = initialPos - 1;
    }
    return {
        code: n,
        pos
    };
}
function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for(let i = 0, e = len == null ? Infinity : len; i < e; ++i){
        const code = input.charCodeAt(pos);
        let val;
        if (code === 95 && allowNumSeparator !== "bail") {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
                if (bailOnError) return {
                    n: null,
                    pos
                };
                errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                if (bailOnError) return {
                    n: null,
                    pos
                };
                errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
        }
        if (code >= 97) val = code - 97 + 10;
        else if (code >= 65) val = code - 65 + 10;
        else if (_isDigit(code)) val = code - 48;
        else val = Infinity;
        if (val >= radix) {
            if (val <= 9 && bailOnError) return {
                n: null,
                pos
            };
            else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) val = 0;
            else if (forceLen) {
                val = 0;
                invalid = true;
            } else break;
        }
        ++pos;
        total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) return {
        n: null,
        pos
    };
    return {
        n: total,
        pos
    };
}
function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code;
    if (ch === 123) {
        ++pos;
        ({ code , pos  } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code !== null && code > 0x10ffff) {
            if (throwOnInvalid) errors.invalidCodePoint(pos, lineStart, curLine);
            else return {
                code: null,
                pos
            };
        }
    } else ({ code , pos  } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    return {
        code,
        pos
    };
}

},{}],"dHy0S":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
const STATEMENT_OR_BLOCK_KEYS = [
    "consequent",
    "body",
    "alternate"
];
exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
const FLATTENABLE_KEYS = [
    "body",
    "expressions"
];
exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
const FOR_INIT_KEYS = [
    "left",
    "init"
];
exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
const COMMENT_KEYS = [
    "leadingComments",
    "trailingComments",
    "innerComments"
];
exports.COMMENT_KEYS = COMMENT_KEYS;
const LOGICAL_OPERATORS = [
    "||",
    "&&",
    "??"
];
exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
const UPDATE_OPERATORS = [
    "++",
    "--"
];
exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
const BOOLEAN_NUMBER_BINARY_OPERATORS = [
    ">",
    "<",
    ">=",
    "<="
];
exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
const EQUALITY_BINARY_OPERATORS = [
    "==",
    "===",
    "!=",
    "!=="
];
exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
const COMPARISON_BINARY_OPERATORS = [
    ...EQUALITY_BINARY_OPERATORS,
    "in",
    "instanceof"
];
exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
const BOOLEAN_BINARY_OPERATORS = [
    ...COMPARISON_BINARY_OPERATORS,
    ...BOOLEAN_NUMBER_BINARY_OPERATORS
];
exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
const NUMBER_BINARY_OPERATORS = [
    "-",
    "/",
    "%",
    "*",
    "**",
    "&",
    "|",
    ">>",
    ">>>",
    "<<",
    "^"
];
exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
const BINARY_OPERATORS = [
    "+",
    ...NUMBER_BINARY_OPERATORS,
    ...BOOLEAN_BINARY_OPERATORS,
    "|>"
];
exports.BINARY_OPERATORS = BINARY_OPERATORS;
const ASSIGNMENT_OPERATORS = [
    "=",
    "+=",
    ...NUMBER_BINARY_OPERATORS.map((op)=>op + "="),
    ...LOGICAL_OPERATORS.map((op)=>op + "=")
];
exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
const BOOLEAN_UNARY_OPERATORS = [
    "delete",
    "!"
];
exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
const NUMBER_UNARY_OPERATORS = [
    "+",
    "-",
    "~"
];
exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
const STRING_UNARY_OPERATORS = [
    "typeof"
];
exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
const UNARY_OPERATORS = [
    "void",
    "throw",
    ...BOOLEAN_UNARY_OPERATORS,
    ...NUMBER_UNARY_OPERATORS,
    ...STRING_UNARY_OPERATORS
];
exports.UNARY_OPERATORS = UNARY_OPERATORS;
const INHERIT_KEYS = {
    optional: [
        "typeAnnotation",
        "typeParameters",
        "returnType"
    ],
    force: [
        "start",
        "loc",
        "end"
    ]
};
exports.INHERIT_KEYS = INHERIT_KEYS;
const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

},{}],"5ByWg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.assertEach = assertEach;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertNodeType = assertNodeType;
exports.assertOneOf = assertOneOf;
exports.assertOptionalChainStart = assertOptionalChainStart;
exports.assertShape = assertShape;
exports.assertValueType = assertValueType;
exports.chain = chain;
exports.default = defineType;
exports.defineAliasedType = defineAliasedType;
exports.typeIs = typeIs;
exports.validate = validate;
exports.validateArrayOfType = validateArrayOfType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.validateType = validateType;
var _is = require("547ef65280f43d26");
var _validate = require("977517dac89328a8");
const VISITOR_KEYS = {};
exports.VISITOR_KEYS = VISITOR_KEYS;
const ALIAS_KEYS = {};
exports.ALIAS_KEYS = ALIAS_KEYS;
const FLIPPED_ALIAS_KEYS = {};
exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
const NODE_FIELDS = {};
exports.NODE_FIELDS = NODE_FIELDS;
const BUILDER_KEYS = {};
exports.BUILDER_KEYS = BUILDER_KEYS;
const DEPRECATED_KEYS = {};
exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
const NODE_PARENT_VALIDATIONS = {};
exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
function getType(val) {
    if (Array.isArray(val)) return "array";
    else if (val === null) return "null";
    else return typeof val;
}
function validate(validate) {
    return {
        validate
    };
}
function typeIs(typeName) {
    return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
}
function validateType(typeName) {
    return validate(typeIs(typeName));
}
function validateOptional(validate) {
    return {
        validate,
        optional: true
    };
}
function validateOptionalType(typeName) {
    return {
        validate: typeIs(typeName),
        optional: true
    };
}
function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
}
function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
}
function validateArrayOfType(typeName) {
    return validate(arrayOfType(typeName));
}
function assertEach(callback) {
    function validator(node, key, val) {
        if (!Array.isArray(val)) return;
        for(let i = 0; i < val.length; i++){
            const subkey = `${key}[${i}]`;
            const v = val[i];
            callback(node, subkey, v);
        }
    }
    validator.each = callback;
    return validator;
}
function assertOneOf(...values) {
    function validate(node, key, val) {
        if (values.indexOf(val) < 0) throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
    }
    validate.oneOf = values;
    return validate;
}
function assertNodeType(...types) {
    function validate(node, key, val) {
        for (const type of types)if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }
    validate.oneOfNodeTypes = types;
    return validate;
}
function assertNodeOrValueType(...types) {
    function validate(node, key, val) {
        for (const type of types)if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }
    validate.oneOfNodeOrValueTypes = types;
    return validate;
}
function assertValueType(type) {
    function validate(node, key, val) {
        const valid = getType(val) === type;
        if (!valid) throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
    validate.type = type;
    return validate;
}
function assertShape(shape) {
    function validate(node, key, val) {
        const errors = [];
        for (const property of Object.keys(shape))try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
        } catch (error) {
            if (error instanceof TypeError) {
                errors.push(error.message);
                continue;
            }
            throw error;
        }
        if (errors.length) throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
    }
    validate.shapeOf = shape;
    return validate;
}
function assertOptionalChainStart() {
    function validate(node) {
        var _current;
        let current = node;
        while(node){
            const { type  } = current;
            if (type === "OptionalCallExpression") {
                if (current.optional) return;
                current = current.callee;
                continue;
            }
            if (type === "OptionalMemberExpression") {
                if (current.optional) return;
                current = current.object;
                continue;
            }
            break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
    }
    return validate;
}
function chain(...fns) {
    function validate(...args) {
        for (const fn of fns)fn(...args);
    }
    validate.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    return validate;
}
const validTypeOpts = [
    "aliases",
    "builder",
    "deprecatedAlias",
    "fields",
    "inherits",
    "visitor",
    "validate"
];
const validFieldKeys = [
    "default",
    "optional",
    "deprecated",
    "validate"
];
const store = {};
function defineAliasedType(...aliases) {
    return (type, opts = {})=>{
        let defined = opts.aliases;
        if (!defined) {
            var _store$opts$inherits$, _defined;
            if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
            (_defined = defined) != null ? _defined : defined = [];
            opts.aliases = defined;
        }
        const additional = aliases.filter((a)=>!defined.includes(a));
        defined.unshift(...additional);
        defineType(type, opts);
    };
}
function defineType(type, opts = {}) {
    const inherits = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;
    if (!fields) {
        fields = {};
        if (inherits.fields) {
            const keys = Object.getOwnPropertyNames(inherits.fields);
            for (const key of keys){
                const field = inherits.fields[key];
                const def = field.default;
                if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") throw new Error("field defaults can only be primitives or empty arrays currently");
                fields[key] = {
                    default: Array.isArray(def) ? [] : def,
                    optional: field.optional,
                    deprecated: field.deprecated,
                    validate: field.validate
                };
            }
        }
    }
    const visitor = opts.visitor || inherits.visitor || [];
    const aliases = opts.aliases || inherits.aliases || [];
    const builder = opts.builder || inherits.builder || opts.visitor || [];
    for (const k of Object.keys(opts)){
        if (validTypeOpts.indexOf(k) === -1) throw new Error(`Unknown type option "${k}" on ${type}`);
    }
    if (opts.deprecatedAlias) DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    for (const key of visitor.concat(builder))fields[key] = fields[key] || {};
    for (const key of Object.keys(fields)){
        const field = fields[key];
        if (field.default !== undefined && builder.indexOf(key) === -1) field.optional = true;
        if (field.default === undefined) field.default = null;
        else if (!field.validate && field.default != null) field.validate = assertValueType(getType(field.default));
        for (const k of Object.keys(field)){
            if (validFieldKeys.indexOf(k) === -1) throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
        }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias)=>{
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) NODE_PARENT_VALIDATIONS[type] = opts.validate;
    store[type] = opts;
}

},{"547ef65280f43d26":"1iNYH","977517dac89328a8":"5qUw2"}],"4aIsr":[function(require,module,exports) {
"use strict";
var _utils = require("dc85d8bd10decfcd");
const defineType = (0, _utils.defineAliasedType)("Flow");
const defineInterfaceishType = (name)=>{
    const isDeclareClass = name === "DeclareClass";
    defineType(name, {
        builder: [
            "id",
            "typeParameters",
            "extends",
            "body"
        ],
        visitor: [
            "id",
            "typeParameters",
            "extends",
            ...isDeclareClass ? [
                "mixins",
                "implements"
            ] : [],
            "body"
        ],
        aliases: [
            "FlowDeclaration",
            "Statement",
            "Declaration"
        ],
        fields: Object.assign({
            id: (0, _utils.validateType)("Identifier"),
            typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
            extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
        }, isDeclareClass ? {
            mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
        } : {}, {
            body: (0, _utils.validateType)("ObjectTypeAnnotation")
        })
    });
};
defineType("AnyTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ArrayTypeAnnotation", {
    visitor: [
        "elementType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        elementType: (0, _utils.validateType)("FlowType")
    }
});
defineType("BooleanTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("BooleanLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("NullLiteralTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ClassImplements", {
    visitor: [
        "id",
        "typeParameters"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineInterfaceishType("DeclareClass");
defineType("DeclareFunction", {
    visitor: [
        "id"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
});
defineInterfaceishType("DeclareInterface");
defineType("DeclareModule", {
    builder: [
        "id",
        "body",
        "kind"
    ],
    visitor: [
        "id",
        "body"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
});
defineType("DeclareModuleExports", {
    visitor: [
        "typeAnnotation"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
});
defineType("DeclareTypeAlias", {
    visitor: [
        "id",
        "typeParameters",
        "right"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
    }
});
defineType("DeclareOpaqueType", {
    visitor: [
        "id",
        "typeParameters",
        "supertype"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
    }
});
defineType("DeclareVariable", {
    visitor: [
        "id"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("DeclareExportDeclaration", {
    visitor: [
        "declaration",
        "specifiers",
        "source"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)([
            "ExportSpecifier",
            "ExportNamespaceSpecifier"
        ])),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("DeclareExportAllDeclaration", {
    visitor: [
        "source"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
});
defineType("DeclaredPredicate", {
    visitor: [
        "value"
    ],
    aliases: [
        "FlowPredicate"
    ],
    fields: {
        value: (0, _utils.validateType)("Flow")
    }
});
defineType("ExistsTypeAnnotation", {
    aliases: [
        "FlowType"
    ]
});
defineType("FunctionTypeAnnotation", {
    visitor: [
        "typeParameters",
        "params",
        "rest",
        "returnType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
    }
});
defineType("FunctionTypeParam", {
    visitor: [
        "name",
        "typeAnnotation"
    ],
    fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("GenericTypeAnnotation", {
    visitor: [
        "id",
        "typeParameters"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineType("InferredPredicate", {
    aliases: [
        "FlowPredicate"
    ]
});
defineType("InterfaceExtends", {
    visitor: [
        "id",
        "typeParameters"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineInterfaceishType("InterfaceDeclaration");
defineType("InterfaceTypeAnnotation", {
    visitor: [
        "extends",
        "body"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
});
defineType("IntersectionTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("MixedTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("EmptyTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("NullableTypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
    }
});
defineType("NumberLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
});
defineType("NumberTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ObjectTypeAnnotation", {
    visitor: [
        "properties",
        "indexers",
        "callProperties",
        "internalSlots"
    ],
    aliases: [
        "FlowType"
    ],
    builder: [
        "properties",
        "indexers",
        "callProperties",
        "internalSlots",
        "exact"
    ],
    fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)([
            "ObjectTypeProperty",
            "ObjectTypeSpreadProperty"
        ])),
        indexers: {
            validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
            optional: true,
            default: []
        },
        callProperties: {
            validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
            optional: true,
            default: []
        },
        internalSlots: {
            validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
            optional: true,
            default: []
        },
        exact: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeInternalSlot", {
    visitor: [
        "id",
        "value",
        "optional",
        "static",
        "method"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeCallProperty", {
    visitor: [
        "value"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeIndexer", {
    visitor: [
        "id",
        "key",
        "value",
        "variance"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
    }
});
defineType("ObjectTypeProperty", {
    visitor: [
        "key",
        "value",
        "variance"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        key: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeSpreadProperty", {
    visitor: [
        "argument"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        argument: (0, _utils.validateType)("FlowType")
    }
});
defineType("OpaqueType", {
    visitor: [
        "id",
        "typeParameters",
        "supertype",
        "impltype"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
    }
});
defineType("QualifiedTypeIdentifier", {
    visitor: [
        "id",
        "qualification"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ])
    }
});
defineType("StringLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
});
defineType("StringTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("SymbolTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ThisTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("TupleTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("TypeofTypeAnnotation", {
    visitor: [
        "argument"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        argument: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeAlias", {
    visitor: [
        "id",
        "typeParameters",
        "right"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeCastExpression", {
    visitor: [
        "expression",
        "typeAnnotation"
    ],
    aliases: [
        "ExpressionWrapper",
        "Expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
});
defineType("TypeParameter", {
    visitor: [
        "bound",
        "default",
        "variance"
    ],
    fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
    }
});
defineType("TypeParameterDeclaration", {
    visitor: [
        "params"
    ],
    fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
});
defineType("TypeParameterInstantiation", {
    visitor: [
        "params"
    ],
    fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("UnionTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("Variance", {
    builder: [
        "kind"
    ],
    fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
});
defineType("VoidTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("EnumDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "body"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)([
            "EnumBooleanBody",
            "EnumNumberBody",
            "EnumStringBody",
            "EnumSymbolBody"
        ])
    }
});
defineType("EnumBooleanBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumNumberBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumStringBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)([
            "EnumStringMember",
            "EnumDefaultedMember"
        ]),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumSymbolBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumBooleanMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
    }
});
defineType("EnumNumberMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
    }
});
defineType("EnumStringMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
    }
});
defineType("EnumDefaultedMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("IndexedAccessType", {
    visitor: [
        "objectType",
        "indexType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
    }
});
defineType("OptionalIndexedAccessType", {
    visitor: [
        "objectType",
        "indexType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});

},{"dc85d8bd10decfcd":"5ByWg"}],"5evAz":[function(require,module,exports) {
"use strict";
var _utils = require("9ea6dd84a0f1b6f");
const defineType = (0, _utils.defineAliasedType)("JSX");
defineType("JSXAttribute", {
    visitor: [
        "name",
        "value"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
    }
});
defineType("JSXClosingElement", {
    visitor: [
        "name"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
    }
});
defineType("JSXElement", {
    builder: [
        "openingElement",
        "closingElement",
        "children",
        "selfClosing"
    ],
    visitor: [
        "openingElement",
        "children",
        "closingElement"
    ],
    aliases: [
        "Immutable",
        "Expression"
    ],
    fields: Object.assign({
        openingElement: {
            validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
    }, {
        selfClosing: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    })
});
defineType("JSXEmptyExpression", {});
defineType("JSXExpressionContainer", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
    }
});
defineType("JSXSpreadChild", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("JSXIdentifier", {
    builder: [
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("JSXMemberExpression", {
    visitor: [
        "object",
        "property"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
    }
});
defineType("JSXNamespacedName", {
    visitor: [
        "namespace",
        "name"
    ],
    fields: {
        namespace: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
    }
});
defineType("JSXOpeningElement", {
    builder: [
        "name",
        "attributes",
        "selfClosing"
    ],
    visitor: [
        "name",
        "attributes"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
            default: false
        },
        attributes: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("JSXSpreadAttribute", {
    visitor: [
        "argument"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("JSXText", {
    aliases: [
        "Immutable"
    ],
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("JSXFragment", {
    builder: [
        "openingFragment",
        "closingFragment",
        "children"
    ],
    visitor: [
        "openingFragment",
        "children",
        "closingFragment"
    ],
    aliases: [
        "Immutable",
        "Expression"
    ],
    fields: {
        openingFragment: {
            validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
            validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
    }
});
defineType("JSXOpeningFragment", {
    aliases: [
        "Immutable"
    ]
});
defineType("JSXClosingFragment", {
    aliases: [
        "Immutable"
    ]
});

},{"9ea6dd84a0f1b6f":"5ByWg"}],"1jcc6":[function(require,module,exports) {
"use strict";
var _utils = require("eb0a05b9d5dbf2a0");
var _placeholders = require("da8cfd5ece491583");
const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
defineType("Noop", {
    visitor: []
});
defineType("Placeholder", {
    visitor: [],
    builder: [
        "expectedNode",
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
            validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
    }
});
defineType("V8IntrinsicIdentifier", {
    builder: [
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});

},{"eb0a05b9d5dbf2a0":"5ByWg","da8cfd5ece491583":"azLWK"}],"azLWK":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
var _utils = require("f7e28f5183fd8688");
const PLACEHOLDERS = [
    "Identifier",
    "StringLiteral",
    "Expression",
    "Statement",
    "Declaration",
    "BlockStatement",
    "ClassBody",
    "Pattern"
];
exports.PLACEHOLDERS = PLACEHOLDERS;
const PLACEHOLDERS_ALIAS = {
    Declaration: [
        "Statement"
    ],
    Pattern: [
        "PatternLike",
        "LVal"
    ]
};
exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
for (const type of PLACEHOLDERS){
    const alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
}
const PLACEHOLDERS_FLIPPED_ALIAS = {};
exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
Object.keys(PLACEHOLDERS_ALIAS).forEach((type)=>{
    PLACEHOLDERS_ALIAS[type].forEach((alias)=>{
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
});

},{"f7e28f5183fd8688":"5ByWg"}],"fsZ4g":[function(require,module,exports) {
"use strict";
var _utils = require("5608f629edea2145");
(0, _utils.default)("ArgumentPlaceholder", {});
(0, _utils.default)("BindExpression", {
    visitor: [
        "object",
        "callee"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        object: {
            validate: Object.assign(()=>{}, {
                oneOfNodeTypes: [
                    "Expression"
                ]
            })
        },
        callee: {
            validate: Object.assign(()=>{}, {
                oneOfNodeTypes: [
                    "Expression"
                ]
            })
        }
    }
});
(0, _utils.default)("ImportAttribute", {
    visitor: [
        "key",
        "value"
    ],
    fields: {
        key: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        }
    }
});
(0, _utils.default)("Decorator", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
(0, _utils.default)("DoExpression", {
    visitor: [
        "body"
    ],
    builder: [
        "body",
        "async"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
        }
    }
});
(0, _utils.default)("ExportDefaultSpecifier", {
    visitor: [
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
(0, _utils.default)("RecordExpression", {
    visitor: [
        "properties"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
        }
    }
});
(0, _utils.default)("TupleExpression", {
    fields: {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
            default: []
        }
    },
    visitor: [
        "elements"
    ],
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("DecimalLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
(0, _utils.default)("ModuleExpression", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.assertNodeType)("Program")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("TopicReference", {
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelineTopicExpression", {
    builder: [
        "expression"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelineBareFunction", {
    builder: [
        "callee"
    ],
    visitor: [
        "callee"
    ],
    fields: {
        callee: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: [
        "Expression"
    ]
});

},{"5608f629edea2145":"5ByWg"}],"4gqhI":[function(require,module,exports) {
"use strict";
var _utils = require("d964985bd56d606d");
var _core = require("38483d35b9d07f8d");
var _is = require("53831cd4d164caee");
const defineType = (0, _utils.defineAliasedType)("TypeScript");
const bool = (0, _utils.assertValueType)("boolean");
const tSFunctionTypeAnnotationCommon = ()=>({
        returnType: {
            validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
            optional: true
        }
    });
defineType("TSParameterProperty", {
    aliases: [
        "LVal"
    ],
    visitor: [
        "parameter"
    ],
    fields: {
        accessibility: {
            validate: (0, _utils.assertOneOf)("public", "private", "protected"),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        parameter: {
            validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    }
});
defineType("TSDeclareFunction", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "params",
        "returnType"
    ],
    fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
});
defineType("TSDeclareMethod", {
    visitor: [
        "decorators",
        "key",
        "typeParameters",
        "params",
        "returnType"
    ],
    fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
});
defineType("TSQualifiedName", {
    aliases: [
        "TSEntityName"
    ],
    visitor: [
        "left",
        "right"
    ],
    fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
    }
});
const signatureDeclarationCommon = ()=>({
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        ["parameters"]: (0, _utils.validateArrayOfType)([
            "Identifier",
            "RestElement"
        ]),
        ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    });
const callConstructSignatureDeclaration = {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ],
    fields: signatureDeclarationCommon()
};
defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
const namedTypeElementCommon = ()=>({
        key: (0, _utils.validateType)("Expression"),
        computed: {
            default: false
        },
        optional: (0, _utils.validateOptional)(bool)
    });
defineType("TSPropertySignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "key",
        "typeAnnotation",
        "initializer"
    ],
    fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        kind: {
            validate: (0, _utils.assertOneOf)("get", "set")
        }
    })
});
defineType("TSMethodSignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "key",
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ],
    fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
            validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
    })
});
defineType("TSIndexSignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "parameters",
        "typeAnnotation"
    ],
    fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
});
const tsKeywordTypes = [
    "TSAnyKeyword",
    "TSBooleanKeyword",
    "TSBigIntKeyword",
    "TSIntrinsicKeyword",
    "TSNeverKeyword",
    "TSNullKeyword",
    "TSNumberKeyword",
    "TSObjectKeyword",
    "TSStringKeyword",
    "TSSymbolKeyword",
    "TSUndefinedKeyword",
    "TSUnknownKeyword",
    "TSVoidKeyword"
];
for (const type of tsKeywordTypes)defineType(type, {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [],
    fields: {}
});
defineType("TSThisType", {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [],
    fields: {}
});
const fnOrCtrBase = {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ]
};
defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon()
}));
defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool)
    })
}));
defineType("TSTypeReference", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeName",
        "typeParameters"
    ],
    fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSTypePredicate", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "parameterName",
        "typeAnnotation"
    ],
    builder: [
        "parameterName",
        "typeAnnotation",
        "asserts"
    ],
    fields: {
        parameterName: (0, _utils.validateType)([
            "Identifier",
            "TSThisType"
        ]),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
    }
});
defineType("TSTypeQuery", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "exprName",
        "typeParameters"
    ],
    fields: {
        exprName: (0, _utils.validateType)([
            "TSEntityName",
            "TSImportType"
        ]),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSTypeLiteral", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "members"
    ],
    fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
});
defineType("TSArrayType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "elementType"
    ],
    fields: {
        elementType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTupleType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "elementTypes"
    ],
    fields: {
        elementTypes: (0, _utils.validateArrayOfType)([
            "TSType",
            "TSNamedTupleMember"
        ])
    }
});
defineType("TSOptionalType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSRestType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSNamedTupleMember", {
    visitor: [
        "label",
        "elementType"
    ],
    builder: [
        "label",
        "elementType",
        "optional"
    ],
    fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
            validate: bool,
            default: false
        },
        elementType: (0, _utils.validateType)("TSType")
    }
});
const unionOrIntersection = {
    aliases: [
        "TSType"
    ],
    visitor: [
        "types"
    ],
    fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
    }
};
defineType("TSUnionType", unionOrIntersection);
defineType("TSIntersectionType", unionOrIntersection);
defineType("TSConditionalType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "checkType",
        "extendsType",
        "trueType",
        "falseType"
    ],
    fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSInferType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameter"
    ],
    fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
});
defineType("TSParenthesizedType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTypeOperator", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSIndexedAccessType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "objectType",
        "indexType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSMappedType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameter",
        "typeAnnotation",
        "nameType"
    ],
    fields: {
        readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeParameter: (0, _utils.validateType)("TSTypeParameter"),
        optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
    }
});
defineType("TSLiteralType", {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [
        "literal"
    ],
    fields: {
        literal: {
            validate: function() {
                const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
                const unaryOperator = (0, _utils.assertOneOf)("-");
                const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
                function validator(parent, key, node) {
                    if ((0, _is.default)("UnaryExpression", node)) {
                        unaryOperator(node, "operator", node.operator);
                        unaryExpression(node, "argument", node.argument);
                    } else literal(parent, key, node);
                }
                validator.oneOfNodeTypes = [
                    "NumericLiteral",
                    "StringLiteral",
                    "BooleanLiteral",
                    "BigIntLiteral",
                    "TemplateLiteral",
                    "UnaryExpression"
                ];
                return validator;
            }()
        }
    }
});
defineType("TSExpressionWithTypeArguments", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "expression",
        "typeParameters"
    ],
    fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSInterfaceDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "extends",
        "body"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
    }
});
defineType("TSInterfaceBody", {
    visitor: [
        "body"
    ],
    fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
});
defineType("TSTypeAliasDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "typeAnnotation"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSInstantiationExpression", {
    aliases: [
        "Expression"
    ],
    visitor: [
        "expression",
        "typeParameters"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
const TSTypeExpression = {
    aliases: [
        "Expression",
        "LVal",
        "PatternLike"
    ],
    visitor: [
        "expression",
        "typeAnnotation"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
};
defineType("TSAsExpression", TSTypeExpression);
defineType("TSSatisfiesExpression", TSTypeExpression);
defineType("TSTypeAssertion", {
    aliases: [
        "Expression",
        "LVal",
        "PatternLike"
    ],
    visitor: [
        "typeAnnotation",
        "expression"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSEnumDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "members"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression")
    }
});
defineType("TSEnumMember", {
    visitor: [
        "id",
        "initializer"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        initializer: (0, _utils.validateOptionalType)("Expression")
    }
});
defineType("TSModuleDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "body"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        global: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        body: (0, _utils.validateType)([
            "TSModuleBlock",
            "TSModuleDeclaration"
        ])
    }
});
defineType("TSModuleBlock", {
    aliases: [
        "Scopable",
        "Block",
        "BlockParent",
        "FunctionParent"
    ],
    visitor: [
        "body"
    ],
    fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
    }
});
defineType("TSImportType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "argument",
        "qualifier",
        "typeParameters"
    ],
    fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSImportEqualsDeclaration", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "id",
        "moduleReference"
    ],
    fields: {
        isExport: (0, _utils.validate)(bool),
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)([
            "TSEntityName",
            "TSExternalModuleReference"
        ]),
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
        }
    }
});
defineType("TSExternalModuleReference", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("StringLiteral")
    }
});
defineType("TSNonNullExpression", {
    aliases: [
        "Expression",
        "LVal",
        "PatternLike"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSExportAssignment", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSNamespaceExportDeclaration", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("TSTypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TSType")
        }
    }
});
defineType("TSTypeParameterInstantiation", {
    visitor: [
        "params"
    ],
    fields: {
        params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
        }
    }
});
defineType("TSTypeParameterDeclaration", {
    visitor: [
        "params"
    ],
    fields: {
        params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
        }
    }
});
defineType("TSTypeParameter", {
    builder: [
        "constraint",
        "default",
        "name"
    ],
    visitor: [
        "constraint",
        "default"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        },
        in: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        out: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        const: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        constraint: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
        },
        default: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
        }
    }
});

},{"d964985bd56d606d":"5ByWg","38483d35b9d07f8d":"gbyBi","53831cd4d164caee":"1iNYH"}],"apAJV":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DEPRECATED_ALIASES = void 0;
const DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
};
exports.DEPRECATED_ALIASES = DEPRECATED_ALIASES;

},{}],"aReY1":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = assertNode;
var _isNode = require("f62735eac939f35a");
function assertNode(node) {
    if (!(0, _isNode.default)(node)) {
        var _node$type;
        const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
    }
}

},{"f62735eac939f35a":"ldCSD"}],"ldCSD":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isNode;
var _definitions = require("1d00987c5ef43823");
function isNode(node) {
    return !!(node && _definitions.VISITOR_KEYS[node.type]);
}

},{"1d00987c5ef43823":"32frq"}],"ff7JR":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertAccessor = assertAccessor;
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
exports.assertArrayExpression = assertArrayExpression;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertBinary = assertBinary;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertBindExpression = assertBindExpression;
exports.assertBlock = assertBlock;
exports.assertBlockParent = assertBlockParent;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertClass = assertClass;
exports.assertClassAccessorProperty = assertClassAccessorProperty;
exports.assertClassBody = assertClassBody;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertClassExpression = assertClassExpression;
exports.assertClassImplements = assertClassImplements;
exports.assertClassMethod = assertClassMethod;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassProperty = assertClassProperty;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDecimalLiteral = assertDecimalLiteral;
exports.assertDeclaration = assertDeclaration;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertDecorator = assertDecorator;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertDoExpression = assertDoExpression;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertEnumBody = assertEnumBody;
exports.assertEnumBooleanBody = assertEnumBooleanBody;
exports.assertEnumBooleanMember = assertEnumBooleanMember;
exports.assertEnumDeclaration = assertEnumDeclaration;
exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
exports.assertEnumMember = assertEnumMember;
exports.assertEnumNumberBody = assertEnumNumberBody;
exports.assertEnumNumberMember = assertEnumNumberMember;
exports.assertEnumStringBody = assertEnumStringBody;
exports.assertEnumStringMember = assertEnumStringMember;
exports.assertEnumSymbolBody = assertEnumSymbolBody;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertExpression = assertExpression;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFile = assertFile;
exports.assertFlow = assertFlow;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertFlowType = assertFlowType;
exports.assertFor = assertFor;
exports.assertForInStatement = assertForInStatement;
exports.assertForOfStatement = assertForOfStatement;
exports.assertForStatement = assertForStatement;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertFunctionParent = assertFunctionParent;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertImmutable = assertImmutable;
exports.assertImport = assertImport;
exports.assertImportAttribute = assertImportAttribute;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertIndexedAccessType = assertIndexedAccessType;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertJSX = assertJSX;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXText = assertJSXText;
exports.assertLVal = assertLVal;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertLiteral = assertLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertLoop = assertLoop;
exports.assertMemberExpression = assertMemberExpression;
exports.assertMetaProperty = assertMetaProperty;
exports.assertMethod = assertMethod;
exports.assertMiscellaneous = assertMiscellaneous;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertModuleExpression = assertModuleExpression;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertNewExpression = assertNewExpression;
exports.assertNoop = assertNoop;
exports.assertNullLiteral = assertNullLiteral;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMember = assertObjectMember;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertObjectProperty = assertObjectProperty;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertPattern = assertPattern;
exports.assertPatternLike = assertPatternLike;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPlaceholder = assertPlaceholder;
exports.assertPrivate = assertPrivate;
exports.assertPrivateName = assertPrivateName;
exports.assertProgram = assertProgram;
exports.assertProperty = assertProperty;
exports.assertPureish = assertPureish;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertRecordExpression = assertRecordExpression;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestElement = assertRestElement;
exports.assertRestProperty = assertRestProperty;
exports.assertReturnStatement = assertReturnStatement;
exports.assertScopable = assertScopable;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSpreadProperty = assertSpreadProperty;
exports.assertStandardized = assertStandardized;
exports.assertStatement = assertStatement;
exports.assertStaticBlock = assertStaticBlock;
exports.assertStringLiteral = assertStringLiteral;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertSuper = assertSuper;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSBaseType = assertTSBaseType;
exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSEntityName = assertTSEntityName;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSImportType = assertTSImportType;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSRestType = assertTSRestType;
exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSType = assertTSType;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertTerminatorless = assertTerminatorless;
exports.assertThisExpression = assertThisExpression;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTopicReference = assertTopicReference;
exports.assertTryStatement = assertTryStatement;
exports.assertTupleExpression = assertTupleExpression;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertTypeScript = assertTypeScript;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUnaryLike = assertUnaryLike;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertWhile = assertWhile;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertYieldExpression = assertYieldExpression;
var _is = require("63965305961ec543");
var _deprecationWarning = require("235a900333d10cf6");
function assert(type, node, opts) {
    if (!(0, _is.default)(type, node, opts)) throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
}
function assertArrayExpression(node, opts) {
    assert("ArrayExpression", node, opts);
}
function assertAssignmentExpression(node, opts) {
    assert("AssignmentExpression", node, opts);
}
function assertBinaryExpression(node, opts) {
    assert("BinaryExpression", node, opts);
}
function assertInterpreterDirective(node, opts) {
    assert("InterpreterDirective", node, opts);
}
function assertDirective(node, opts) {
    assert("Directive", node, opts);
}
function assertDirectiveLiteral(node, opts) {
    assert("DirectiveLiteral", node, opts);
}
function assertBlockStatement(node, opts) {
    assert("BlockStatement", node, opts);
}
function assertBreakStatement(node, opts) {
    assert("BreakStatement", node, opts);
}
function assertCallExpression(node, opts) {
    assert("CallExpression", node, opts);
}
function assertCatchClause(node, opts) {
    assert("CatchClause", node, opts);
}
function assertConditionalExpression(node, opts) {
    assert("ConditionalExpression", node, opts);
}
function assertContinueStatement(node, opts) {
    assert("ContinueStatement", node, opts);
}
function assertDebuggerStatement(node, opts) {
    assert("DebuggerStatement", node, opts);
}
function assertDoWhileStatement(node, opts) {
    assert("DoWhileStatement", node, opts);
}
function assertEmptyStatement(node, opts) {
    assert("EmptyStatement", node, opts);
}
function assertExpressionStatement(node, opts) {
    assert("ExpressionStatement", node, opts);
}
function assertFile(node, opts) {
    assert("File", node, opts);
}
function assertForInStatement(node, opts) {
    assert("ForInStatement", node, opts);
}
function assertForStatement(node, opts) {
    assert("ForStatement", node, opts);
}
function assertFunctionDeclaration(node, opts) {
    assert("FunctionDeclaration", node, opts);
}
function assertFunctionExpression(node, opts) {
    assert("FunctionExpression", node, opts);
}
function assertIdentifier(node, opts) {
    assert("Identifier", node, opts);
}
function assertIfStatement(node, opts) {
    assert("IfStatement", node, opts);
}
function assertLabeledStatement(node, opts) {
    assert("LabeledStatement", node, opts);
}
function assertStringLiteral(node, opts) {
    assert("StringLiteral", node, opts);
}
function assertNumericLiteral(node, opts) {
    assert("NumericLiteral", node, opts);
}
function assertNullLiteral(node, opts) {
    assert("NullLiteral", node, opts);
}
function assertBooleanLiteral(node, opts) {
    assert("BooleanLiteral", node, opts);
}
function assertRegExpLiteral(node, opts) {
    assert("RegExpLiteral", node, opts);
}
function assertLogicalExpression(node, opts) {
    assert("LogicalExpression", node, opts);
}
function assertMemberExpression(node, opts) {
    assert("MemberExpression", node, opts);
}
function assertNewExpression(node, opts) {
    assert("NewExpression", node, opts);
}
function assertProgram(node, opts) {
    assert("Program", node, opts);
}
function assertObjectExpression(node, opts) {
    assert("ObjectExpression", node, opts);
}
function assertObjectMethod(node, opts) {
    assert("ObjectMethod", node, opts);
}
function assertObjectProperty(node, opts) {
    assert("ObjectProperty", node, opts);
}
function assertRestElement(node, opts) {
    assert("RestElement", node, opts);
}
function assertReturnStatement(node, opts) {
    assert("ReturnStatement", node, opts);
}
function assertSequenceExpression(node, opts) {
    assert("SequenceExpression", node, opts);
}
function assertParenthesizedExpression(node, opts) {
    assert("ParenthesizedExpression", node, opts);
}
function assertSwitchCase(node, opts) {
    assert("SwitchCase", node, opts);
}
function assertSwitchStatement(node, opts) {
    assert("SwitchStatement", node, opts);
}
function assertThisExpression(node, opts) {
    assert("ThisExpression", node, opts);
}
function assertThrowStatement(node, opts) {
    assert("ThrowStatement", node, opts);
}
function assertTryStatement(node, opts) {
    assert("TryStatement", node, opts);
}
function assertUnaryExpression(node, opts) {
    assert("UnaryExpression", node, opts);
}
function assertUpdateExpression(node, opts) {
    assert("UpdateExpression", node, opts);
}
function assertVariableDeclaration(node, opts) {
    assert("VariableDeclaration", node, opts);
}
function assertVariableDeclarator(node, opts) {
    assert("VariableDeclarator", node, opts);
}
function assertWhileStatement(node, opts) {
    assert("WhileStatement", node, opts);
}
function assertWithStatement(node, opts) {
    assert("WithStatement", node, opts);
}
function assertAssignmentPattern(node, opts) {
    assert("AssignmentPattern", node, opts);
}
function assertArrayPattern(node, opts) {
    assert("ArrayPattern", node, opts);
}
function assertArrowFunctionExpression(node, opts) {
    assert("ArrowFunctionExpression", node, opts);
}
function assertClassBody(node, opts) {
    assert("ClassBody", node, opts);
}
function assertClassExpression(node, opts) {
    assert("ClassExpression", node, opts);
}
function assertClassDeclaration(node, opts) {
    assert("ClassDeclaration", node, opts);
}
function assertExportAllDeclaration(node, opts) {
    assert("ExportAllDeclaration", node, opts);
}
function assertExportDefaultDeclaration(node, opts) {
    assert("ExportDefaultDeclaration", node, opts);
}
function assertExportNamedDeclaration(node, opts) {
    assert("ExportNamedDeclaration", node, opts);
}
function assertExportSpecifier(node, opts) {
    assert("ExportSpecifier", node, opts);
}
function assertForOfStatement(node, opts) {
    assert("ForOfStatement", node, opts);
}
function assertImportDeclaration(node, opts) {
    assert("ImportDeclaration", node, opts);
}
function assertImportDefaultSpecifier(node, opts) {
    assert("ImportDefaultSpecifier", node, opts);
}
function assertImportNamespaceSpecifier(node, opts) {
    assert("ImportNamespaceSpecifier", node, opts);
}
function assertImportSpecifier(node, opts) {
    assert("ImportSpecifier", node, opts);
}
function assertMetaProperty(node, opts) {
    assert("MetaProperty", node, opts);
}
function assertClassMethod(node, opts) {
    assert("ClassMethod", node, opts);
}
function assertObjectPattern(node, opts) {
    assert("ObjectPattern", node, opts);
}
function assertSpreadElement(node, opts) {
    assert("SpreadElement", node, opts);
}
function assertSuper(node, opts) {
    assert("Super", node, opts);
}
function assertTaggedTemplateExpression(node, opts) {
    assert("TaggedTemplateExpression", node, opts);
}
function assertTemplateElement(node, opts) {
    assert("TemplateElement", node, opts);
}
function assertTemplateLiteral(node, opts) {
    assert("TemplateLiteral", node, opts);
}
function assertYieldExpression(node, opts) {
    assert("YieldExpression", node, opts);
}
function assertAwaitExpression(node, opts) {
    assert("AwaitExpression", node, opts);
}
function assertImport(node, opts) {
    assert("Import", node, opts);
}
function assertBigIntLiteral(node, opts) {
    assert("BigIntLiteral", node, opts);
}
function assertExportNamespaceSpecifier(node, opts) {
    assert("ExportNamespaceSpecifier", node, opts);
}
function assertOptionalMemberExpression(node, opts) {
    assert("OptionalMemberExpression", node, opts);
}
function assertOptionalCallExpression(node, opts) {
    assert("OptionalCallExpression", node, opts);
}
function assertClassProperty(node, opts) {
    assert("ClassProperty", node, opts);
}
function assertClassAccessorProperty(node, opts) {
    assert("ClassAccessorProperty", node, opts);
}
function assertClassPrivateProperty(node, opts) {
    assert("ClassPrivateProperty", node, opts);
}
function assertClassPrivateMethod(node, opts) {
    assert("ClassPrivateMethod", node, opts);
}
function assertPrivateName(node, opts) {
    assert("PrivateName", node, opts);
}
function assertStaticBlock(node, opts) {
    assert("StaticBlock", node, opts);
}
function assertAnyTypeAnnotation(node, opts) {
    assert("AnyTypeAnnotation", node, opts);
}
function assertArrayTypeAnnotation(node, opts) {
    assert("ArrayTypeAnnotation", node, opts);
}
function assertBooleanTypeAnnotation(node, opts) {
    assert("BooleanTypeAnnotation", node, opts);
}
function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
}
function assertNullLiteralTypeAnnotation(node, opts) {
    assert("NullLiteralTypeAnnotation", node, opts);
}
function assertClassImplements(node, opts) {
    assert("ClassImplements", node, opts);
}
function assertDeclareClass(node, opts) {
    assert("DeclareClass", node, opts);
}
function assertDeclareFunction(node, opts) {
    assert("DeclareFunction", node, opts);
}
function assertDeclareInterface(node, opts) {
    assert("DeclareInterface", node, opts);
}
function assertDeclareModule(node, opts) {
    assert("DeclareModule", node, opts);
}
function assertDeclareModuleExports(node, opts) {
    assert("DeclareModuleExports", node, opts);
}
function assertDeclareTypeAlias(node, opts) {
    assert("DeclareTypeAlias", node, opts);
}
function assertDeclareOpaqueType(node, opts) {
    assert("DeclareOpaqueType", node, opts);
}
function assertDeclareVariable(node, opts) {
    assert("DeclareVariable", node, opts);
}
function assertDeclareExportDeclaration(node, opts) {
    assert("DeclareExportDeclaration", node, opts);
}
function assertDeclareExportAllDeclaration(node, opts) {
    assert("DeclareExportAllDeclaration", node, opts);
}
function assertDeclaredPredicate(node, opts) {
    assert("DeclaredPredicate", node, opts);
}
function assertExistsTypeAnnotation(node, opts) {
    assert("ExistsTypeAnnotation", node, opts);
}
function assertFunctionTypeAnnotation(node, opts) {
    assert("FunctionTypeAnnotation", node, opts);
}
function assertFunctionTypeParam(node, opts) {
    assert("FunctionTypeParam", node, opts);
}
function assertGenericTypeAnnotation(node, opts) {
    assert("GenericTypeAnnotation", node, opts);
}
function assertInferredPredicate(node, opts) {
    assert("InferredPredicate", node, opts);
}
function assertInterfaceExtends(node, opts) {
    assert("InterfaceExtends", node, opts);
}
function assertInterfaceDeclaration(node, opts) {
    assert("InterfaceDeclaration", node, opts);
}
function assertInterfaceTypeAnnotation(node, opts) {
    assert("InterfaceTypeAnnotation", node, opts);
}
function assertIntersectionTypeAnnotation(node, opts) {
    assert("IntersectionTypeAnnotation", node, opts);
}
function assertMixedTypeAnnotation(node, opts) {
    assert("MixedTypeAnnotation", node, opts);
}
function assertEmptyTypeAnnotation(node, opts) {
    assert("EmptyTypeAnnotation", node, opts);
}
function assertNullableTypeAnnotation(node, opts) {
    assert("NullableTypeAnnotation", node, opts);
}
function assertNumberLiteralTypeAnnotation(node, opts) {
    assert("NumberLiteralTypeAnnotation", node, opts);
}
function assertNumberTypeAnnotation(node, opts) {
    assert("NumberTypeAnnotation", node, opts);
}
function assertObjectTypeAnnotation(node, opts) {
    assert("ObjectTypeAnnotation", node, opts);
}
function assertObjectTypeInternalSlot(node, opts) {
    assert("ObjectTypeInternalSlot", node, opts);
}
function assertObjectTypeCallProperty(node, opts) {
    assert("ObjectTypeCallProperty", node, opts);
}
function assertObjectTypeIndexer(node, opts) {
    assert("ObjectTypeIndexer", node, opts);
}
function assertObjectTypeProperty(node, opts) {
    assert("ObjectTypeProperty", node, opts);
}
function assertObjectTypeSpreadProperty(node, opts) {
    assert("ObjectTypeSpreadProperty", node, opts);
}
function assertOpaqueType(node, opts) {
    assert("OpaqueType", node, opts);
}
function assertQualifiedTypeIdentifier(node, opts) {
    assert("QualifiedTypeIdentifier", node, opts);
}
function assertStringLiteralTypeAnnotation(node, opts) {
    assert("StringLiteralTypeAnnotation", node, opts);
}
function assertStringTypeAnnotation(node, opts) {
    assert("StringTypeAnnotation", node, opts);
}
function assertSymbolTypeAnnotation(node, opts) {
    assert("SymbolTypeAnnotation", node, opts);
}
function assertThisTypeAnnotation(node, opts) {
    assert("ThisTypeAnnotation", node, opts);
}
function assertTupleTypeAnnotation(node, opts) {
    assert("TupleTypeAnnotation", node, opts);
}
function assertTypeofTypeAnnotation(node, opts) {
    assert("TypeofTypeAnnotation", node, opts);
}
function assertTypeAlias(node, opts) {
    assert("TypeAlias", node, opts);
}
function assertTypeAnnotation(node, opts) {
    assert("TypeAnnotation", node, opts);
}
function assertTypeCastExpression(node, opts) {
    assert("TypeCastExpression", node, opts);
}
function assertTypeParameter(node, opts) {
    assert("TypeParameter", node, opts);
}
function assertTypeParameterDeclaration(node, opts) {
    assert("TypeParameterDeclaration", node, opts);
}
function assertTypeParameterInstantiation(node, opts) {
    assert("TypeParameterInstantiation", node, opts);
}
function assertUnionTypeAnnotation(node, opts) {
    assert("UnionTypeAnnotation", node, opts);
}
function assertVariance(node, opts) {
    assert("Variance", node, opts);
}
function assertVoidTypeAnnotation(node, opts) {
    assert("VoidTypeAnnotation", node, opts);
}
function assertEnumDeclaration(node, opts) {
    assert("EnumDeclaration", node, opts);
}
function assertEnumBooleanBody(node, opts) {
    assert("EnumBooleanBody", node, opts);
}
function assertEnumNumberBody(node, opts) {
    assert("EnumNumberBody", node, opts);
}
function assertEnumStringBody(node, opts) {
    assert("EnumStringBody", node, opts);
}
function assertEnumSymbolBody(node, opts) {
    assert("EnumSymbolBody", node, opts);
}
function assertEnumBooleanMember(node, opts) {
    assert("EnumBooleanMember", node, opts);
}
function assertEnumNumberMember(node, opts) {
    assert("EnumNumberMember", node, opts);
}
function assertEnumStringMember(node, opts) {
    assert("EnumStringMember", node, opts);
}
function assertEnumDefaultedMember(node, opts) {
    assert("EnumDefaultedMember", node, opts);
}
function assertIndexedAccessType(node, opts) {
    assert("IndexedAccessType", node, opts);
}
function assertOptionalIndexedAccessType(node, opts) {
    assert("OptionalIndexedAccessType", node, opts);
}
function assertJSXAttribute(node, opts) {
    assert("JSXAttribute", node, opts);
}
function assertJSXClosingElement(node, opts) {
    assert("JSXClosingElement", node, opts);
}
function assertJSXElement(node, opts) {
    assert("JSXElement", node, opts);
}
function assertJSXEmptyExpression(node, opts) {
    assert("JSXEmptyExpression", node, opts);
}
function assertJSXExpressionContainer(node, opts) {
    assert("JSXExpressionContainer", node, opts);
}
function assertJSXSpreadChild(node, opts) {
    assert("JSXSpreadChild", node, opts);
}
function assertJSXIdentifier(node, opts) {
    assert("JSXIdentifier", node, opts);
}
function assertJSXMemberExpression(node, opts) {
    assert("JSXMemberExpression", node, opts);
}
function assertJSXNamespacedName(node, opts) {
    assert("JSXNamespacedName", node, opts);
}
function assertJSXOpeningElement(node, opts) {
    assert("JSXOpeningElement", node, opts);
}
function assertJSXSpreadAttribute(node, opts) {
    assert("JSXSpreadAttribute", node, opts);
}
function assertJSXText(node, opts) {
    assert("JSXText", node, opts);
}
function assertJSXFragment(node, opts) {
    assert("JSXFragment", node, opts);
}
function assertJSXOpeningFragment(node, opts) {
    assert("JSXOpeningFragment", node, opts);
}
function assertJSXClosingFragment(node, opts) {
    assert("JSXClosingFragment", node, opts);
}
function assertNoop(node, opts) {
    assert("Noop", node, opts);
}
function assertPlaceholder(node, opts) {
    assert("Placeholder", node, opts);
}
function assertV8IntrinsicIdentifier(node, opts) {
    assert("V8IntrinsicIdentifier", node, opts);
}
function assertArgumentPlaceholder(node, opts) {
    assert("ArgumentPlaceholder", node, opts);
}
function assertBindExpression(node, opts) {
    assert("BindExpression", node, opts);
}
function assertImportAttribute(node, opts) {
    assert("ImportAttribute", node, opts);
}
function assertDecorator(node, opts) {
    assert("Decorator", node, opts);
}
function assertDoExpression(node, opts) {
    assert("DoExpression", node, opts);
}
function assertExportDefaultSpecifier(node, opts) {
    assert("ExportDefaultSpecifier", node, opts);
}
function assertRecordExpression(node, opts) {
    assert("RecordExpression", node, opts);
}
function assertTupleExpression(node, opts) {
    assert("TupleExpression", node, opts);
}
function assertDecimalLiteral(node, opts) {
    assert("DecimalLiteral", node, opts);
}
function assertModuleExpression(node, opts) {
    assert("ModuleExpression", node, opts);
}
function assertTopicReference(node, opts) {
    assert("TopicReference", node, opts);
}
function assertPipelineTopicExpression(node, opts) {
    assert("PipelineTopicExpression", node, opts);
}
function assertPipelineBareFunction(node, opts) {
    assert("PipelineBareFunction", node, opts);
}
function assertPipelinePrimaryTopicReference(node, opts) {
    assert("PipelinePrimaryTopicReference", node, opts);
}
function assertTSParameterProperty(node, opts) {
    assert("TSParameterProperty", node, opts);
}
function assertTSDeclareFunction(node, opts) {
    assert("TSDeclareFunction", node, opts);
}
function assertTSDeclareMethod(node, opts) {
    assert("TSDeclareMethod", node, opts);
}
function assertTSQualifiedName(node, opts) {
    assert("TSQualifiedName", node, opts);
}
function assertTSCallSignatureDeclaration(node, opts) {
    assert("TSCallSignatureDeclaration", node, opts);
}
function assertTSConstructSignatureDeclaration(node, opts) {
    assert("TSConstructSignatureDeclaration", node, opts);
}
function assertTSPropertySignature(node, opts) {
    assert("TSPropertySignature", node, opts);
}
function assertTSMethodSignature(node, opts) {
    assert("TSMethodSignature", node, opts);
}
function assertTSIndexSignature(node, opts) {
    assert("TSIndexSignature", node, opts);
}
function assertTSAnyKeyword(node, opts) {
    assert("TSAnyKeyword", node, opts);
}
function assertTSBooleanKeyword(node, opts) {
    assert("TSBooleanKeyword", node, opts);
}
function assertTSBigIntKeyword(node, opts) {
    assert("TSBigIntKeyword", node, opts);
}
function assertTSIntrinsicKeyword(node, opts) {
    assert("TSIntrinsicKeyword", node, opts);
}
function assertTSNeverKeyword(node, opts) {
    assert("TSNeverKeyword", node, opts);
}
function assertTSNullKeyword(node, opts) {
    assert("TSNullKeyword", node, opts);
}
function assertTSNumberKeyword(node, opts) {
    assert("TSNumberKeyword", node, opts);
}
function assertTSObjectKeyword(node, opts) {
    assert("TSObjectKeyword", node, opts);
}
function assertTSStringKeyword(node, opts) {
    assert("TSStringKeyword", node, opts);
}
function assertTSSymbolKeyword(node, opts) {
    assert("TSSymbolKeyword", node, opts);
}
function assertTSUndefinedKeyword(node, opts) {
    assert("TSUndefinedKeyword", node, opts);
}
function assertTSUnknownKeyword(node, opts) {
    assert("TSUnknownKeyword", node, opts);
}
function assertTSVoidKeyword(node, opts) {
    assert("TSVoidKeyword", node, opts);
}
function assertTSThisType(node, opts) {
    assert("TSThisType", node, opts);
}
function assertTSFunctionType(node, opts) {
    assert("TSFunctionType", node, opts);
}
function assertTSConstructorType(node, opts) {
    assert("TSConstructorType", node, opts);
}
function assertTSTypeReference(node, opts) {
    assert("TSTypeReference", node, opts);
}
function assertTSTypePredicate(node, opts) {
    assert("TSTypePredicate", node, opts);
}
function assertTSTypeQuery(node, opts) {
    assert("TSTypeQuery", node, opts);
}
function assertTSTypeLiteral(node, opts) {
    assert("TSTypeLiteral", node, opts);
}
function assertTSArrayType(node, opts) {
    assert("TSArrayType", node, opts);
}
function assertTSTupleType(node, opts) {
    assert("TSTupleType", node, opts);
}
function assertTSOptionalType(node, opts) {
    assert("TSOptionalType", node, opts);
}
function assertTSRestType(node, opts) {
    assert("TSRestType", node, opts);
}
function assertTSNamedTupleMember(node, opts) {
    assert("TSNamedTupleMember", node, opts);
}
function assertTSUnionType(node, opts) {
    assert("TSUnionType", node, opts);
}
function assertTSIntersectionType(node, opts) {
    assert("TSIntersectionType", node, opts);
}
function assertTSConditionalType(node, opts) {
    assert("TSConditionalType", node, opts);
}
function assertTSInferType(node, opts) {
    assert("TSInferType", node, opts);
}
function assertTSParenthesizedType(node, opts) {
    assert("TSParenthesizedType", node, opts);
}
function assertTSTypeOperator(node, opts) {
    assert("TSTypeOperator", node, opts);
}
function assertTSIndexedAccessType(node, opts) {
    assert("TSIndexedAccessType", node, opts);
}
function assertTSMappedType(node, opts) {
    assert("TSMappedType", node, opts);
}
function assertTSLiteralType(node, opts) {
    assert("TSLiteralType", node, opts);
}
function assertTSExpressionWithTypeArguments(node, opts) {
    assert("TSExpressionWithTypeArguments", node, opts);
}
function assertTSInterfaceDeclaration(node, opts) {
    assert("TSInterfaceDeclaration", node, opts);
}
function assertTSInterfaceBody(node, opts) {
    assert("TSInterfaceBody", node, opts);
}
function assertTSTypeAliasDeclaration(node, opts) {
    assert("TSTypeAliasDeclaration", node, opts);
}
function assertTSInstantiationExpression(node, opts) {
    assert("TSInstantiationExpression", node, opts);
}
function assertTSAsExpression(node, opts) {
    assert("TSAsExpression", node, opts);
}
function assertTSSatisfiesExpression(node, opts) {
    assert("TSSatisfiesExpression", node, opts);
}
function assertTSTypeAssertion(node, opts) {
    assert("TSTypeAssertion", node, opts);
}
function assertTSEnumDeclaration(node, opts) {
    assert("TSEnumDeclaration", node, opts);
}
function assertTSEnumMember(node, opts) {
    assert("TSEnumMember", node, opts);
}
function assertTSModuleDeclaration(node, opts) {
    assert("TSModuleDeclaration", node, opts);
}
function assertTSModuleBlock(node, opts) {
    assert("TSModuleBlock", node, opts);
}
function assertTSImportType(node, opts) {
    assert("TSImportType", node, opts);
}
function assertTSImportEqualsDeclaration(node, opts) {
    assert("TSImportEqualsDeclaration", node, opts);
}
function assertTSExternalModuleReference(node, opts) {
    assert("TSExternalModuleReference", node, opts);
}
function assertTSNonNullExpression(node, opts) {
    assert("TSNonNullExpression", node, opts);
}
function assertTSExportAssignment(node, opts) {
    assert("TSExportAssignment", node, opts);
}
function assertTSNamespaceExportDeclaration(node, opts) {
    assert("TSNamespaceExportDeclaration", node, opts);
}
function assertTSTypeAnnotation(node, opts) {
    assert("TSTypeAnnotation", node, opts);
}
function assertTSTypeParameterInstantiation(node, opts) {
    assert("TSTypeParameterInstantiation", node, opts);
}
function assertTSTypeParameterDeclaration(node, opts) {
    assert("TSTypeParameterDeclaration", node, opts);
}
function assertTSTypeParameter(node, opts) {
    assert("TSTypeParameter", node, opts);
}
function assertStandardized(node, opts) {
    assert("Standardized", node, opts);
}
function assertExpression(node, opts) {
    assert("Expression", node, opts);
}
function assertBinary(node, opts) {
    assert("Binary", node, opts);
}
function assertScopable(node, opts) {
    assert("Scopable", node, opts);
}
function assertBlockParent(node, opts) {
    assert("BlockParent", node, opts);
}
function assertBlock(node, opts) {
    assert("Block", node, opts);
}
function assertStatement(node, opts) {
    assert("Statement", node, opts);
}
function assertTerminatorless(node, opts) {
    assert("Terminatorless", node, opts);
}
function assertCompletionStatement(node, opts) {
    assert("CompletionStatement", node, opts);
}
function assertConditional(node, opts) {
    assert("Conditional", node, opts);
}
function assertLoop(node, opts) {
    assert("Loop", node, opts);
}
function assertWhile(node, opts) {
    assert("While", node, opts);
}
function assertExpressionWrapper(node, opts) {
    assert("ExpressionWrapper", node, opts);
}
function assertFor(node, opts) {
    assert("For", node, opts);
}
function assertForXStatement(node, opts) {
    assert("ForXStatement", node, opts);
}
function assertFunction(node, opts) {
    assert("Function", node, opts);
}
function assertFunctionParent(node, opts) {
    assert("FunctionParent", node, opts);
}
function assertPureish(node, opts) {
    assert("Pureish", node, opts);
}
function assertDeclaration(node, opts) {
    assert("Declaration", node, opts);
}
function assertPatternLike(node, opts) {
    assert("PatternLike", node, opts);
}
function assertLVal(node, opts) {
    assert("LVal", node, opts);
}
function assertTSEntityName(node, opts) {
    assert("TSEntityName", node, opts);
}
function assertLiteral(node, opts) {
    assert("Literal", node, opts);
}
function assertImmutable(node, opts) {
    assert("Immutable", node, opts);
}
function assertUserWhitespacable(node, opts) {
    assert("UserWhitespacable", node, opts);
}
function assertMethod(node, opts) {
    assert("Method", node, opts);
}
function assertObjectMember(node, opts) {
    assert("ObjectMember", node, opts);
}
function assertProperty(node, opts) {
    assert("Property", node, opts);
}
function assertUnaryLike(node, opts) {
    assert("UnaryLike", node, opts);
}
function assertPattern(node, opts) {
    assert("Pattern", node, opts);
}
function assertClass(node, opts) {
    assert("Class", node, opts);
}
function assertImportOrExportDeclaration(node, opts) {
    assert("ImportOrExportDeclaration", node, opts);
}
function assertExportDeclaration(node, opts) {
    assert("ExportDeclaration", node, opts);
}
function assertModuleSpecifier(node, opts) {
    assert("ModuleSpecifier", node, opts);
}
function assertAccessor(node, opts) {
    assert("Accessor", node, opts);
}
function assertPrivate(node, opts) {
    assert("Private", node, opts);
}
function assertFlow(node, opts) {
    assert("Flow", node, opts);
}
function assertFlowType(node, opts) {
    assert("FlowType", node, opts);
}
function assertFlowBaseAnnotation(node, opts) {
    assert("FlowBaseAnnotation", node, opts);
}
function assertFlowDeclaration(node, opts) {
    assert("FlowDeclaration", node, opts);
}
function assertFlowPredicate(node, opts) {
    assert("FlowPredicate", node, opts);
}
function assertEnumBody(node, opts) {
    assert("EnumBody", node, opts);
}
function assertEnumMember(node, opts) {
    assert("EnumMember", node, opts);
}
function assertJSX(node, opts) {
    assert("JSX", node, opts);
}
function assertMiscellaneous(node, opts) {
    assert("Miscellaneous", node, opts);
}
function assertTypeScript(node, opts) {
    assert("TypeScript", node, opts);
}
function assertTSTypeElement(node, opts) {
    assert("TSTypeElement", node, opts);
}
function assertTSType(node, opts) {
    assert("TSType", node, opts);
}
function assertTSBaseType(node, opts) {
    assert("TSBaseType", node, opts);
}
function assertNumberLiteral(node, opts) {
    (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
    assert("NumberLiteral", node, opts);
}
function assertRegexLiteral(node, opts) {
    (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
    assert("RegexLiteral", node, opts);
}
function assertRestProperty(node, opts) {
    (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
    assert("RestProperty", node, opts);
}
function assertSpreadProperty(node, opts) {
    (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
    assert("SpreadProperty", node, opts);
}
function assertModuleDeclaration(node, opts) {
    (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
    assert("ModuleDeclaration", node, opts);
}

},{"63965305961ec543":"1iNYH","235a900333d10cf6":"dnmbV"}],"029ot":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("747113b444bcf36");
var _default = createTypeAnnotationBasedOnTypeof;
exports.default = _default;
function createTypeAnnotationBasedOnTypeof(type) {
    switch(type){
        case "string":
            return (0, _generated.stringTypeAnnotation)();
        case "number":
            return (0, _generated.numberTypeAnnotation)();
        case "undefined":
            return (0, _generated.voidTypeAnnotation)();
        case "boolean":
            return (0, _generated.booleanTypeAnnotation)();
        case "function":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
        case "object":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
        case "symbol":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
        case "bigint":
            return (0, _generated.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
}

},{"747113b444bcf36":"fvX9A"}],"ibg5t":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createFlowUnionType;
var _generated = require("542d3b173504bb08");
var _removeTypeDuplicates = require("b65ca78e474a1645");
function createFlowUnionType(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) return flattened[0];
    else return (0, _generated.unionTypeAnnotation)(flattened);
}

},{"542d3b173504bb08":"fvX9A","b65ca78e474a1645":"jX5sp"}],"jX5sp":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeTypeDuplicates;
var _generated = require("ad787dbac299f17c");
function getQualifiedName(node) {
    return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
}
function removeTypeDuplicates(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = new Map();
    const bases = new Map();
    const typeGroups = new Set();
    const types = [];
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        if (!node) continue;
        if (types.indexOf(node) >= 0) continue;
        if ((0, _generated.isAnyTypeAnnotation)(node)) return [
            node
        ];
        if ((0, _generated.isFlowBaseAnnotation)(node)) {
            bases.set(node.type, node);
            continue;
        }
        if ((0, _generated.isUnionTypeAnnotation)(node)) {
            if (!typeGroups.has(node.types)) {
                nodes.push(...node.types);
                typeGroups.add(node.types);
            }
            continue;
        }
        if ((0, _generated.isGenericTypeAnnotation)(node)) {
            const name = getQualifiedName(node.id);
            if (generics.has(name)) {
                let existing = generics.get(name);
                if (existing.typeParameters) {
                    if (node.typeParameters) {
                        existing.typeParameters.params.push(...node.typeParameters.params);
                        existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
                    }
                } else existing = node.typeParameters;
            } else generics.set(name, node);
            continue;
        }
        types.push(node);
    }
    for (const [, baseType] of bases)types.push(baseType);
    for (const [, genericName] of generics)types.push(genericName);
    return types;
}

},{"ad787dbac299f17c":"lrUKn"}],"fgFzg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createTSUnionType;
var _generated = require("d6d8e564dcec73eb");
var _removeTypeDuplicates = require("25a420ca075e0352");
var _index = require("2cc427584ee4e489");
function createTSUnionType(typeAnnotations) {
    const types = typeAnnotations.map((type)=>{
        return (0, _index.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
    });
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) return flattened[0];
    else return (0, _generated.tsUnionType)(flattened);
}

},{"d6d8e564dcec73eb":"fvX9A","25a420ca075e0352":"aB3jw","2cc427584ee4e489":"lrUKn"}],"aB3jw":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeTypeDuplicates;
var _generated = require("510459adc1bdc75");
function getQualifiedName(node) {
    return (0, _generated.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;
}
function removeTypeDuplicates(nodesIn) {
    const nodes = Array.from(nodesIn);
    const generics = new Map();
    const bases = new Map();
    const typeGroups = new Set();
    const types = [];
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        if (!node) continue;
        if (types.indexOf(node) >= 0) continue;
        if ((0, _generated.isTSAnyKeyword)(node)) return [
            node
        ];
        if ((0, _generated.isTSBaseType)(node)) {
            bases.set(node.type, node);
            continue;
        }
        if ((0, _generated.isTSUnionType)(node)) {
            if (!typeGroups.has(node.types)) {
                nodes.push(...node.types);
                typeGroups.add(node.types);
            }
            continue;
        }
        if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {
            const name = getQualifiedName(node.typeName);
            if (generics.has(name)) {
                let existing = generics.get(name);
                if (existing.typeParameters) {
                    if (node.typeParameters) {
                        existing.typeParameters.params.push(...node.typeParameters.params);
                        existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
                    }
                } else existing = node.typeParameters;
            } else generics.set(name, node);
            continue;
        }
        types.push(node);
    }
    for (const [, baseType] of bases)types.push(baseType);
    for (const [, genericName] of generics)types.push(genericName);
    return types;
}

},{"510459adc1bdc75":"lrUKn"}],"5Eayz":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AnyTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.anyTypeAnnotation;
    }
});
Object.defineProperty(exports, "ArgumentPlaceholder", {
    enumerable: true,
    get: function() {
        return _index.argumentPlaceholder;
    }
});
Object.defineProperty(exports, "ArrayExpression", {
    enumerable: true,
    get: function() {
        return _index.arrayExpression;
    }
});
Object.defineProperty(exports, "ArrayPattern", {
    enumerable: true,
    get: function() {
        return _index.arrayPattern;
    }
});
Object.defineProperty(exports, "ArrayTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.arrayTypeAnnotation;
    }
});
Object.defineProperty(exports, "ArrowFunctionExpression", {
    enumerable: true,
    get: function() {
        return _index.arrowFunctionExpression;
    }
});
Object.defineProperty(exports, "AssignmentExpression", {
    enumerable: true,
    get: function() {
        return _index.assignmentExpression;
    }
});
Object.defineProperty(exports, "AssignmentPattern", {
    enumerable: true,
    get: function() {
        return _index.assignmentPattern;
    }
});
Object.defineProperty(exports, "AwaitExpression", {
    enumerable: true,
    get: function() {
        return _index.awaitExpression;
    }
});
Object.defineProperty(exports, "BigIntLiteral", {
    enumerable: true,
    get: function() {
        return _index.bigIntLiteral;
    }
});
Object.defineProperty(exports, "BinaryExpression", {
    enumerable: true,
    get: function() {
        return _index.binaryExpression;
    }
});
Object.defineProperty(exports, "BindExpression", {
    enumerable: true,
    get: function() {
        return _index.bindExpression;
    }
});
Object.defineProperty(exports, "BlockStatement", {
    enumerable: true,
    get: function() {
        return _index.blockStatement;
    }
});
Object.defineProperty(exports, "BooleanLiteral", {
    enumerable: true,
    get: function() {
        return _index.booleanLiteral;
    }
});
Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.booleanLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "BooleanTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.booleanTypeAnnotation;
    }
});
Object.defineProperty(exports, "BreakStatement", {
    enumerable: true,
    get: function() {
        return _index.breakStatement;
    }
});
Object.defineProperty(exports, "CallExpression", {
    enumerable: true,
    get: function() {
        return _index.callExpression;
    }
});
Object.defineProperty(exports, "CatchClause", {
    enumerable: true,
    get: function() {
        return _index.catchClause;
    }
});
Object.defineProperty(exports, "ClassAccessorProperty", {
    enumerable: true,
    get: function() {
        return _index.classAccessorProperty;
    }
});
Object.defineProperty(exports, "ClassBody", {
    enumerable: true,
    get: function() {
        return _index.classBody;
    }
});
Object.defineProperty(exports, "ClassDeclaration", {
    enumerable: true,
    get: function() {
        return _index.classDeclaration;
    }
});
Object.defineProperty(exports, "ClassExpression", {
    enumerable: true,
    get: function() {
        return _index.classExpression;
    }
});
Object.defineProperty(exports, "ClassImplements", {
    enumerable: true,
    get: function() {
        return _index.classImplements;
    }
});
Object.defineProperty(exports, "ClassMethod", {
    enumerable: true,
    get: function() {
        return _index.classMethod;
    }
});
Object.defineProperty(exports, "ClassPrivateMethod", {
    enumerable: true,
    get: function() {
        return _index.classPrivateMethod;
    }
});
Object.defineProperty(exports, "ClassPrivateProperty", {
    enumerable: true,
    get: function() {
        return _index.classPrivateProperty;
    }
});
Object.defineProperty(exports, "ClassProperty", {
    enumerable: true,
    get: function() {
        return _index.classProperty;
    }
});
Object.defineProperty(exports, "ConditionalExpression", {
    enumerable: true,
    get: function() {
        return _index.conditionalExpression;
    }
});
Object.defineProperty(exports, "ContinueStatement", {
    enumerable: true,
    get: function() {
        return _index.continueStatement;
    }
});
Object.defineProperty(exports, "DebuggerStatement", {
    enumerable: true,
    get: function() {
        return _index.debuggerStatement;
    }
});
Object.defineProperty(exports, "DecimalLiteral", {
    enumerable: true,
    get: function() {
        return _index.decimalLiteral;
    }
});
Object.defineProperty(exports, "DeclareClass", {
    enumerable: true,
    get: function() {
        return _index.declareClass;
    }
});
Object.defineProperty(exports, "DeclareExportAllDeclaration", {
    enumerable: true,
    get: function() {
        return _index.declareExportAllDeclaration;
    }
});
Object.defineProperty(exports, "DeclareExportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.declareExportDeclaration;
    }
});
Object.defineProperty(exports, "DeclareFunction", {
    enumerable: true,
    get: function() {
        return _index.declareFunction;
    }
});
Object.defineProperty(exports, "DeclareInterface", {
    enumerable: true,
    get: function() {
        return _index.declareInterface;
    }
});
Object.defineProperty(exports, "DeclareModule", {
    enumerable: true,
    get: function() {
        return _index.declareModule;
    }
});
Object.defineProperty(exports, "DeclareModuleExports", {
    enumerable: true,
    get: function() {
        return _index.declareModuleExports;
    }
});
Object.defineProperty(exports, "DeclareOpaqueType", {
    enumerable: true,
    get: function() {
        return _index.declareOpaqueType;
    }
});
Object.defineProperty(exports, "DeclareTypeAlias", {
    enumerable: true,
    get: function() {
        return _index.declareTypeAlias;
    }
});
Object.defineProperty(exports, "DeclareVariable", {
    enumerable: true,
    get: function() {
        return _index.declareVariable;
    }
});
Object.defineProperty(exports, "DeclaredPredicate", {
    enumerable: true,
    get: function() {
        return _index.declaredPredicate;
    }
});
Object.defineProperty(exports, "Decorator", {
    enumerable: true,
    get: function() {
        return _index.decorator;
    }
});
Object.defineProperty(exports, "Directive", {
    enumerable: true,
    get: function() {
        return _index.directive;
    }
});
Object.defineProperty(exports, "DirectiveLiteral", {
    enumerable: true,
    get: function() {
        return _index.directiveLiteral;
    }
});
Object.defineProperty(exports, "DoExpression", {
    enumerable: true,
    get: function() {
        return _index.doExpression;
    }
});
Object.defineProperty(exports, "DoWhileStatement", {
    enumerable: true,
    get: function() {
        return _index.doWhileStatement;
    }
});
Object.defineProperty(exports, "EmptyStatement", {
    enumerable: true,
    get: function() {
        return _index.emptyStatement;
    }
});
Object.defineProperty(exports, "EmptyTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.emptyTypeAnnotation;
    }
});
Object.defineProperty(exports, "EnumBooleanBody", {
    enumerable: true,
    get: function() {
        return _index.enumBooleanBody;
    }
});
Object.defineProperty(exports, "EnumBooleanMember", {
    enumerable: true,
    get: function() {
        return _index.enumBooleanMember;
    }
});
Object.defineProperty(exports, "EnumDeclaration", {
    enumerable: true,
    get: function() {
        return _index.enumDeclaration;
    }
});
Object.defineProperty(exports, "EnumDefaultedMember", {
    enumerable: true,
    get: function() {
        return _index.enumDefaultedMember;
    }
});
Object.defineProperty(exports, "EnumNumberBody", {
    enumerable: true,
    get: function() {
        return _index.enumNumberBody;
    }
});
Object.defineProperty(exports, "EnumNumberMember", {
    enumerable: true,
    get: function() {
        return _index.enumNumberMember;
    }
});
Object.defineProperty(exports, "EnumStringBody", {
    enumerable: true,
    get: function() {
        return _index.enumStringBody;
    }
});
Object.defineProperty(exports, "EnumStringMember", {
    enumerable: true,
    get: function() {
        return _index.enumStringMember;
    }
});
Object.defineProperty(exports, "EnumSymbolBody", {
    enumerable: true,
    get: function() {
        return _index.enumSymbolBody;
    }
});
Object.defineProperty(exports, "ExistsTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.existsTypeAnnotation;
    }
});
Object.defineProperty(exports, "ExportAllDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportAllDeclaration;
    }
});
Object.defineProperty(exports, "ExportDefaultDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportDefaultDeclaration;
    }
});
Object.defineProperty(exports, "ExportDefaultSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportDefaultSpecifier;
    }
});
Object.defineProperty(exports, "ExportNamedDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportNamedDeclaration;
    }
});
Object.defineProperty(exports, "ExportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportNamespaceSpecifier;
    }
});
Object.defineProperty(exports, "ExportSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportSpecifier;
    }
});
Object.defineProperty(exports, "ExpressionStatement", {
    enumerable: true,
    get: function() {
        return _index.expressionStatement;
    }
});
Object.defineProperty(exports, "File", {
    enumerable: true,
    get: function() {
        return _index.file;
    }
});
Object.defineProperty(exports, "ForInStatement", {
    enumerable: true,
    get: function() {
        return _index.forInStatement;
    }
});
Object.defineProperty(exports, "ForOfStatement", {
    enumerable: true,
    get: function() {
        return _index.forOfStatement;
    }
});
Object.defineProperty(exports, "ForStatement", {
    enumerable: true,
    get: function() {
        return _index.forStatement;
    }
});
Object.defineProperty(exports, "FunctionDeclaration", {
    enumerable: true,
    get: function() {
        return _index.functionDeclaration;
    }
});
Object.defineProperty(exports, "FunctionExpression", {
    enumerable: true,
    get: function() {
        return _index.functionExpression;
    }
});
Object.defineProperty(exports, "FunctionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.functionTypeAnnotation;
    }
});
Object.defineProperty(exports, "FunctionTypeParam", {
    enumerable: true,
    get: function() {
        return _index.functionTypeParam;
    }
});
Object.defineProperty(exports, "GenericTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.genericTypeAnnotation;
    }
});
Object.defineProperty(exports, "Identifier", {
    enumerable: true,
    get: function() {
        return _index.identifier;
    }
});
Object.defineProperty(exports, "IfStatement", {
    enumerable: true,
    get: function() {
        return _index.ifStatement;
    }
});
Object.defineProperty(exports, "Import", {
    enumerable: true,
    get: function() {
        return _index.import;
    }
});
Object.defineProperty(exports, "ImportAttribute", {
    enumerable: true,
    get: function() {
        return _index.importAttribute;
    }
});
Object.defineProperty(exports, "ImportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.importDeclaration;
    }
});
Object.defineProperty(exports, "ImportDefaultSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importDefaultSpecifier;
    }
});
Object.defineProperty(exports, "ImportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importNamespaceSpecifier;
    }
});
Object.defineProperty(exports, "ImportSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importSpecifier;
    }
});
Object.defineProperty(exports, "IndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.indexedAccessType;
    }
});
Object.defineProperty(exports, "InferredPredicate", {
    enumerable: true,
    get: function() {
        return _index.inferredPredicate;
    }
});
Object.defineProperty(exports, "InterfaceDeclaration", {
    enumerable: true,
    get: function() {
        return _index.interfaceDeclaration;
    }
});
Object.defineProperty(exports, "InterfaceExtends", {
    enumerable: true,
    get: function() {
        return _index.interfaceExtends;
    }
});
Object.defineProperty(exports, "InterfaceTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.interfaceTypeAnnotation;
    }
});
Object.defineProperty(exports, "InterpreterDirective", {
    enumerable: true,
    get: function() {
        return _index.interpreterDirective;
    }
});
Object.defineProperty(exports, "IntersectionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.intersectionTypeAnnotation;
    }
});
Object.defineProperty(exports, "JSXAttribute", {
    enumerable: true,
    get: function() {
        return _index.jsxAttribute;
    }
});
Object.defineProperty(exports, "JSXClosingElement", {
    enumerable: true,
    get: function() {
        return _index.jsxClosingElement;
    }
});
Object.defineProperty(exports, "JSXClosingFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxClosingFragment;
    }
});
Object.defineProperty(exports, "JSXElement", {
    enumerable: true,
    get: function() {
        return _index.jsxElement;
    }
});
Object.defineProperty(exports, "JSXEmptyExpression", {
    enumerable: true,
    get: function() {
        return _index.jsxEmptyExpression;
    }
});
Object.defineProperty(exports, "JSXExpressionContainer", {
    enumerable: true,
    get: function() {
        return _index.jsxExpressionContainer;
    }
});
Object.defineProperty(exports, "JSXFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxFragment;
    }
});
Object.defineProperty(exports, "JSXIdentifier", {
    enumerable: true,
    get: function() {
        return _index.jsxIdentifier;
    }
});
Object.defineProperty(exports, "JSXMemberExpression", {
    enumerable: true,
    get: function() {
        return _index.jsxMemberExpression;
    }
});
Object.defineProperty(exports, "JSXNamespacedName", {
    enumerable: true,
    get: function() {
        return _index.jsxNamespacedName;
    }
});
Object.defineProperty(exports, "JSXOpeningElement", {
    enumerable: true,
    get: function() {
        return _index.jsxOpeningElement;
    }
});
Object.defineProperty(exports, "JSXOpeningFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxOpeningFragment;
    }
});
Object.defineProperty(exports, "JSXSpreadAttribute", {
    enumerable: true,
    get: function() {
        return _index.jsxSpreadAttribute;
    }
});
Object.defineProperty(exports, "JSXSpreadChild", {
    enumerable: true,
    get: function() {
        return _index.jsxSpreadChild;
    }
});
Object.defineProperty(exports, "JSXText", {
    enumerable: true,
    get: function() {
        return _index.jsxText;
    }
});
Object.defineProperty(exports, "LabeledStatement", {
    enumerable: true,
    get: function() {
        return _index.labeledStatement;
    }
});
Object.defineProperty(exports, "LogicalExpression", {
    enumerable: true,
    get: function() {
        return _index.logicalExpression;
    }
});
Object.defineProperty(exports, "MemberExpression", {
    enumerable: true,
    get: function() {
        return _index.memberExpression;
    }
});
Object.defineProperty(exports, "MetaProperty", {
    enumerable: true,
    get: function() {
        return _index.metaProperty;
    }
});
Object.defineProperty(exports, "MixedTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.mixedTypeAnnotation;
    }
});
Object.defineProperty(exports, "ModuleExpression", {
    enumerable: true,
    get: function() {
        return _index.moduleExpression;
    }
});
Object.defineProperty(exports, "NewExpression", {
    enumerable: true,
    get: function() {
        return _index.newExpression;
    }
});
Object.defineProperty(exports, "Noop", {
    enumerable: true,
    get: function() {
        return _index.noop;
    }
});
Object.defineProperty(exports, "NullLiteral", {
    enumerable: true,
    get: function() {
        return _index.nullLiteral;
    }
});
Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.nullLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "NullableTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.nullableTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumberLiteral", {
    enumerable: true,
    get: function() {
        return _index.numberLiteral;
    }
});
Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.numberLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumberTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.numberTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumericLiteral", {
    enumerable: true,
    get: function() {
        return _index.numericLiteral;
    }
});
Object.defineProperty(exports, "ObjectExpression", {
    enumerable: true,
    get: function() {
        return _index.objectExpression;
    }
});
Object.defineProperty(exports, "ObjectMethod", {
    enumerable: true,
    get: function() {
        return _index.objectMethod;
    }
});
Object.defineProperty(exports, "ObjectPattern", {
    enumerable: true,
    get: function() {
        return _index.objectPattern;
    }
});
Object.defineProperty(exports, "ObjectProperty", {
    enumerable: true,
    get: function() {
        return _index.objectProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.objectTypeAnnotation;
    }
});
Object.defineProperty(exports, "ObjectTypeCallProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeCallProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeIndexer", {
    enumerable: true,
    get: function() {
        return _index.objectTypeIndexer;
    }
});
Object.defineProperty(exports, "ObjectTypeInternalSlot", {
    enumerable: true,
    get: function() {
        return _index.objectTypeInternalSlot;
    }
});
Object.defineProperty(exports, "ObjectTypeProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeSpreadProperty;
    }
});
Object.defineProperty(exports, "OpaqueType", {
    enumerable: true,
    get: function() {
        return _index.opaqueType;
    }
});
Object.defineProperty(exports, "OptionalCallExpression", {
    enumerable: true,
    get: function() {
        return _index.optionalCallExpression;
    }
});
Object.defineProperty(exports, "OptionalIndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.optionalIndexedAccessType;
    }
});
Object.defineProperty(exports, "OptionalMemberExpression", {
    enumerable: true,
    get: function() {
        return _index.optionalMemberExpression;
    }
});
Object.defineProperty(exports, "ParenthesizedExpression", {
    enumerable: true,
    get: function() {
        return _index.parenthesizedExpression;
    }
});
Object.defineProperty(exports, "PipelineBareFunction", {
    enumerable: true,
    get: function() {
        return _index.pipelineBareFunction;
    }
});
Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
    enumerable: true,
    get: function() {
        return _index.pipelinePrimaryTopicReference;
    }
});
Object.defineProperty(exports, "PipelineTopicExpression", {
    enumerable: true,
    get: function() {
        return _index.pipelineTopicExpression;
    }
});
Object.defineProperty(exports, "Placeholder", {
    enumerable: true,
    get: function() {
        return _index.placeholder;
    }
});
Object.defineProperty(exports, "PrivateName", {
    enumerable: true,
    get: function() {
        return _index.privateName;
    }
});
Object.defineProperty(exports, "Program", {
    enumerable: true,
    get: function() {
        return _index.program;
    }
});
Object.defineProperty(exports, "QualifiedTypeIdentifier", {
    enumerable: true,
    get: function() {
        return _index.qualifiedTypeIdentifier;
    }
});
Object.defineProperty(exports, "RecordExpression", {
    enumerable: true,
    get: function() {
        return _index.recordExpression;
    }
});
Object.defineProperty(exports, "RegExpLiteral", {
    enumerable: true,
    get: function() {
        return _index.regExpLiteral;
    }
});
Object.defineProperty(exports, "RegexLiteral", {
    enumerable: true,
    get: function() {
        return _index.regexLiteral;
    }
});
Object.defineProperty(exports, "RestElement", {
    enumerable: true,
    get: function() {
        return _index.restElement;
    }
});
Object.defineProperty(exports, "RestProperty", {
    enumerable: true,
    get: function() {
        return _index.restProperty;
    }
});
Object.defineProperty(exports, "ReturnStatement", {
    enumerable: true,
    get: function() {
        return _index.returnStatement;
    }
});
Object.defineProperty(exports, "SequenceExpression", {
    enumerable: true,
    get: function() {
        return _index.sequenceExpression;
    }
});
Object.defineProperty(exports, "SpreadElement", {
    enumerable: true,
    get: function() {
        return _index.spreadElement;
    }
});
Object.defineProperty(exports, "SpreadProperty", {
    enumerable: true,
    get: function() {
        return _index.spreadProperty;
    }
});
Object.defineProperty(exports, "StaticBlock", {
    enumerable: true,
    get: function() {
        return _index.staticBlock;
    }
});
Object.defineProperty(exports, "StringLiteral", {
    enumerable: true,
    get: function() {
        return _index.stringLiteral;
    }
});
Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.stringLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "StringTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.stringTypeAnnotation;
    }
});
Object.defineProperty(exports, "Super", {
    enumerable: true,
    get: function() {
        return _index.super;
    }
});
Object.defineProperty(exports, "SwitchCase", {
    enumerable: true,
    get: function() {
        return _index.switchCase;
    }
});
Object.defineProperty(exports, "SwitchStatement", {
    enumerable: true,
    get: function() {
        return _index.switchStatement;
    }
});
Object.defineProperty(exports, "SymbolTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.symbolTypeAnnotation;
    }
});
Object.defineProperty(exports, "TSAnyKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsAnyKeyword;
    }
});
Object.defineProperty(exports, "TSArrayType", {
    enumerable: true,
    get: function() {
        return _index.tsArrayType;
    }
});
Object.defineProperty(exports, "TSAsExpression", {
    enumerable: true,
    get: function() {
        return _index.tsAsExpression;
    }
});
Object.defineProperty(exports, "TSBigIntKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsBigIntKeyword;
    }
});
Object.defineProperty(exports, "TSBooleanKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsBooleanKeyword;
    }
});
Object.defineProperty(exports, "TSCallSignatureDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsCallSignatureDeclaration;
    }
});
Object.defineProperty(exports, "TSConditionalType", {
    enumerable: true,
    get: function() {
        return _index.tsConditionalType;
    }
});
Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsConstructSignatureDeclaration;
    }
});
Object.defineProperty(exports, "TSConstructorType", {
    enumerable: true,
    get: function() {
        return _index.tsConstructorType;
    }
});
Object.defineProperty(exports, "TSDeclareFunction", {
    enumerable: true,
    get: function() {
        return _index.tsDeclareFunction;
    }
});
Object.defineProperty(exports, "TSDeclareMethod", {
    enumerable: true,
    get: function() {
        return _index.tsDeclareMethod;
    }
});
Object.defineProperty(exports, "TSEnumDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsEnumDeclaration;
    }
});
Object.defineProperty(exports, "TSEnumMember", {
    enumerable: true,
    get: function() {
        return _index.tsEnumMember;
    }
});
Object.defineProperty(exports, "TSExportAssignment", {
    enumerable: true,
    get: function() {
        return _index.tsExportAssignment;
    }
});
Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
    enumerable: true,
    get: function() {
        return _index.tsExpressionWithTypeArguments;
    }
});
Object.defineProperty(exports, "TSExternalModuleReference", {
    enumerable: true,
    get: function() {
        return _index.tsExternalModuleReference;
    }
});
Object.defineProperty(exports, "TSFunctionType", {
    enumerable: true,
    get: function() {
        return _index.tsFunctionType;
    }
});
Object.defineProperty(exports, "TSImportEqualsDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsImportEqualsDeclaration;
    }
});
Object.defineProperty(exports, "TSImportType", {
    enumerable: true,
    get: function() {
        return _index.tsImportType;
    }
});
Object.defineProperty(exports, "TSIndexSignature", {
    enumerable: true,
    get: function() {
        return _index.tsIndexSignature;
    }
});
Object.defineProperty(exports, "TSIndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.tsIndexedAccessType;
    }
});
Object.defineProperty(exports, "TSInferType", {
    enumerable: true,
    get: function() {
        return _index.tsInferType;
    }
});
Object.defineProperty(exports, "TSInstantiationExpression", {
    enumerable: true,
    get: function() {
        return _index.tsInstantiationExpression;
    }
});
Object.defineProperty(exports, "TSInterfaceBody", {
    enumerable: true,
    get: function() {
        return _index.tsInterfaceBody;
    }
});
Object.defineProperty(exports, "TSInterfaceDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsInterfaceDeclaration;
    }
});
Object.defineProperty(exports, "TSIntersectionType", {
    enumerable: true,
    get: function() {
        return _index.tsIntersectionType;
    }
});
Object.defineProperty(exports, "TSIntrinsicKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsIntrinsicKeyword;
    }
});
Object.defineProperty(exports, "TSLiteralType", {
    enumerable: true,
    get: function() {
        return _index.tsLiteralType;
    }
});
Object.defineProperty(exports, "TSMappedType", {
    enumerable: true,
    get: function() {
        return _index.tsMappedType;
    }
});
Object.defineProperty(exports, "TSMethodSignature", {
    enumerable: true,
    get: function() {
        return _index.tsMethodSignature;
    }
});
Object.defineProperty(exports, "TSModuleBlock", {
    enumerable: true,
    get: function() {
        return _index.tsModuleBlock;
    }
});
Object.defineProperty(exports, "TSModuleDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsModuleDeclaration;
    }
});
Object.defineProperty(exports, "TSNamedTupleMember", {
    enumerable: true,
    get: function() {
        return _index.tsNamedTupleMember;
    }
});
Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsNamespaceExportDeclaration;
    }
});
Object.defineProperty(exports, "TSNeverKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNeverKeyword;
    }
});
Object.defineProperty(exports, "TSNonNullExpression", {
    enumerable: true,
    get: function() {
        return _index.tsNonNullExpression;
    }
});
Object.defineProperty(exports, "TSNullKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNullKeyword;
    }
});
Object.defineProperty(exports, "TSNumberKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNumberKeyword;
    }
});
Object.defineProperty(exports, "TSObjectKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsObjectKeyword;
    }
});
Object.defineProperty(exports, "TSOptionalType", {
    enumerable: true,
    get: function() {
        return _index.tsOptionalType;
    }
});
Object.defineProperty(exports, "TSParameterProperty", {
    enumerable: true,
    get: function() {
        return _index.tsParameterProperty;
    }
});
Object.defineProperty(exports, "TSParenthesizedType", {
    enumerable: true,
    get: function() {
        return _index.tsParenthesizedType;
    }
});
Object.defineProperty(exports, "TSPropertySignature", {
    enumerable: true,
    get: function() {
        return _index.tsPropertySignature;
    }
});
Object.defineProperty(exports, "TSQualifiedName", {
    enumerable: true,
    get: function() {
        return _index.tsQualifiedName;
    }
});
Object.defineProperty(exports, "TSRestType", {
    enumerable: true,
    get: function() {
        return _index.tsRestType;
    }
});
Object.defineProperty(exports, "TSSatisfiesExpression", {
    enumerable: true,
    get: function() {
        return _index.tsSatisfiesExpression;
    }
});
Object.defineProperty(exports, "TSStringKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsStringKeyword;
    }
});
Object.defineProperty(exports, "TSSymbolKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsSymbolKeyword;
    }
});
Object.defineProperty(exports, "TSThisType", {
    enumerable: true,
    get: function() {
        return _index.tsThisType;
    }
});
Object.defineProperty(exports, "TSTupleType", {
    enumerable: true,
    get: function() {
        return _index.tsTupleType;
    }
});
Object.defineProperty(exports, "TSTypeAliasDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAliasDeclaration;
    }
});
Object.defineProperty(exports, "TSTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAnnotation;
    }
});
Object.defineProperty(exports, "TSTypeAssertion", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAssertion;
    }
});
Object.defineProperty(exports, "TSTypeLiteral", {
    enumerable: true,
    get: function() {
        return _index.tsTypeLiteral;
    }
});
Object.defineProperty(exports, "TSTypeOperator", {
    enumerable: true,
    get: function() {
        return _index.tsTypeOperator;
    }
});
Object.defineProperty(exports, "TSTypeParameter", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameter;
    }
});
Object.defineProperty(exports, "TSTypeParameterDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameterDeclaration;
    }
});
Object.defineProperty(exports, "TSTypeParameterInstantiation", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameterInstantiation;
    }
});
Object.defineProperty(exports, "TSTypePredicate", {
    enumerable: true,
    get: function() {
        return _index.tsTypePredicate;
    }
});
Object.defineProperty(exports, "TSTypeQuery", {
    enumerable: true,
    get: function() {
        return _index.tsTypeQuery;
    }
});
Object.defineProperty(exports, "TSTypeReference", {
    enumerable: true,
    get: function() {
        return _index.tsTypeReference;
    }
});
Object.defineProperty(exports, "TSUndefinedKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsUndefinedKeyword;
    }
});
Object.defineProperty(exports, "TSUnionType", {
    enumerable: true,
    get: function() {
        return _index.tsUnionType;
    }
});
Object.defineProperty(exports, "TSUnknownKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsUnknownKeyword;
    }
});
Object.defineProperty(exports, "TSVoidKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsVoidKeyword;
    }
});
Object.defineProperty(exports, "TaggedTemplateExpression", {
    enumerable: true,
    get: function() {
        return _index.taggedTemplateExpression;
    }
});
Object.defineProperty(exports, "TemplateElement", {
    enumerable: true,
    get: function() {
        return _index.templateElement;
    }
});
Object.defineProperty(exports, "TemplateLiteral", {
    enumerable: true,
    get: function() {
        return _index.templateLiteral;
    }
});
Object.defineProperty(exports, "ThisExpression", {
    enumerable: true,
    get: function() {
        return _index.thisExpression;
    }
});
Object.defineProperty(exports, "ThisTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.thisTypeAnnotation;
    }
});
Object.defineProperty(exports, "ThrowStatement", {
    enumerable: true,
    get: function() {
        return _index.throwStatement;
    }
});
Object.defineProperty(exports, "TopicReference", {
    enumerable: true,
    get: function() {
        return _index.topicReference;
    }
});
Object.defineProperty(exports, "TryStatement", {
    enumerable: true,
    get: function() {
        return _index.tryStatement;
    }
});
Object.defineProperty(exports, "TupleExpression", {
    enumerable: true,
    get: function() {
        return _index.tupleExpression;
    }
});
Object.defineProperty(exports, "TupleTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.tupleTypeAnnotation;
    }
});
Object.defineProperty(exports, "TypeAlias", {
    enumerable: true,
    get: function() {
        return _index.typeAlias;
    }
});
Object.defineProperty(exports, "TypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.typeAnnotation;
    }
});
Object.defineProperty(exports, "TypeCastExpression", {
    enumerable: true,
    get: function() {
        return _index.typeCastExpression;
    }
});
Object.defineProperty(exports, "TypeParameter", {
    enumerable: true,
    get: function() {
        return _index.typeParameter;
    }
});
Object.defineProperty(exports, "TypeParameterDeclaration", {
    enumerable: true,
    get: function() {
        return _index.typeParameterDeclaration;
    }
});
Object.defineProperty(exports, "TypeParameterInstantiation", {
    enumerable: true,
    get: function() {
        return _index.typeParameterInstantiation;
    }
});
Object.defineProperty(exports, "TypeofTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.typeofTypeAnnotation;
    }
});
Object.defineProperty(exports, "UnaryExpression", {
    enumerable: true,
    get: function() {
        return _index.unaryExpression;
    }
});
Object.defineProperty(exports, "UnionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.unionTypeAnnotation;
    }
});
Object.defineProperty(exports, "UpdateExpression", {
    enumerable: true,
    get: function() {
        return _index.updateExpression;
    }
});
Object.defineProperty(exports, "V8IntrinsicIdentifier", {
    enumerable: true,
    get: function() {
        return _index.v8IntrinsicIdentifier;
    }
});
Object.defineProperty(exports, "VariableDeclaration", {
    enumerable: true,
    get: function() {
        return _index.variableDeclaration;
    }
});
Object.defineProperty(exports, "VariableDeclarator", {
    enumerable: true,
    get: function() {
        return _index.variableDeclarator;
    }
});
Object.defineProperty(exports, "Variance", {
    enumerable: true,
    get: function() {
        return _index.variance;
    }
});
Object.defineProperty(exports, "VoidTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.voidTypeAnnotation;
    }
});
Object.defineProperty(exports, "WhileStatement", {
    enumerable: true,
    get: function() {
        return _index.whileStatement;
    }
});
Object.defineProperty(exports, "WithStatement", {
    enumerable: true,
    get: function() {
        return _index.withStatement;
    }
});
Object.defineProperty(exports, "YieldExpression", {
    enumerable: true,
    get: function() {
        return _index.yieldExpression;
    }
});
var _index = require("56e600e2872b3490");

},{"56e600e2872b3490":"fvX9A"}],"dSpB5":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneNode;
var _definitions = require("487a3e1b5654886e");
var _generated = require("3f92ff028c1c9cd9");
const has = Function.call.bind(Object.prototype.hasOwnProperty);
function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === "string") return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    return obj;
}
function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) return obj.map((node)=>cloneIfNode(node, deep, withoutLoc, commentsCache));
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
}
function cloneNode(node, deep = true, withoutLoc = false) {
    return cloneNodeInternal(node, deep, withoutLoc, new Map());
}
function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
    if (!node) return node;
    const { type  } = node;
    const newNode = {
        type: node.type
    };
    if ((0, _generated.isIdentifier)(node)) {
        newNode.name = node.name;
        if (has(node, "optional") && typeof node.optional === "boolean") newNode.optional = node.optional;
        if (has(node, "typeAnnotation")) newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
    } else if (!has(_definitions.NODE_FIELDS, type)) throw new Error(`Unknown node type: "${type}"`);
    else {
        for (const field of Object.keys(_definitions.NODE_FIELDS[type]))if (has(node, field)) {
            if (deep) newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
            else newNode[field] = node[field];
        }
    }
    if (has(node, "loc")) {
        if (withoutLoc) newNode.loc = null;
        else newNode.loc = node.loc;
    }
    if (has(node, "leadingComments")) newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
    if (has(node, "innerComments")) newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
    if (has(node, "trailingComments")) newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
    if (has(node, "extra")) newNode.extra = Object.assign({}, node.extra);
    return newNode;
}
function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
    if (!comments || !deep) return comments;
    return comments.map((comment)=>{
        const cache = commentsCache.get(comment);
        if (cache) return cache;
        const { type , value , loc  } = comment;
        const ret = {
            type,
            value,
            loc
        };
        if (withoutLoc) ret.loc = null;
        commentsCache.set(comment, ret);
        return ret;
    });
}

},{"487a3e1b5654886e":"32frq","3f92ff028c1c9cd9":"lrUKn"}],"fR7E2":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = clone;
var _cloneNode = require("8d8d313f6d912b3f");
function clone(node) {
    return (0, _cloneNode.default)(node, false);
}

},{"8d8d313f6d912b3f":"dSpB5"}],"hCb55":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneDeep;
var _cloneNode = require("fedf1ca0b78fc8a");
function cloneDeep(node) {
    return (0, _cloneNode.default)(node);
}

},{"fedf1ca0b78fc8a":"dSpB5"}],"4fIeZ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneDeepWithoutLoc;
var _cloneNode = require("1b7b83c865c3f9fe");
function cloneDeepWithoutLoc(node) {
    return (0, _cloneNode.default)(node, true, true);
}

},{"1b7b83c865c3f9fe":"dSpB5"}],"f2GBU":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneWithoutLoc;
var _cloneNode = require("2b933aa48548befc");
function cloneWithoutLoc(node) {
    return (0, _cloneNode.default)(node, false, true);
}

},{"2b933aa48548befc":"dSpB5"}],"feFUq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addComment;
var _addComments = require("3ba6f40da8b0d272");
function addComment(node, type, content, line) {
    return (0, _addComments.default)(node, type, [
        {
            type: line ? "CommentLine" : "CommentBlock",
            value: content
        }
    ]);
}

},{"3ba6f40da8b0d272":"hkQTK"}],"hkQTK":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addComments;
function addComments(node, type, comments) {
    if (!comments || !node) return node;
    const key = `${type}Comments`;
    if (node[key]) {
        if (type === "leading") node[key] = comments.concat(node[key]);
        else node[key].push(...comments);
    } else node[key] = comments;
    return node;
}

},{}],"9uTML":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritInnerComments;
var _inherit = require("cf973d0e0349f73c");
function inheritInnerComments(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
}

},{"cf973d0e0349f73c":"evWbl"}],"evWbl":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inherit;
function inherit(key, child, parent) {
    if (child && parent) child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
}

},{}],"6bm0A":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritLeadingComments;
var _inherit = require("10fde9818d90d617");
function inheritLeadingComments(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
}

},{"10fde9818d90d617":"evWbl"}],"2fk6o":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritsComments;
var _inheritTrailingComments = require("75818285727bce51");
var _inheritLeadingComments = require("959ebde63184ecd8");
var _inheritInnerComments = require("7113b7406d7ae8f6");
function inheritsComments(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
}

},{"75818285727bce51":"7p2Q8","959ebde63184ecd8":"6bm0A","7113b7406d7ae8f6":"9uTML"}],"7p2Q8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritTrailingComments;
var _inherit = require("8def01f180432614");
function inheritTrailingComments(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
}

},{"8def01f180432614":"evWbl"}],"ld5OA":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeComments;
var _constants = require("4194a1cc47ea04");
function removeComments(node) {
    _constants.COMMENT_KEYS.forEach((key)=>{
        node[key] = null;
    });
    return node;
}

},{"4194a1cc47ea04":"dHy0S"}],"4shEB":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
var _definitions = require("b873fb9608cfeb7a");
const STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Standardized"];
exports.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
exports.BINARY_TYPES = BINARY_TYPES;
const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
exports.BLOCK_TYPES = BLOCK_TYPES;
const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
exports.STATEMENT_TYPES = STATEMENT_TYPES;
const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
exports.LOOP_TYPES = LOOP_TYPES;
const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
exports.WHILE_TYPES = WHILE_TYPES;
const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
exports.FOR_TYPES = FOR_TYPES;
const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
exports.FUNCTION_TYPES = FUNCTION_TYPES;
const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
exports.PUREISH_TYPES = PUREISH_TYPES;
const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
exports.DECLARATION_TYPES = DECLARATION_TYPES;
const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
exports.LVAL_TYPES = LVAL_TYPES;
const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
exports.LITERAL_TYPES = LITERAL_TYPES;
const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
exports.METHOD_TYPES = METHOD_TYPES;
const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
exports.PROPERTY_TYPES = PROPERTY_TYPES;
const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
exports.PATTERN_TYPES = PATTERN_TYPES;
const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
exports.CLASS_TYPES = CLASS_TYPES;
const IMPORTOREXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
exports.IMPORTOREXPORTDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
const ACCESSOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Accessor"];
exports.ACCESSOR_TYPES = ACCESSOR_TYPES;
const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
exports.PRIVATE_TYPES = PRIVATE_TYPES;
const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
exports.FLOW_TYPES = FLOW_TYPES;
const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
exports.JSX_TYPES = JSX_TYPES;
const MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Miscellaneous"];
exports.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
const TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TypeScript"];
exports.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
exports.TSTYPE_TYPES = TSTYPE_TYPES;
const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
const MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;

},{"b873fb9608cfeb7a":"32frq"}],"fsDMl":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ensureBlock;
var _toBlock = require("29399f35a95f3085");
function ensureBlock(node, key = "body") {
    const result = (0, _toBlock.default)(node[key], node);
    node[key] = result;
    return result;
}

},{"29399f35a95f3085":"7jRMp"}],"7jRMp":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toBlock;
var _generated = require("bf8cdde861eadcb");
var _generated2 = require("c27b89c3fef8174b");
function toBlock(node, parent) {
    if ((0, _generated.isBlockStatement)(node)) return node;
    let blockNodes = [];
    if ((0, _generated.isEmptyStatement)(node)) blockNodes = [];
    else {
        if (!(0, _generated.isStatement)(node)) {
            if ((0, _generated.isFunction)(parent)) node = (0, _generated2.returnStatement)(node);
            else node = (0, _generated2.expressionStatement)(node);
        }
        blockNodes = [
            node
        ];
    }
    return (0, _generated2.blockStatement)(blockNodes);
}

},{"bf8cdde861eadcb":"lrUKn","c27b89c3fef8174b":"fvX9A"}],"hoi4j":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toBindingIdentifierName;
var _toIdentifier = require("6ea4f08193bc4db");
function toBindingIdentifierName(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
}

},{"6ea4f08193bc4db":"bZr91"}],"bZr91":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toIdentifier;
var _isValidIdentifier = require("124764d8294b0200");
var _helperValidatorIdentifier = require("79cb80db32b7cfa0");
function toIdentifier(input) {
    input = input + "";
    let name = "";
    for (const c of input)name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier.default)(name)) name = `_${name}`;
    return name || "_";
}

},{"124764d8294b0200":"co3Ir","79cb80db32b7cfa0":"jsf1q"}],"9A3PE":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toComputedKey;
var _generated = require("826b60efec6eac59");
var _generated2 = require("c7561b0bcdd2620a");
function toComputedKey(node, key = node.key || node.property) {
    if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
    return key;
}

},{"826b60efec6eac59":"lrUKn","c7561b0bcdd2620a":"fvX9A"}],"j2Ei2":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("6775d6b9bf40ac3");
var _default = toExpression;
exports.default = _default;
function toExpression(node) {
    if ((0, _generated.isExpressionStatement)(node)) node = node.expression;
    if ((0, _generated.isExpression)(node)) return node;
    if ((0, _generated.isClass)(node)) node.type = "ClassExpression";
    else if ((0, _generated.isFunction)(node)) node.type = "FunctionExpression";
    if (!(0, _generated.isExpression)(node)) throw new Error(`cannot turn ${node.type} to an expression`);
    return node;
}

},{"6775d6b9bf40ac3":"lrUKn"}],"2mp3d":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toKeyAlias;
var _generated = require("6b9bda55831ec429");
var _cloneNode = require("9a90f01e58be67ce");
var _removePropertiesDeep = require("46cd254937bdf4e8");
function toKeyAlias(node, key = node.key) {
    let alias;
    if (node.kind === "method") return toKeyAlias.increment() + "";
    else if ((0, _generated.isIdentifier)(key)) alias = key.name;
    else if ((0, _generated.isStringLiteral)(key)) alias = JSON.stringify(key.value);
    else alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
    if (node.computed) alias = `[${alias}]`;
    if (node.static) alias = `static:${alias}`;
    return alias;
}
toKeyAlias.uid = 0;
toKeyAlias.increment = function() {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) return toKeyAlias.uid = 0;
    else return toKeyAlias.uid++;
};

},{"6b9bda55831ec429":"lrUKn","9a90f01e58be67ce":"dSpB5","46cd254937bdf4e8":"6an75"}],"6an75":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removePropertiesDeep;
var _traverseFast = require("4bcd6b3a65931845");
var _removeProperties = require("de05720b885a6b33");
function removePropertiesDeep(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
}

},{"4bcd6b3a65931845":"1xVK0","de05720b885a6b33":"9jgoG"}],"1xVK0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = traverseFast;
var _definitions = require("4cb02e31f3149028");
function traverseFast(node, enter, opts) {
    if (!node) return;
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {};
    enter(node, opts);
    for (const key of keys){
        const subNode = node[key];
        if (Array.isArray(subNode)) for (const node of subNode)traverseFast(node, enter, opts);
        else traverseFast(subNode, enter, opts);
    }
}

},{"4cb02e31f3149028":"32frq"}],"9jgoG":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeProperties;
var _constants = require("37c1dda4cb708190");
const CLEAR_KEYS = [
    "tokens",
    "start",
    "end",
    "loc",
    "raw",
    "rawValue"
];
const CLEAR_KEYS_PLUS_COMMENTS = [
    ..._constants.COMMENT_KEYS,
    "comments",
    ...CLEAR_KEYS
];
function removeProperties(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map)if (node[key] != null) node[key] = undefined;
    for (const key of Object.keys(node))if (key[0] === "_" && node[key] != null) node[key] = undefined;
    const symbols = Object.getOwnPropertySymbols(node);
    for (const sym of symbols)node[sym] = null;
}

},{"37c1dda4cb708190":"dHy0S"}],"dQ3Xe":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toSequenceExpression;
var _gatherSequenceExpressions = require("fbe004858b576d1");
function toSequenceExpression(nodes, scope) {
    if (!(nodes != null && nodes.length)) return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
    if (!result) return;
    for (const declar of declars)scope.push(declar);
    return result;
}

},{"fbe004858b576d1":"heOr0"}],"heOr0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = gatherSequenceExpressions;
var _getBindingIdentifiers = require("fb0b2ee72093836c");
var _generated = require("aed33f883983e167");
var _generated2 = require("d1715b85cf7dfb43");
var _cloneNode = require("80e9c9dfcd29b59f");
function gatherSequenceExpressions(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node of nodes){
        if (!(0, _generated.isEmptyStatement)(node)) ensureLastUndefined = false;
        if ((0, _generated.isExpression)(node)) exprs.push(node);
        else if ((0, _generated.isExpressionStatement)(node)) exprs.push(node.expression);
        else if ((0, _generated.isVariableDeclaration)(node)) {
            if (node.kind !== "var") return;
            for (const declar of node.declarations){
                const bindings = (0, _getBindingIdentifiers.default)(declar);
                for (const key of Object.keys(bindings))declars.push({
                    kind: node.kind,
                    id: (0, _cloneNode.default)(bindings[key])
                });
                if (declar.init) exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
            }
            ensureLastUndefined = true;
        } else if ((0, _generated.isIfStatement)(node)) {
            const consequent = node.consequent ? gatherSequenceExpressions([
                node.consequent
            ], scope, declars) : scope.buildUndefinedNode();
            const alternate = node.alternate ? gatherSequenceExpressions([
                node.alternate
            ], scope, declars) : scope.buildUndefinedNode();
            if (!consequent || !alternate) return;
            exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _generated.isBlockStatement)(node)) {
            const body = gatherSequenceExpressions(node.body, scope, declars);
            if (!body) return;
            exprs.push(body);
        } else if ((0, _generated.isEmptyStatement)(node)) {
            if (nodes.indexOf(node) === 0) ensureLastUndefined = true;
        } else return;
    }
    if (ensureLastUndefined) exprs.push(scope.buildUndefinedNode());
    if (exprs.length === 1) return exprs[0];
    else return (0, _generated2.sequenceExpression)(exprs);
}

},{"fb0b2ee72093836c":"jZjJ0","aed33f883983e167":"lrUKn","d1715b85cf7dfb43":"fvX9A","80e9c9dfcd29b59f":"dSpB5"}],"jZjJ0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getBindingIdentifiers;
var _generated = require("89a86808f50f873f");
function getBindingIdentifiers(node, duplicates, outerOnly) {
    const search = [].concat(node);
    const ids = Object.create(null);
    while(search.length){
        const id = search.shift();
        if (!id) continue;
        const keys = getBindingIdentifiers.keys[id.type];
        if ((0, _generated.isIdentifier)(id)) {
            if (duplicates) {
                const _ids = ids[id.name] = ids[id.name] || [];
                _ids.push(id);
            } else ids[id.name] = id;
            continue;
        }
        if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {
            if ((0, _generated.isDeclaration)(id.declaration)) search.push(id.declaration);
            continue;
        }
        if (outerOnly) {
            if ((0, _generated.isFunctionDeclaration)(id)) {
                search.push(id.id);
                continue;
            }
            if ((0, _generated.isFunctionExpression)(id)) continue;
        }
        if (keys) for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            const nodes = id[key];
            if (nodes) Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
        }
    }
    return ids;
}
getBindingIdentifiers.keys = {
    DeclareClass: [
        "id"
    ],
    DeclareFunction: [
        "id"
    ],
    DeclareModule: [
        "id"
    ],
    DeclareVariable: [
        "id"
    ],
    DeclareInterface: [
        "id"
    ],
    DeclareTypeAlias: [
        "id"
    ],
    DeclareOpaqueType: [
        "id"
    ],
    InterfaceDeclaration: [
        "id"
    ],
    TypeAlias: [
        "id"
    ],
    OpaqueType: [
        "id"
    ],
    CatchClause: [
        "param"
    ],
    LabeledStatement: [
        "label"
    ],
    UnaryExpression: [
        "argument"
    ],
    AssignmentExpression: [
        "left"
    ],
    ImportSpecifier: [
        "local"
    ],
    ImportNamespaceSpecifier: [
        "local"
    ],
    ImportDefaultSpecifier: [
        "local"
    ],
    ImportDeclaration: [
        "specifiers"
    ],
    ExportSpecifier: [
        "exported"
    ],
    ExportNamespaceSpecifier: [
        "exported"
    ],
    ExportDefaultSpecifier: [
        "exported"
    ],
    FunctionDeclaration: [
        "id",
        "params"
    ],
    FunctionExpression: [
        "id",
        "params"
    ],
    ArrowFunctionExpression: [
        "params"
    ],
    ObjectMethod: [
        "params"
    ],
    ClassMethod: [
        "params"
    ],
    ClassPrivateMethod: [
        "params"
    ],
    ForInStatement: [
        "left"
    ],
    ForOfStatement: [
        "left"
    ],
    ClassDeclaration: [
        "id"
    ],
    ClassExpression: [
        "id"
    ],
    RestElement: [
        "argument"
    ],
    UpdateExpression: [
        "argument"
    ],
    ObjectProperty: [
        "value"
    ],
    AssignmentPattern: [
        "left"
    ],
    ArrayPattern: [
        "elements"
    ],
    ObjectPattern: [
        "properties"
    ],
    VariableDeclaration: [
        "declarations"
    ],
    VariableDeclarator: [
        "id"
    ]
};

},{"89a86808f50f873f":"lrUKn"}],"bdr8R":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("a7359e856892d38b");
var _generated2 = require("18dbbc47c1699a78");
var _default = toStatement;
exports.default = _default;
function toStatement(node, ignore) {
    if ((0, _generated.isStatement)(node)) return node;
    let mustHaveId = false;
    let newType;
    if ((0, _generated.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
    } else if ((0, _generated.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
    } else if ((0, _generated.isAssignmentExpression)(node)) return (0, _generated2.expressionStatement)(node);
    if (mustHaveId && !node.id) newType = false;
    if (!newType) {
        if (ignore) return false;
        else throw new Error(`cannot turn ${node.type} to a statement`);
    }
    node.type = newType;
    return node;
}

},{"a7359e856892d38b":"lrUKn","18dbbc47c1699a78":"fvX9A"}],"7nKLb":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _isValidIdentifier = require("6d7c19080ff2ec26");
var _generated = require("8666c0d7d754b294");
var _default = valueToNode;
exports.default = _default;
const objectToString = Function.call.bind(Object.prototype.toString);
function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
}
function isPlainObject(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") return false;
    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
}
function valueToNode(value) {
    if (value === undefined) return (0, _generated.identifier)("undefined");
    if (value === true || value === false) return (0, _generated.booleanLiteral)(value);
    if (value === null) return (0, _generated.nullLiteral)();
    if (typeof value === "string") return (0, _generated.stringLiteral)(value);
    if (typeof value === "number") {
        let result;
        if (Number.isFinite(value)) result = (0, _generated.numericLiteral)(Math.abs(value));
        else {
            let numerator;
            if (Number.isNaN(value)) numerator = (0, _generated.numericLiteral)(0);
            else numerator = (0, _generated.numericLiteral)(1);
            result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
        }
        if (value < 0 || Object.is(value, -0)) result = (0, _generated.unaryExpression)("-", result);
        return result;
    }
    if (isRegExp(value)) {
        const pattern = value.source;
        const flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return (0, _generated.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) return (0, _generated.arrayExpression)(value.map(valueToNode));
    if (isPlainObject(value)) {
        const props = [];
        for (const key of Object.keys(value)){
            let nodeKey;
            if ((0, _isValidIdentifier.default)(key)) nodeKey = (0, _generated.identifier)(key);
            else nodeKey = (0, _generated.stringLiteral)(key);
            props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
        }
        return (0, _generated.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
}

},{"6d7c19080ff2ec26":"co3Ir","8666c0d7d754b294":"fvX9A"}],"3EoGP":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = appendToMemberExpression;
var _generated = require("2e033cf7e8fd7807");
function appendToMemberExpression(member, append, computed = false) {
    member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
}

},{"2e033cf7e8fd7807":"fvX9A"}],"c0pUW":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inherits;
var _constants = require("670493c490d83e0d");
var _inheritsComments = require("71d4b1739e57cfa6");
function inherits(child, parent) {
    if (!child || !parent) return child;
    for (const key of _constants.INHERIT_KEYS.optional)if (child[key] == null) child[key] = parent[key];
    for (const key of Object.keys(parent))if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
    for (const key of _constants.INHERIT_KEYS.force)child[key] = parent[key];
    (0, _inheritsComments.default)(child, parent);
    return child;
}

},{"670493c490d83e0d":"dHy0S","71d4b1739e57cfa6":"2fk6o"}],"gltcL":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = prependToMemberExpression;
var _generated = require("8dda8273ab0f222a");
var _ = require("b01a9f673ad1c4e9");
function prependToMemberExpression(member, prepend) {
    if ((0, _.isSuper)(member.object)) throw new Error("Cannot prepend node to super property access (`super.foo`).");
    member.object = (0, _generated.memberExpression)(prepend, member.object);
    return member;
}

},{"8dda8273ab0f222a":"fvX9A","b01a9f673ad1c4e9":"hnm3y"}],"bIpkE":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _getBindingIdentifiers = require("395d5ca30b83b8fa");
var _default = getOuterBindingIdentifiers;
exports.default = _default;
function getOuterBindingIdentifiers(node, duplicates) {
    return (0, _getBindingIdentifiers.default)(node, duplicates, true);
}

},{"395d5ca30b83b8fa":"jZjJ0"}],"fgXi5":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = traverse;
var _definitions = require("6b7ced0af293d5a5");
function traverse(node, handlers, state) {
    if (typeof handlers === "function") handlers = {
        enter: handlers
    };
    const { enter , exit  } = handlers;
    traverseSimpleImpl(node, enter, exit, state, []);
}
function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);
    for (const key of keys){
        const subNode = node[key];
        if (Array.isArray(subNode)) for(let i = 0; i < subNode.length; i++){
            const child = subNode[i];
            if (!child) continue;
            ancestors.push({
                node,
                key,
                index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
        }
        else if (subNode) {
            ancestors.push({
                node,
                key
            });
            traverseSimpleImpl(subNode, enter, exit, state, ancestors);
            ancestors.pop();
        }
    }
    if (exit) exit(node, ancestors, state);
}

},{"6b7ced0af293d5a5":"32frq"}],"fYWFw":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isBinding;
var _getBindingIdentifiers = require("183efe8266867ec5");
function isBinding(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") return false;
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        const val = parent[key];
        if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0) return true;
        } else {
            if (val === node) return true;
        }
    }
    return false;
}

},{"183efe8266867ec5":"jZjJ0"}],"bwozb":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isBlockScoped;
var _generated = require("6ed0ce8f7ed0e1d0");
var _isLet = require("723f27aaeef67584");
function isBlockScoped(node) {
    return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
}

},{"6ed0ce8f7ed0e1d0":"lrUKn","723f27aaeef67584":"9OjDp"}],"9OjDp":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isLet;
var _generated = require("71129a790feed41b");
var _constants = require("8db4c81b56b1705e");
function isLet(node) {
    return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}

},{"71129a790feed41b":"lrUKn","8db4c81b56b1705e":"dHy0S"}],"3MWUv":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isImmutable;
var _isType = require("5f61cc38d32f8b05");
var _generated = require("101cd2a028d7ca97");
function isImmutable(node) {
    if ((0, _isType.default)(node.type, "Immutable")) return true;
    if ((0, _generated.isIdentifier)(node)) {
        if (node.name === "undefined") return true;
        else return false;
    }
    return false;
}

},{"5f61cc38d32f8b05":"8A4sW","101cd2a028d7ca97":"lrUKn"}],"btgKJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isNodesEquivalent;
var _definitions = require("219829eb5695aff6");
function isNodesEquivalent(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) return a === b;
    if (a.type !== b.type) return false;
    const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = _definitions.VISITOR_KEYS[a.type];
    for (const field of fields){
        const val_a = a[field];
        const val_b = b[field];
        if (typeof val_a !== typeof val_b) return false;
        if (val_a == null && val_b == null) continue;
        else if (val_a == null || val_b == null) return false;
        if (Array.isArray(val_a)) {
            if (!Array.isArray(val_b)) return false;
            if (val_a.length !== val_b.length) return false;
            for(let i = 0; i < val_a.length; i++){
                if (!isNodesEquivalent(val_a[i], val_b[i])) return false;
            }
            continue;
        }
        if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
            for (const key of Object.keys(val_a)){
                if (val_a[key] !== val_b[key]) return false;
            }
            continue;
        }
        if (!isNodesEquivalent(val_a, val_b)) return false;
    }
    return true;
}

},{"219829eb5695aff6":"32frq"}],"ic2HW":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isReferenced;
function isReferenced(node, parent, grandparent) {
    switch(parent.type){
        case "MemberExpression":
        case "OptionalMemberExpression":
            if (parent.property === node) return !!parent.computed;
            return parent.object === node;
        case "JSXMemberExpression":
            return parent.object === node;
        case "VariableDeclarator":
            return parent.init === node;
        case "ArrowFunctionExpression":
            return parent.body === node;
        case "PrivateName":
            return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
            if (parent.key === node) return !!parent.computed;
            return false;
        case "ObjectProperty":
            if (parent.key === node) return !!parent.computed;
            return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
            if (parent.key === node) return !!parent.computed;
            return true;
        case "ClassPrivateProperty":
            return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
            return parent.superClass === node;
        case "AssignmentExpression":
            return parent.right === node;
        case "AssignmentPattern":
            return parent.right === node;
        case "LabeledStatement":
            return false;
        case "CatchClause":
            return false;
        case "RestElement":
            return false;
        case "BreakStatement":
        case "ContinueStatement":
            return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
            return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
            return false;
        case "ExportSpecifier":
            if (grandparent != null && grandparent.source) return false;
            return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
            return false;
        case "ImportAttribute":
            return false;
        case "JSXAttribute":
            return false;
        case "ObjectPattern":
        case "ArrayPattern":
            return false;
        case "MetaProperty":
            return false;
        case "ObjectTypeProperty":
            return parent.key !== node;
        case "TSEnumMember":
            return parent.id !== node;
        case "TSPropertySignature":
            if (parent.key === node) return !!parent.computed;
            return true;
    }
    return true;
}

},{}],"ddb3V":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isScope;
var _generated = require("b81f145d9a558c68");
function isScope(node, parent) {
    if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) return false;
    if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) return true;
    return (0, _generated.isScopable)(node);
}

},{"b81f145d9a558c68":"lrUKn"}],"gQ4Hx":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isSpecifierDefault;
var _generated = require("2e1cc28dd14ae82b");
function isSpecifierDefault(specifier) {
    return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
    });
}

},{"2e1cc28dd14ae82b":"lrUKn"}],"iyBPq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isValidES3Identifier;
var _isValidIdentifier = require("f8cdb20e9565334b");
const RESERVED_WORDS_ES3_ONLY = new Set([
    "abstract",
    "boolean",
    "byte",
    "char",
    "double",
    "enum",
    "final",
    "float",
    "goto",
    "implements",
    "int",
    "interface",
    "long",
    "native",
    "package",
    "private",
    "protected",
    "public",
    "short",
    "static",
    "synchronized",
    "throws",
    "transient",
    "volatile"
]);
function isValidES3Identifier(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}

},{"f8cdb20e9565334b":"co3Ir"}],"2trSd":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isVar;
var _generated = require("f8d7e3ea39e128");
var _constants = require("952c1ccc020cc940");
function isVar(node) {
    return (0, _generated.isVariableDeclaration)(node, {
        kind: "var"
    }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}

},{"f8d7e3ea39e128":"lrUKn","952c1ccc020cc940":"dHy0S"}],"j9YRY":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
function binaryOperation(operator, left, right) {
    switch(operator){
        case "+":
            return left + right;
        case "-":
            return left - right;
        case "/":
            return left / right;
        case "%":
            return left % right;
        case "*":
            return left * right;
        case "**":
            return Math.pow(left, right);
        case "&":
            return left & right;
        case "|":
            return left | right;
        case ">>":
            return left >> right;
        case ">>>":
            return left >>> right;
        case "<<":
            return left << right;
        case "^":
            return left ^ right;
        case "==":
            return left == right;
        case "===":
            return left === right;
        case "!=":
            return left != right;
        case "!==":
            return left !== right;
        case "in":
            return left in right;
        case "instanceof":
            return left instanceof right;
        case ">":
            return left > right;
        case "<":
            return left < right;
        case ">=":
            return left >= right;
        case "<=":
            return left <= right;
    }
}
exports["default"] = binaryOperation;

},{}],"74FvY":[function(require,module,exports) {
"use strict";
var assert = require("10cb011dac5f935d");
var walk = require("b9259139cfba97be");
function error() {
    throw require("b2e3c09db4ddab1e").apply(null, arguments);
}
module.exports = link;
function link(ast) {
    assert(ast.type === "Block", "The top level element should always be a block");
    var extendsNode = null;
    if (ast.nodes.length) {
        var hasExtends = ast.nodes[0].type === "Extends";
        checkExtendPosition(ast, hasExtends);
        if (hasExtends) extendsNode = ast.nodes.shift();
    }
    ast = applyIncludes(ast);
    ast.declaredBlocks = findDeclaredBlocks(ast);
    if (extendsNode) {
        var mixins = [];
        var expectedBlocks = [];
        ast.nodes.forEach(function addNode(node) {
            if (node.type === "NamedBlock") expectedBlocks.push(node);
            else if (node.type === "Block") node.nodes.forEach(addNode);
            else if (node.type === "Mixin" && node.call === false) mixins.push(node);
            else error("UNEXPECTED_NODES_IN_EXTENDING_ROOT", "Only named blocks and mixins can appear at the top level of an extending template", node);
        });
        var parent = link(extendsNode.file.ast);
        extend(parent.declaredBlocks, ast);
        var foundBlockNames = [];
        walk(parent, function(node) {
            if (node.type === "NamedBlock") foundBlockNames.push(node.name);
        });
        expectedBlocks.forEach(function(expectedBlock) {
            if (foundBlockNames.indexOf(expectedBlock.name) === -1) error("UNEXPECTED_BLOCK", "Unexpected block " + expectedBlock.name, expectedBlock);
        });
        Object.keys(ast.declaredBlocks).forEach(function(name) {
            parent.declaredBlocks[name] = ast.declaredBlocks[name];
        });
        parent.nodes = mixins.concat(parent.nodes);
        parent.hasExtends = true;
        return parent;
    }
    return ast;
}
function findDeclaredBlocks(ast) /*: {[name: string]: Array<BlockNode>}*/ {
    var definitions = {};
    walk(ast, function before(node) {
        if (node.type === "NamedBlock" && node.mode === "replace") {
            definitions[node.name] = definitions[node.name] || [];
            definitions[node.name].push(node);
        }
    });
    return definitions;
}
function flattenParentBlocks(parentBlocks, accumulator) {
    accumulator = accumulator || [];
    parentBlocks.forEach(function(parentBlock) {
        if (parentBlock.parents) flattenParentBlocks(parentBlock.parents, accumulator);
        accumulator.push(parentBlock);
    });
    return accumulator;
}
function extend(parentBlocks, ast) {
    var stack = {};
    walk(ast, function before(node) {
        if (node.type === "NamedBlock") {
            if (stack[node.name] === node.name) return node.ignore = true;
            stack[node.name] = node.name;
            var parentBlockList = parentBlocks[node.name] ? flattenParentBlocks(parentBlocks[node.name]) : [];
            if (parentBlockList.length) {
                node.parents = parentBlockList;
                parentBlockList.forEach(function(parentBlock) {
                    switch(node.mode){
                        case "append":
                            parentBlock.nodes = parentBlock.nodes.concat(node.nodes);
                            break;
                        case "prepend":
                            parentBlock.nodes = node.nodes.concat(parentBlock.nodes);
                            break;
                        case "replace":
                            parentBlock.nodes = node.nodes;
                            break;
                    }
                });
            }
        }
    }, function after(node) {
        if (node.type === "NamedBlock" && !node.ignore) delete stack[node.name];
    });
}
function applyIncludes(ast, child) {
    return walk(ast, function before(node, replace) {
        if (node.type === "RawInclude") replace({
            type: "Text",
            val: node.file.str.replace(/\r/g, "")
        });
    }, function after(node, replace) {
        if (node.type === "Include") {
            var childAST = link(node.file.ast);
            if (childAST.hasExtends) childAST = removeBlocks(childAST);
            replace(applyYield(childAST, node.block));
        }
    });
}
function removeBlocks(ast) {
    return walk(ast, function(node, replace) {
        if (node.type === "NamedBlock") replace({
            type: "Block",
            nodes: node.nodes
        });
    });
}
function applyYield(ast, block) {
    if (!block || !block.nodes.length) return ast;
    var replaced = false;
    ast = walk(ast, null, function(node, replace) {
        if (node.type === "YieldBlock") {
            replaced = true;
            node.type = "Block";
            node.nodes = [
                block
            ];
        }
    });
    function defaultYieldLocation(node) {
        var res = node;
        for(var i = 0; i < node.nodes.length; i++){
            if (node.nodes[i].textOnly) continue;
            if (node.nodes[i].type === "Block") res = defaultYieldLocation(node.nodes[i]);
            else if (node.nodes[i].block && node.nodes[i].block.nodes.length) res = defaultYieldLocation(node.nodes[i].block);
        }
        return res;
    }
    if (!replaced) // todo: probably should deprecate this with a warning
    defaultYieldLocation(ast).nodes.push(block);
    return ast;
}
function checkExtendPosition(ast, hasExtends) {
    var legitExtendsReached = false;
    walk(ast, function(node) {
        if (node.type === "Extends") {
            if (hasExtends && !legitExtendsReached) legitExtendsReached = true;
            else error("EXTENDS_NOT_FIRST", 'Declaration of template inheritance ("extends") should be the first thing in the file. There can only be one extends statement per file.', node);
        }
    });
}

},{"10cb011dac5f935d":"f3tT4","b9259139cfba97be":"kOecN","b2e3c09db4ddab1e":"khglH"}],"ksxv5":[function(require,module,exports) {
"use strict";
var doctypes = require("fb2aed682ecd5f7d");
var makeError = require("c99f50b798f53803");
var buildRuntime = require("1b792f8caadde923");
var runtime = require("b32352d4cca237e");
var compileAttrs = require("470934a14ec1ca1f");
var selfClosing = require("57231fecc6b1d3a2");
var constantinople = require("4c4e15e6aeda5aa5");
var stringify = require("63421ee0b9bbacd0");
var addWith = require("b9b6f31a930e1607");
// This is used to prevent pretty printing inside certain tags
var WHITE_SPACE_SENSITIVE_TAGS = {
    pre: true,
    textarea: true
};
var INTERNAL_VARIABLES = [
    "pug",
    "pug_mixins",
    "pug_interp",
    "pug_debug_filename",
    "pug_debug_line",
    "pug_debug_sources",
    "pug_html"
];
module.exports = generateCode;
module.exports.CodeGenerator = Compiler;
function generateCode(ast, options) {
    return new Compiler(ast, options).compile();
}
function isConstant(src) {
    return constantinople(src, {
        pug: runtime,
        pug_interp: undefined
    });
}
function toConstant(src) {
    return constantinople.toConstant(src, {
        pug: runtime,
        pug_interp: undefined
    });
}
/**
 * Initialize `Compiler` with the given `node`.
 *
 * @param {Node} node
 * @param {Object} options
 * @api public
 */ function Compiler(node, options) {
    this.options = options = options || {};
    this.node = node;
    this.bufferedConcatenationCount = 0;
    this.hasCompiledDoctype = false;
    this.hasCompiledTag = false;
    this.pp = options.pretty || false;
    if (this.pp && typeof this.pp !== "string") this.pp = "  ";
    if (this.pp && !/^\s+$/.test(this.pp)) throw new Error("The pretty parameter should either be a boolean or whitespace only string");
    this.debug = false !== options.compileDebug;
    this.indents = 0;
    this.parentIndents = 0;
    this.terse = false;
    this.mixins = {};
    this.dynamicMixins = false;
    this.eachCount = 0;
    if (options.doctype) this.setDoctype(options.doctype);
    this.runtimeFunctionsUsed = [];
    this.inlineRuntimeFunctions = options.inlineRuntimeFunctions || false;
    if (this.debug && this.inlineRuntimeFunctions) this.runtimeFunctionsUsed.push("rethrow");
}
/**
 * Compiler prototype.
 */ Compiler.prototype = {
    runtime: function(name) {
        if (this.inlineRuntimeFunctions) {
            this.runtimeFunctionsUsed.push(name);
            return "pug_" + name;
        } else return "pug." + name;
    },
    error: function(message, code, node) {
        var err = makeError(code, message, {
            line: node.line,
            column: node.column,
            filename: node.filename
        });
        throw err;
    },
    /**
   * Compile parse tree to JavaScript.
   *
   * @api public
   */ compile: function() {
        this.buf = [];
        if (this.pp) this.buf.push("var pug_indent = [];");
        this.lastBufferedIdx = -1;
        this.visit(this.node);
        if (!this.dynamicMixins) {
            // if there are no dynamic mixins we can remove any un-used mixins
            var mixinNames = Object.keys(this.mixins);
            for(var i = 0; i < mixinNames.length; i++){
                var mixin = this.mixins[mixinNames[i]];
                if (!mixin.used) {
                    for(var x = 0; x < mixin.instances.length; x++)for(var y = mixin.instances[x].start; y < mixin.instances[x].end; y++)this.buf[y] = "";
                }
            }
        }
        var js = this.buf.join("\n");
        var globals = this.options.globals ? this.options.globals.concat(INTERNAL_VARIABLES) : INTERNAL_VARIABLES;
        if (this.options.self) js = "var self = locals || {};" + js;
        else js = addWith("locals || {}", js, globals.concat(this.runtimeFunctionsUsed.map(function(name) {
            return "pug_" + name;
        })));
        if (this.debug) {
            if (this.options.includeSources) js = "var pug_debug_sources = " + stringify(this.options.includeSources) + ";\n" + js;
            js = "var pug_debug_filename, pug_debug_line;try {" + js + "} catch (err) {" + (this.inlineRuntimeFunctions ? "pug_rethrow" : "pug.rethrow") + "(err, pug_debug_filename, pug_debug_line" + (this.options.includeSources ? ", pug_debug_sources[pug_debug_filename]" : "") + ");" + "}";
        }
        return buildRuntime(this.runtimeFunctionsUsed) + "function " + (this.options.templateName || "template") + '(locals) {var pug_html = "", pug_mixins = {}, pug_interp;' + js + ";return pug_html;}";
    },
    /**
   * Sets the default doctype `name`. Sets terse mode to `true` when
   * html 5 is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {string} name
   * @api public
   */ setDoctype: function(name) {
        this.doctype = doctypes[name.toLowerCase()] || "<!DOCTYPE " + name + ">";
        this.terse = this.doctype.toLowerCase() == "<!doctype html>";
        this.xml = 0 == this.doctype.indexOf("<?xml");
    },
    /**
   * Buffer the given `str` exactly as is or with interpolation
   *
   * @param {String} str
   * @param {Boolean} interpolate
   * @api public
   */ buffer: function(str) {
        var self = this;
        str = stringify(str);
        str = str.substr(1, str.length - 2);
        if (this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100) {
            if (this.lastBufferedType === "code") {
                this.lastBuffered += ' + "';
                this.bufferedConcatenationCount++;
            }
            this.lastBufferedType = "text";
            this.lastBuffered += str;
            this.buf[this.lastBufferedIdx - 1] = "pug_html = pug_html + " + this.bufferStartChar + this.lastBuffered + '";';
        } else {
            this.bufferedConcatenationCount = 0;
            this.buf.push('pug_html = pug_html + "' + str + '";');
            this.lastBufferedType = "text";
            this.bufferStartChar = '"';
            this.lastBuffered = str;
            this.lastBufferedIdx = this.buf.length;
        }
    },
    /**
   * Buffer the given `src` so it is evaluated at run time
   *
   * @param {String} src
   * @api public
   */ bufferExpression: function(src) {
        if (isConstant(src)) return this.buffer(toConstant(src) + "");
        if (this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100) {
            this.bufferedConcatenationCount++;
            if (this.lastBufferedType === "text") this.lastBuffered += '"';
            this.lastBufferedType = "code";
            this.lastBuffered += " + (" + src + ")";
            this.buf[this.lastBufferedIdx - 1] = "pug_html = pug_html + (" + this.bufferStartChar + this.lastBuffered + ");";
        } else {
            this.bufferedConcatenationCount = 0;
            this.buf.push("pug_html = pug_html + (" + src + ");");
            this.lastBufferedType = "code";
            this.bufferStartChar = "";
            this.lastBuffered = "(" + src + ")";
            this.lastBufferedIdx = this.buf.length;
        }
    },
    /**
   * Buffer an indent based on the current `indent`
   * property and an additional `offset`.
   *
   * @param {Number} offset
   * @param {Boolean} newline
   * @api public
   */ prettyIndent: function(offset, newline) {
        offset = offset || 0;
        newline = newline ? "\n" : "";
        this.buffer(newline + Array(this.indents + offset).join(this.pp));
        if (this.parentIndents) this.buf.push('pug_html = pug_html + pug_indent.join("");');
    },
    /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */ visit: function(node, parent) {
        var debug = this.debug;
        if (!node) {
            var msg;
            if (parent) msg = "A child of " + parent.type + " (" + (parent.filename || "Pug") + ":" + parent.line + ")";
            else msg = "A top-level node";
            msg += " is " + node + ", expected a Pug AST Node.";
            throw new TypeError(msg);
        }
        if (debug && node.debug !== false && node.type !== "Block") {
            if (node.line) {
                var js = ";pug_debug_line = " + node.line;
                if (node.filename) js += ";pug_debug_filename = " + stringify(node.filename);
                this.buf.push(js + ";");
            }
        }
        if (!this["visit" + node.type]) {
            var msg;
            if (parent) msg = "A child of " + parent.type;
            else msg = "A top-level node";
            msg += " (" + (node.filename || "Pug") + ":" + node.line + ")" + " is of type " + node.type + "," + " which is not supported by pug-code-gen.";
            switch(node.type){
                case "Filter":
                    msg += " Please use pug-filters to preprocess this AST.";
                    break;
                case "Extends":
                case "Include":
                case "NamedBlock":
                case "FileReference":
                    msg += " Please use pug-linker to preprocess this AST.";
                    break;
            }
            throw new TypeError(msg);
        }
        this.visitNode(node);
    },
    /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */ visitNode: function(node) {
        return this["visit" + node.type](node);
    },
    /**
   * Visit case `node`.
   *
   * @param {Literal} node
   * @api public
   */ visitCase: function(node) {
        this.buf.push("switch (" + node.expr + "){");
        this.visit(node.block, node);
        this.buf.push("}");
    },
    /**
   * Visit when `node`.
   *
   * @param {Literal} node
   * @api public
   */ visitWhen: function(node) {
        if ("default" == node.expr) this.buf.push("default:");
        else this.buf.push("case " + node.expr + ":");
        if (node.block) {
            this.visit(node.block, node);
            this.buf.push("  break;");
        }
    },
    /**
   * Visit literal `node`.
   *
   * @param {Literal} node
   * @api public
   */ visitLiteral: function(node) {
        this.buffer(node.str);
    },
    visitNamedBlock: function(block) {
        return this.visitBlock(block);
    },
    /**
   * Visit all nodes in `block`.
   *
   * @param {Block} block
   * @api public
   */ visitBlock: function(block) {
        var escapePrettyMode = this.escapePrettyMode;
        var pp = this.pp;
        // Pretty print multi-line text
        if (pp && block.nodes.length > 1 && !escapePrettyMode && block.nodes[0].type === "Text" && block.nodes[1].type === "Text") this.prettyIndent(1, true);
        for(var i = 0; i < block.nodes.length; ++i){
            // Pretty print text
            if (pp && i > 0 && !escapePrettyMode && block.nodes[i].type === "Text" && block.nodes[i - 1].type === "Text" && /\n$/.test(block.nodes[i - 1].val)) this.prettyIndent(1, false);
            this.visit(block.nodes[i], block);
        }
    },
    /**
   * Visit a mixin's `block` keyword.
   *
   * @param {MixinBlock} block
   * @api public
   */ visitMixinBlock: function(block) {
        if (this.pp) this.buf.push("pug_indent.push(" + stringify(Array(this.indents + 1).join(this.pp)) + ");");
        this.buf.push("block && block();");
        if (this.pp) this.buf.push("pug_indent.pop();");
    },
    /**
   * Visit `doctype`. Sets terse mode to `true` when html 5
   * is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {Doctype} doctype
   * @api public
   */ visitDoctype: function(doctype) {
        if (doctype && (doctype.val || !this.doctype)) this.setDoctype(doctype.val || "html");
        if (this.doctype) this.buffer(this.doctype);
        this.hasCompiledDoctype = true;
    },
    /**
   * Visit `mixin`, generating a function that
   * may be called within the template.
   *
   * @param {Mixin} mixin
   * @api public
   */ visitMixin: function(mixin) {
        var name = "pug_mixins[";
        var args = mixin.args || "";
        var block = mixin.block;
        var attrs = mixin.attrs;
        var attrsBlocks = this.attributeBlocks(mixin.attributeBlocks);
        var pp = this.pp;
        var dynamic = mixin.name[0] === "#";
        var key = mixin.name;
        if (dynamic) this.dynamicMixins = true;
        name += (dynamic ? mixin.name.substr(2, mixin.name.length - 3) : '"' + mixin.name + '"') + "]";
        this.mixins[key] = this.mixins[key] || {
            used: false,
            instances: []
        };
        if (mixin.call) {
            this.mixins[key].used = true;
            if (pp) this.buf.push("pug_indent.push(" + stringify(Array(this.indents + 1).join(pp)) + ");");
            if (block || attrs.length || attrsBlocks.length) {
                this.buf.push(name + ".call({");
                if (block) {
                    this.buf.push("block: function(){");
                    // Render block with no indents, dynamically added when rendered
                    this.parentIndents++;
                    var _indents = this.indents;
                    this.indents = 0;
                    this.visit(mixin.block, mixin);
                    this.indents = _indents;
                    this.parentIndents--;
                    if (attrs.length || attrsBlocks.length) this.buf.push("},");
                    else this.buf.push("}");
                }
                if (attrsBlocks.length) {
                    if (attrs.length) {
                        var val = this.attrs(attrs);
                        attrsBlocks.unshift(val);
                    }
                    if (attrsBlocks.length > 1) this.buf.push("attributes: " + this.runtime("merge") + "([" + attrsBlocks.join(",") + "])");
                    else this.buf.push("attributes: " + attrsBlocks[0]);
                } else if (attrs.length) {
                    var val = this.attrs(attrs);
                    this.buf.push("attributes: " + val);
                }
                if (args) this.buf.push("}, " + args + ");");
                else this.buf.push("});");
            } else this.buf.push(name + "(" + args + ");");
            if (pp) this.buf.push("pug_indent.pop();");
        } else {
            var mixin_start = this.buf.length;
            args = args ? args.split(",") : [];
            var rest;
            if (args.length && /^\.\.\./.test(args[args.length - 1].trim())) rest = args.pop().trim().replace(/^\.\.\./, "");
            // we need use pug_interp here for v8: https://code.google.com/p/v8/issues/detail?id=4165
            // once fixed, use this: this.buf.push(name + ' = function(' + args.join(',') + '){');
            this.buf.push(name + " = pug_interp = function(" + args.join(",") + "){");
            this.buf.push("var block = (this && this.block), attributes = (this && this.attributes) || {};");
            if (rest) {
                this.buf.push("var " + rest + " = [];");
                this.buf.push("for (pug_interp = " + args.length + "; pug_interp < arguments.length; pug_interp++) {");
                this.buf.push("  " + rest + ".push(arguments[pug_interp]);");
                this.buf.push("}");
            }
            this.parentIndents++;
            this.visit(block, mixin);
            this.parentIndents--;
            this.buf.push("};");
            var mixin_end = this.buf.length;
            this.mixins[key].instances.push({
                start: mixin_start,
                end: mixin_end
            });
        }
    },
    /**
   * Visit `tag` buffering tag markup, generating
   * attributes, visiting the `tag`'s code and block.
   *
   * @param {Tag} tag
   * @param {boolean} interpolated
   * @api public
   */ visitTag: function(tag, interpolated) {
        this.indents++;
        var name = tag.name, pp = this.pp, self = this;
        function bufferName() {
            if (interpolated) self.bufferExpression(tag.expr);
            else self.buffer(name);
        }
        if (WHITE_SPACE_SENSITIVE_TAGS[tag.name] === true) this.escapePrettyMode = true;
        if (!this.hasCompiledTag) {
            if (!this.hasCompiledDoctype && "html" == name) this.visitDoctype();
            this.hasCompiledTag = true;
        }
        // pretty print
        if (pp && !tag.isInline) this.prettyIndent(0, true);
        if (tag.selfClosing || !this.xml && selfClosing[tag.name]) {
            this.buffer("<");
            bufferName();
            this.visitAttributes(tag.attrs, this.attributeBlocks(tag.attributeBlocks));
            if (this.terse && !tag.selfClosing) this.buffer(">");
            else this.buffer("/>");
            // if it is non-empty throw an error
            if (tag.code || tag.block && !(tag.block.type === "Block" && tag.block.nodes.length === 0) && tag.block.nodes.some(function(tag) {
                return tag.type !== "Text" || !/^\s*$/.test(tag.val);
            })) this.error(name + " is a self closing element: <" + name + "/> but contains nested content.", "SELF_CLOSING_CONTENT", tag);
        } else {
            // Optimize attributes buffering
            this.buffer("<");
            bufferName();
            this.visitAttributes(tag.attrs, this.attributeBlocks(tag.attributeBlocks));
            this.buffer(">");
            if (tag.code) this.visitCode(tag.code);
            this.visit(tag.block, tag);
            // pretty print
            if (pp && !tag.isInline && WHITE_SPACE_SENSITIVE_TAGS[tag.name] !== true && !tagCanInline(tag)) this.prettyIndent(0, true);
            this.buffer("</");
            bufferName();
            this.buffer(">");
        }
        if (WHITE_SPACE_SENSITIVE_TAGS[tag.name] === true) this.escapePrettyMode = false;
        this.indents--;
    },
    /**
   * Visit InterpolatedTag.
   *
   * @param {InterpolatedTag} tag
   * @api public
   */ visitInterpolatedTag: function(tag) {
        return this.visitTag(tag, true);
    },
    /**
   * Visit `text` node.
   *
   * @param {Text} text
   * @api public
   */ visitText: function(text) {
        this.buffer(text.val);
    },
    /**
   * Visit a `comment`, only buffering when the buffer flag is set.
   *
   * @param {Comment} comment
   * @api public
   */ visitComment: function(comment) {
        if (!comment.buffer) return;
        if (this.pp) this.prettyIndent(1, true);
        this.buffer("<!--" + comment.val + "-->");
    },
    /**
   * Visit a `YieldBlock`.
   *
   * This is necessary since we allow compiling a file with `yield`.
   *
   * @param {YieldBlock} block
   * @api public
   */ visitYieldBlock: function(block) {},
    /**
   * Visit a `BlockComment`.
   *
   * @param {Comment} comment
   * @api public
   */ visitBlockComment: function(comment) {
        if (!comment.buffer) return;
        if (this.pp) this.prettyIndent(1, true);
        this.buffer("<!--" + (comment.val || ""));
        this.visit(comment.block, comment);
        if (this.pp) this.prettyIndent(1, true);
        this.buffer("-->");
    },
    /**
   * Visit `code`, respecting buffer / escape flags.
   * If the code is followed by a block, wrap it in
   * a self-calling function.
   *
   * @param {Code} code
   * @api public
   */ visitCode: function(code) {
        // Wrap code blocks with {}.
        // we only wrap unbuffered code blocks ATM
        // since they are usually flow control
        // Buffer code
        if (code.buffer) {
            var val = code.val.trim();
            val = "null == (pug_interp = " + val + ') ? "" : pug_interp';
            if (code.mustEscape !== false) val = this.runtime("escape") + "(" + val + ")";
            this.bufferExpression(val);
        } else this.buf.push(code.val);
        // Block support
        if (code.block) {
            if (!code.buffer) this.buf.push("{");
            this.visit(code.block, code);
            if (!code.buffer) this.buf.push("}");
        }
    },
    /**
   * Visit `Conditional`.
   *
   * @param {Conditional} cond
   * @api public
   */ visitConditional: function(cond) {
        var test = cond.test;
        this.buf.push("if (" + test + ") {");
        this.visit(cond.consequent, cond);
        this.buf.push("}");
        if (cond.alternate) {
            if (cond.alternate.type === "Conditional") {
                this.buf.push("else");
                this.visitConditional(cond.alternate);
            } else {
                this.buf.push("else {");
                this.visit(cond.alternate, cond);
                this.buf.push("}");
            }
        }
    },
    /**
   * Visit `While`.
   *
   * @param {While} loop
   * @api public
   */ visitWhile: function(loop) {
        var test = loop.test;
        this.buf.push("while (" + test + ") {");
        this.visit(loop.block, loop);
        this.buf.push("}");
    },
    /**
   * Visit `each` block.
   *
   * @param {Each} each
   * @api public
   */ visitEach: function(each) {
        var indexVarName = each.key || "pug_index" + this.eachCount;
        this.eachCount++;
        this.buf.push("// iterate " + each.obj + "\n" + ";(function(){\n" + "  var $$obj = " + each.obj + ";\n" + "  if ('number' == typeof $$obj.length) {");
        if (each.alternate) this.buf.push("    if ($$obj.length) {");
        this.buf.push("      for (var " + indexVarName + " = 0, $$l = $$obj.length; " + indexVarName + " < $$l; " + indexVarName + "++) {\n" + "        var " + each.val + " = $$obj[" + indexVarName + "];");
        this.visit(each.block, each);
        this.buf.push("      }");
        if (each.alternate) {
            this.buf.push("    } else {");
            this.visit(each.alternate, each);
            this.buf.push("    }");
        }
        this.buf.push("  } else {\n    var $$l = 0;\n    for (var " + indexVarName + " in $$obj) {\n" + "      $$l++;\n" + "      var " + each.val + " = $$obj[" + indexVarName + "];");
        this.visit(each.block, each);
        this.buf.push("    }");
        if (each.alternate) {
            this.buf.push("    if ($$l === 0) {");
            this.visit(each.alternate, each);
            this.buf.push("    }");
        }
        this.buf.push("  }\n}).call(this);\n");
    },
    visitEachOf: function(each) {
        this.buf.push("// iterate " + each.obj + "\n" + "for (const " + each.val + " of " + each.obj + ") {\n");
        this.visit(each.block, each);
        this.buf.push("}\n");
    },
    /**
   * Visit `attrs`.
   *
   * @param {Array} attrs
   * @api public
   */ visitAttributes: function(attrs, attributeBlocks) {
        if (attributeBlocks.length) {
            if (attrs.length) {
                var val = this.attrs(attrs);
                attributeBlocks.unshift(val);
            }
            if (attributeBlocks.length > 1) this.bufferExpression(this.runtime("attrs") + "(" + this.runtime("merge") + "([" + attributeBlocks.join(",") + "]), " + stringify(this.terse) + ")");
            else this.bufferExpression(this.runtime("attrs") + "(" + attributeBlocks[0] + ", " + stringify(this.terse) + ")");
        } else if (attrs.length) this.attrs(attrs, true);
    },
    /**
   * Compile attributes.
   */ attrs: function(attrs, buffer) {
        var res = compileAttrs(attrs, {
            terse: this.terse,
            format: buffer ? "html" : "object",
            runtime: this.runtime.bind(this)
        });
        if (buffer) this.bufferExpression(res);
        return res;
    },
    /**
   * Compile attribute blocks.
   */ attributeBlocks: function(attributeBlocks) {
        return attributeBlocks && attributeBlocks.slice().map(function(attrBlock) {
            return attrBlock.val;
        });
    }
};
function tagCanInline(tag) {
    function isInline(node) {
        // Recurse if the node is a block
        if (node.type === "Block") return node.nodes.every(isInline);
        // When there is a YieldBlock here, it is an indication that the file is
        // expected to be included but is not. If this is the case, the block
        // must be empty.
        if (node.type === "YieldBlock") return true;
        return node.type === "Text" && !/\n/.test(node.val) || node.isInline;
    }
    return tag.block.nodes.every(isInline);
}

},{"fb2aed682ecd5f7d":"kP3xq","c99f50b798f53803":"khglH","1b792f8caadde923":"2dEV7","b32352d4cca237e":"bDby4","470934a14ec1ca1f":"vXxDa","57231fecc6b1d3a2":"9oJeI","4c4e15e6aeda5aa5":"hMtKb","63421ee0b9bbacd0":"4OXpP","b9b6f31a930e1607":"rhZf6"}],"kP3xq":[function(require,module,exports) {
"use strict";
module.exports = {
    "html": "<!DOCTYPE html>",
    "xml": '<?xml version="1.0" encoding="utf-8" ?>',
    "transitional": '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
    "strict": '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
    "frameset": '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
    "1.1": '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">',
    "basic": '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">',
    "mobile": '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">',
    "plist": '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">'
};

},{}],"2dEV7":[function(require,module,exports) {
"use strict";
var fs = require("73febb4cfadddb9c");
var dependencies = require("a10358424e7b5905");
var internals = require("b51767903c83db79");
var sources = require("df90d2b2988dc7fb");
module.exports = build;
function build(functions) {
    var fns = [];
    functions = functions.filter(function(fn) {
        return !internals[fn];
    });
    for(var i = 0; i < functions.length; i++)if (fns.indexOf(functions[i]) === -1) {
        fns.push(functions[i]);
        functions.push.apply(functions, dependencies[functions[i]]);
    }
    return fns.sort().map(function(name) {
        return sources[name];
    }).join("\n");
}

},{"73febb4cfadddb9c":"jhUEF","a10358424e7b5905":"6f2E5","b51767903c83db79":"ihRxS","df90d2b2988dc7fb":"fw9ui"}],"6f2E5":[function(require,module,exports) {
module.exports = {
    "has_own_property": [],
    "merge": [
        "style"
    ],
    "classes_array": [
        "classes",
        "escape"
    ],
    "classes_object": [
        "has_own_property"
    ],
    "classes": [
        "classes_array",
        "classes_object"
    ],
    "style": [
        "has_own_property"
    ],
    "attr": [
        "escape"
    ],
    "attrs": [
        "attr",
        "classes",
        "has_own_property",
        "style"
    ],
    "match_html": [],
    "escape": [
        "match_html"
    ],
    "rethrow": []
};

},{}],"ihRxS":[function(require,module,exports) {
module.exports = {
    "dependencies": true,
    "internals": true,
    "has_own_property": true,
    "classes_array": true,
    "classes_object": true,
    "match_html": true
};

},{}],"fw9ui":[function(require,module,exports) {
module.exports = {
    "has_own_property": "var pug_has_own_property=Object.prototype.hasOwnProperty;",
    "merge": 'function pug_merge(e,r){if(1===arguments.length){for(var t=e[0],g=1;g<e.length;g++)t=pug_merge(t,e[g]);return t}for(var l in r)if("class"===l){var n=e[l]||[];e[l]=(Array.isArray(n)?n:[n]).concat(r[l]||[])}else if("style"===l){var n=pug_style(e[l]);n=n&&";"!==n[n.length-1]?n+";":n;var a=pug_style(r[l]);a=a&&";"!==a[a.length-1]?a+";":a,e[l]=n+a}else e[l]=r[l];return e}',
    "classes_array": 'function pug_classes_array(r,a){for(var s,e="",u="",c=Array.isArray(a),g=0;g<r.length;g++)(s=pug_classes(r[g]))&&(c&&a[g]&&(s=pug_escape(s)),e=e+u+s,u=" ");return e}',
    "classes_object": 'function pug_classes_object(r){var a="",n="";for(var o in r)o&&r[o]&&pug_has_own_property.call(r,o)&&(a=a+n+o,n=" ");return a}',
    "classes": 'function pug_classes(s,r){return Array.isArray(s)?pug_classes_array(s,r):s&&"object"==typeof s?pug_classes_object(s):s||""}',
    "style": 'function pug_style(r){if(!r)return"";if("object"==typeof r){var t="";for(var e in r)pug_has_own_property.call(r,e)&&(t=t+e+":"+r[e]+";");return t}return r+""}',
    "attr": 'function pug_attr(t,e,n,r){if(!1===e||null==e||!e&&("class"===t||"style"===t))return"";if(!0===e)return" "+(r?t:t+\'="\'+t+\'"\');var f=typeof e;return"object"!==f&&"function"!==f||"function"!=typeof e.toJSON||(e=e.toJSON()),"string"==typeof e||(e=JSON.stringify(e),n||-1===e.indexOf(\'"\'))?(n&&(e=pug_escape(e))," "+t+\'="\'+e+\'"\'):" "+t+"=\'"+e.replace(/\'/g,"&#39;")+"\'"}',
    "attrs": 'function pug_attrs(t,r){var a="";for(var s in t)if(pug_has_own_property.call(t,s)){var u=t[s];if("class"===s){u=pug_classes(u),a=pug_attr(s,u,!1,r)+a;continue}"style"===s&&(u=pug_style(u)),a+=pug_attr(s,u,!1,r)}return a}',
    "match_html": 'var pug_match_html=/["&<>]/;',
    "escape": 'function pug_escape(e){var a=""+e,t=pug_match_html.exec(a);if(!t)return e;var r,c,n,s="";for(r=t.index,c=0;r<a.length;r++){switch(a.charCodeAt(r)){case 34:n="&quot;";break;case 38:n="&amp;";break;case 60:n="&lt;";break;case 62:n="&gt;";break;default:continue}c!==r&&(s+=a.substring(c,r)),c=r+1,s+=n}return c!==r?s+a.substring(c,r):s}',
    "rethrow": 'function pug_rethrow(e,n,r,t){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||t))throw e.message+=" on line "+r,e;var o,a,i,s;try{t=t||require("fs").readFileSync(n,{encoding:"utf8"}),o=3,a=t.split("\\n"),i=Math.max(r-o,0),s=Math.min(a.length,r+o)}catch(t){return e.message+=" - could not read from "+n+" ("+t.message+")",void pug_rethrow(e,null,r)}o=a.slice(i,s).map(function(e,n){var t=n+i+1;return(t==r?"  > ":"    ")+t+"| "+e}).join("\\n"),e.path=n;try{e.message=(n||"Pug")+":"+r+"\\n"+o+"\\n\\n"+e.message}catch(e){}throw e}'
};

},{}],"bDby4":[function(require,module,exports) {
"use strict";
var pug_has_own_property = Object.prototype.hasOwnProperty;
/**
 * Merge two attribute objects giving precedence
 * to values in object `b`. Classes are special-cased
 * allowing for arrays and merging/joining appropriately
 * resulting in a string.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */ exports.merge = pug_merge;
function pug_merge(a, b) {
    if (arguments.length === 1) {
        var attrs = a[0];
        for(var i = 1; i < a.length; i++)attrs = pug_merge(attrs, a[i]);
        return attrs;
    }
    for(var key in b){
        if (key === "class") {
            var valA = a[key] || [];
            a[key] = (Array.isArray(valA) ? valA : [
                valA
            ]).concat(b[key] || []);
        } else if (key === "style") {
            var valA = pug_style(a[key]);
            valA = valA && valA[valA.length - 1] !== ";" ? valA + ";" : valA;
            var valB = pug_style(b[key]);
            valB = valB && valB[valB.length - 1] !== ";" ? valB + ";" : valB;
            a[key] = valA + valB;
        } else a[key] = b[key];
    }
    return a;
}
/**
 * Process array, object, or string as a string of classes delimited by a space.
 *
 * If `val` is an array, all members of it and its subarrays are counted as
 * classes. If `escaping` is an array, then whether or not the item in `val` is
 * escaped depends on the corresponding item in `escaping`. If `escaping` is
 * not an array, no escaping is done.
 *
 * If `val` is an object, all the keys whose value is truthy are counted as
 * classes. No escaping is done.
 *
 * If `val` is a string, it is counted as a class. No escaping is done.
 *
 * @param {(Array.<string>|Object.<string, boolean>|string)} val
 * @param {?Array.<string>} escaping
 * @return {String}
 */ exports.classes = pug_classes;
function pug_classes_array(val, escaping) {
    var classString = "", className, padding = "", escapeEnabled = Array.isArray(escaping);
    for(var i = 0; i < val.length; i++){
        className = pug_classes(val[i]);
        if (!className) continue;
        escapeEnabled && escaping[i] && (className = pug_escape(className));
        classString = classString + padding + className;
        padding = " ";
    }
    return classString;
}
function pug_classes_object(val) {
    var classString = "", padding = "";
    for(var key in val)if (key && val[key] && pug_has_own_property.call(val, key)) {
        classString = classString + padding + key;
        padding = " ";
    }
    return classString;
}
function pug_classes(val, escaping) {
    if (Array.isArray(val)) return pug_classes_array(val, escaping);
    else if (val && typeof val === "object") return pug_classes_object(val);
    else return val || "";
}
/**
 * Convert object or string to a string of CSS styles delimited by a semicolon.
 *
 * @param {(Object.<string, string>|string)} val
 * @return {String}
 */ exports.style = pug_style;
function pug_style(val) {
    if (!val) return "";
    if (typeof val === "object") {
        var out = "";
        for(var style in val)/* istanbul ignore else */ if (pug_has_own_property.call(val, style)) out = out + style + ":" + val[style] + ";";
        return out;
    } else return val + "";
}
/**
 * Render the given attribute.
 *
 * @param {String} key
 * @param {String} val
 * @param {Boolean} escaped
 * @param {Boolean} terse
 * @return {String}
 */ exports.attr = pug_attr;
function pug_attr(key, val, escaped, terse) {
    if (val === false || val == null || !val && (key === "class" || key === "style")) return "";
    if (val === true) return " " + (terse ? key : key + '="' + key + '"');
    var type = typeof val;
    if ((type === "object" || type === "function") && typeof val.toJSON === "function") val = val.toJSON();
    if (typeof val !== "string") {
        val = JSON.stringify(val);
        if (!escaped && val.indexOf('"') !== -1) return " " + key + "='" + val.replace(/'/g, "&#39;") + "'";
    }
    if (escaped) val = pug_escape(val);
    return " " + key + '="' + val + '"';
}
/**
 * Render the given attributes object.
 *
 * @param {Object} obj
 * @param {Object} terse whether to use HTML5 terse boolean attributes
 * @return {String}
 */ exports.attrs = pug_attrs;
function pug_attrs(obj, terse) {
    var attrs = "";
    for(var key in obj)if (pug_has_own_property.call(obj, key)) {
        var val = obj[key];
        if ("class" === key) {
            val = pug_classes(val);
            attrs = pug_attr(key, val, false, terse) + attrs;
            continue;
        }
        if ("style" === key) val = pug_style(val);
        attrs += pug_attr(key, val, false, terse);
    }
    return attrs;
}
/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */ var pug_match_html = /["&<>]/;
exports.escape = pug_escape;
function pug_escape(_html) {
    var html = "" + _html;
    var regexResult = pug_match_html.exec(html);
    if (!regexResult) return _html;
    var result = "";
    var i, lastIndex, escape;
    for(i = regexResult.index, lastIndex = 0; i < html.length; i++){
        switch(html.charCodeAt(i)){
            case 34:
                escape = "&quot;";
                break;
            case 38:
                escape = "&amp;";
                break;
            case 60:
                escape = "&lt;";
                break;
            case 62:
                escape = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== i) result += html.substring(lastIndex, i);
        lastIndex = i + 1;
        result += escape;
    }
    if (lastIndex !== i) return result + html.substring(lastIndex, i);
    else return result;
}
/**
 * Re-throw the given `err` in context to the
 * the pug in `filename` at the given `lineno`.
 *
 * @param {Error} err
 * @param {String} filename
 * @param {String} lineno
 * @param {String} str original source
 * @api private
 */ exports.rethrow = pug_rethrow;
function pug_rethrow(err, filename, lineno, str) {
    if (!(err instanceof Error)) throw err;
    if ((typeof window != "undefined" || !filename) && !str) {
        err.message += " on line " + lineno;
        throw err;
    }
    var context, lines, start, end;
    try {
        str = str || require("6217591c3915f439").readFileSync(filename, {
            encoding: "utf8"
        });
        context = 3;
        lines = str.split("\n");
        start = Math.max(lineno - context, 0);
        end = Math.min(lines.length, lineno + context);
    } catch (ex) {
        err.message += " - could not read from " + filename + " (" + ex.message + ")";
        pug_rethrow(err, null, lineno);
        return;
    }
    // Error context
    context = lines.slice(start, end).map(function(line, i) {
        var curr = i + start + 1;
        return (curr == lineno ? "  > " : "    ") + curr + "| " + line;
    }).join("\n");
    // Alter exception message
    err.path = filename;
    try {
        err.message = (filename || "Pug") + ":" + lineno + "\n" + context + "\n\n" + err.message;
    } catch (e) {}
    throw err;
}

},{"6217591c3915f439":"jhUEF"}],"vXxDa":[function(require,module,exports) {
"use strict";
var assert = require("1fc9ff3717bce5b");
var constantinople = require("72460b0d0a2115c1");
var runtime = require("ac0d2c661fede73d");
var stringify = require("49e96d394d6879a1");
function isConstant(src) {
    return constantinople(src, {
        pug: runtime,
        pug_interp: undefined
    });
}
function toConstant(src) {
    return constantinople.toConstant(src, {
        pug: runtime,
        pug_interp: undefined
    });
}
module.exports = compileAttrs;
/**
 * options:
 *  - terse
 *  - runtime
 *  - format ('html' || 'object')
 */ function compileAttrs(attrs, options) {
    assert(Array.isArray(attrs), "Attrs should be an array");
    assert(attrs.every(function(attr) {
        return attr && typeof attr === "object" && typeof attr.name === "string" && (typeof attr.val === "string" || typeof attr.val === "boolean") && typeof attr.mustEscape === "boolean";
    }), "All attributes should be supplied as an object of the form {name, val, mustEscape}");
    assert(options && typeof options === "object", "Options should be an object");
    assert(typeof options.terse === "boolean", "Options.terse should be a boolean");
    assert(typeof options.runtime === "function", "Options.runtime should be a function that takes a runtime function name and returns the source code that will evaluate to that function at runtime");
    assert(options.format === "html" || options.format === "object", 'Options.format should be "html" or "object"');
    var buf = [];
    var classes = [];
    var classEscaping = [];
    function addAttribute(key, val, mustEscape, buf) {
        if (isConstant(val)) {
            if (options.format === "html") {
                var str = stringify(runtime.attr(key, toConstant(val), mustEscape, options.terse));
                var last = buf[buf.length - 1];
                if (last && last[last.length - 1] === str[0]) buf[buf.length - 1] = last.substr(0, last.length - 1) + str.substr(1);
                else buf.push(str);
            } else {
                val = toConstant(val);
                if (mustEscape) val = runtime.escape(val);
                buf.push(stringify(key) + ": " + stringify(val));
            }
        } else if (options.format === "html") buf.push(options.runtime("attr") + '("' + key + '", ' + val + ", " + stringify(mustEscape) + ", " + stringify(options.terse) + ")");
        else {
            if (mustEscape) val = options.runtime("escape") + "(" + val + ")";
            buf.push(stringify(key) + ": " + val);
        }
    }
    attrs.forEach(function(attr) {
        var key = attr.name;
        var val = attr.val;
        var mustEscape = attr.mustEscape;
        if (key === "class") {
            classes.push(val);
            classEscaping.push(mustEscape);
        } else {
            if (key === "style") {
                if (isConstant(val)) val = stringify(runtime.style(toConstant(val)));
                else val = options.runtime("style") + "(" + val + ")";
            }
            addAttribute(key, val, mustEscape, buf);
        }
    });
    var classesBuf = [];
    if (classes.length) {
        if (classes.every(isConstant)) addAttribute("class", stringify(runtime.classes(classes.map(toConstant), classEscaping)), false, classesBuf);
        else {
            classes = classes.map(function(cls, i) {
                if (isConstant(cls)) {
                    cls = stringify(classEscaping[i] ? runtime.escape(toConstant(cls)) : toConstant(cls));
                    classEscaping[i] = false;
                }
                return cls;
            });
            addAttribute("class", options.runtime("classes") + "([" + classes.join(",") + "], " + stringify(classEscaping) + ")", false, classesBuf);
        }
    }
    buf = classesBuf.concat(buf);
    if (options.format === "html") return buf.length ? buf.join("+") : '""';
    else return "{" + buf.join(",") + "}";
}

},{"1fc9ff3717bce5b":"f3tT4","72460b0d0a2115c1":"hMtKb","ac0d2c661fede73d":"bDby4","49e96d394d6879a1":"4OXpP"}],"4OXpP":[function(require,module,exports) {
"use strict";
module.exports = stringify;
function stringify(obj) {
    if (obj instanceof Date) return "new Date(" + stringify(obj.toISOString()) + ")";
    if (obj === undefined) return "undefined";
    return JSON.stringify(obj).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/</g, "\\u003C").replace(/>/g, "\\u003E").replace(/\//g, "\\u002F");
}

},{}],"9oJeI":[function(require,module,exports) {
/**
 * This file automatically generated from `pre-publish.js`.
 * Do not manually edit.
 */ module.exports = {
    "area": true,
    "base": true,
    "br": true,
    "col": true,
    "embed": true,
    "hr": true,
    "img": true,
    "input": true,
    "link": true,
    "meta": true,
    "param": true,
    "source": true,
    "track": true,
    "wbr": true
};

},{}],"rhZf6":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const parser_1 = require("cbbdf95349e5ef45");
const babel_walk_1 = require("4de3546740491534");
const t = __importStar(require("5c6b77d353a677b5"));
const globals_1 = __importDefault(require("d82b550c13e5099"));
const parseOptions = {
    allowReturnOutsideFunction: true,
    allowImportExportEverywhere: true
};
/**
 * Mimic `with` as far as possible but at compile time
 *
 * @param obj The object part of a with expression
 * @param src The body of the with expression
 * @param exclude A list of variable names to explicitly exclude
 */ function addWith(obj, src, exclude = []) {
    // tslint:disable-next-line: no-parameter-reassignment
    obj = obj + "";
    // tslint:disable-next-line: no-parameter-reassignment
    src = src + "";
    let ast;
    try {
        ast = parser_1.parse(src, parseOptions);
    } catch (e) {
        throw Object.assign(new Error("Error parsing body of the with expression"), {
            component: "src",
            babylonError: e
        });
    }
    let objAst;
    try {
        objAst = parser_1.parse(obj, parseOptions);
    } catch (e) {
        throw Object.assign(new Error("Error parsing object part of the with expression"), {
            component: "obj",
            babylonError: e
        });
    }
    const excludeSet = new Set([
        "undefined",
        "this",
        ...exclude,
        ...globals_1.default(objAst).map((g)=>g.name)
    ]);
    const vars = new Set(globals_1.default(ast).map((global)=>global.name).filter((v)=>!excludeSet.has(v)));
    if (vars.size === 0) return src;
    let declareLocal = "";
    let local = "locals_for_with";
    let result = "result_of_with";
    if (t.isValidIdentifier(obj)) local = obj;
    else {
        while(vars.has(local) || excludeSet.has(local))local += "_";
        declareLocal = `var ${local} = (${obj});`;
    }
    while(vars.has(result) || excludeSet.has(result))result += "_";
    const args = [
        "this",
        ...Array.from(vars).map((v)=>`${JSON.stringify(v)} in ${local} ?
        ${local}.${v} :
        typeof ${v} !== 'undefined' ? ${v} : undefined`)
    ];
    const unwrapped = unwrapReturns(ast, src, result);
    return `;
    ${declareLocal}
    ${unwrapped.before}
    (function (${Array.from(vars).join(", ")}) {
      ${unwrapped.body}
    }.call(${args.join(", ")}));
    ${unwrapped.after};`;
}
exports.default = addWith;
const unwrapReturnsVisitors = babel_walk_1.recursive({
    Function (_node, _state, _c) {
    // returns in these functions are not applicable
    },
    ReturnStatement (node, state) {
        state.hasReturn = true;
        let value = "";
        if (node.argument) value = `value: (${state.source(node.argument)})`;
        state.replace(node, `return {${value}};`);
    }
});
/**
 * Take a self calling function, and unwrap it such that return inside the function
 * results in return outside the function
 *
 * @param src    Some JavaScript code representing a self-calling function
 * @param result A temporary variable to store the result in
 */ function unwrapReturns(ast, src, result) {
    const charArray = src.split("");
    const state = {
        hasReturn: false,
        source (node) {
            return src.slice(node.start, node.end);
        },
        replace (node, str) {
            charArray.fill("", node.start, node.end);
            charArray[node.start] = str;
        }
    };
    unwrapReturnsVisitors(ast, state);
    return {
        before: state.hasReturn ? `var ${result} = ` : "",
        body: charArray.join(""),
        after: state.hasReturn ? `;if (${result}) return ${result}.value` : ""
    };
}
module.exports = addWith;
module.exports.default = addWith;

},{"cbbdf95349e5ef45":"j1WdR","4de3546740491534":"02ubw","5c6b77d353a677b5":"hnm3y","d82b550c13e5099":"elUbM"}],"02ubw":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.recursive = exports.ancestor = exports.simple = void 0;
const t = __importStar(require("7122d60f73e0221e"));
const explode_1 = __importDefault(require("b758bca2a2f590c5"));
const VISITOR_KEYS = t.VISITOR_KEYS;
if (!(VISITOR_KEYS && // tslint:disable-next-line: strict-type-predicates
typeof VISITOR_KEYS === "object" && Object.keys(VISITOR_KEYS).every((key)=>Array.isArray(VISITOR_KEYS[key]) && // tslint:disable-next-line: strict-type-predicates
    VISITOR_KEYS[key].every((v)=>typeof v === "string")))) throw new Error("@babel/types VISITOR_KEYS does not match the expected type.");
function simple(visitors) {
    const vis = explode_1.default(visitors);
    return (node, state)=>{
        (function recurse(node) {
            if (!node) return;
            const visitor = vis[node.type];
            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) for (const v of visitor.enter)v(node, state);
            for (const key of VISITOR_KEYS[node.type] || []){
                const subNode = node[key];
                if (Array.isArray(subNode)) for (const subSubNode of subNode)recurse(subSubNode);
                else recurse(subNode);
            }
            if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) for (const v of visitor.exit)v(node, state);
        })(node);
    };
}
exports.simple = simple;
function ancestor(visitors) {
    const vis = explode_1.default(visitors);
    return (node, state)=>{
        const ancestors = [];
        (function recurse(node) {
            if (!node) return;
            const visitor = vis[node.type];
            const isNew = node !== ancestors[ancestors.length - 1];
            if (isNew) ancestors.push(node);
            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) for (const v of visitor.enter)v(node, state, ancestors);
            for (const key of VISITOR_KEYS[node.type] || []){
                const subNode = node[key];
                if (Array.isArray(subNode)) for (const subSubNode of subNode)recurse(subSubNode);
                else recurse(subNode);
            }
            if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) for (const v of visitor.exit)v(node, state, ancestors);
            if (isNew) ancestors.pop();
        })(node);
    };
}
exports.ancestor = ancestor;
function recursive(visitors) {
    const vis = explode_1.default(visitors);
    return (node, state)=>{
        (function recurse(node) {
            if (!node) return;
            const visitor = vis[node.type];
            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) for (const v of visitor.enter)v(node, state, recurse);
            else for (const key of VISITOR_KEYS[node.type] || []){
                const subNode = node[key];
                if (Array.isArray(subNode)) for (const subSubNode of subNode)recurse(subSubNode);
                else recurse(subNode);
            }
        })(node);
    };
}
exports.recursive = recursive;

},{"7122d60f73e0221e":"hnm3y","b758bca2a2f590c5":"dlUaM"}],"dlUaM":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const t = __importStar(require("d11ff2ebb65fcb52"));
if (!(Array.isArray(t.TYPES) && t.TYPES.every((t)=>typeof t === "string"))) throw new Error("@babel/types TYPES does not match the expected type.");
const FLIPPED_ALIAS_KEYS = t.FLIPPED_ALIAS_KEYS;
const TYPES = new Set(t.TYPES);
if (!(FLIPPED_ALIAS_KEYS && // tslint:disable-next-line: strict-type-predicates
typeof FLIPPED_ALIAS_KEYS === "object" && Object.keys(FLIPPED_ALIAS_KEYS).every((key)=>Array.isArray(FLIPPED_ALIAS_KEYS[key]) && // tslint:disable-next-line: strict-type-predicates
    FLIPPED_ALIAS_KEYS[key].every((v)=>typeof v === "string")))) throw new Error("@babel/types FLIPPED_ALIAS_KEYS does not match the expected type.");
/**
 * This serves thre functions:
 *
 * 1. Take any "aliases" and explode them to refecence the concrete types
 * 2. Normalize all handlers to have an `{enter, exit}` pair, rather than raw functions
 * 3. make the enter and exit handlers arrays, so that multiple handlers can be merged
 */ function explode(input) {
    const results = {};
    for(const key in input){
        const aliases = FLIPPED_ALIAS_KEYS[key];
        if (aliases) for (const concreteKey of aliases){
            if (concreteKey in results) {
                if (typeof input[key] === "function") results[concreteKey].enter.push(input[key]);
                else {
                    if (input[key].enter) results[concreteKey].enter.push(input[key].enter);
                    if (input[key].exit) results[concreteKey].exit.push(input[key].exit);
                }
            } else if (typeof input[key] === "function") results[concreteKey] = {
                enter: [
                    input[key]
                ],
                exit: []
            };
            else results[concreteKey] = {
                enter: input[key].enter ? [
                    input[key].enter
                ] : [],
                exit: input[key].exit ? [
                    input[key].exit
                ] : []
            };
        }
        else if (TYPES.has(key)) {
            if (key in results) {
                if (typeof input[key] === "function") results[key].enter.push(input[key]);
                else {
                    if (input[key].enter) results[key].enter.push(input[key].enter);
                    if (input[key].exit) results[key].exit.push(input[key].exit);
                }
            } else if (typeof input[key] === "function") results[key] = {
                enter: [
                    input[key]
                ],
                exit: []
            };
            else results[key] = {
                enter: input[key].enter ? [
                    input[key].enter
                ] : [],
                exit: input[key].exit ? [
                    input[key].exit
                ] : []
            };
        }
    }
    return results;
}
exports.default = explode;

},{"d11ff2ebb65fcb52":"hnm3y"}],"elUbM":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const assert_never_1 = __importDefault(require("c54b0a4d88a81c77"));
const babel_walk_1 = require("5b750493b8ad46ae");
const t = __importStar(require("550e1803451602ea"));
const reference_1 = __importDefault(require("d769cefcb84111a2"));
const isScope = (node)=>t.isFunctionParent(node) || t.isProgram(node);
const isBlockScope = (node)=>t.isBlockStatement(node) || isScope(node);
const declaresArguments = (node)=>t.isFunction(node) && !t.isArrowFunctionExpression(node);
const declaresThis = declaresArguments;
const LOCALS_SYMBOL = Symbol("locals");
const getLocals = (node)=>node[LOCALS_SYMBOL];
const declareLocals = (node)=>node[LOCALS_SYMBOL] = node[LOCALS_SYMBOL] || new Set();
const setLocal = (node, name)=>declareLocals(node).add(name);
// First pass
function declareFunction(node) {
    for (const param of node.params)declarePattern(param, node);
    const id = node.id;
    if (id) setLocal(node, id.name);
}
function declarePattern(node, parent) {
    switch(node.type){
        case "Identifier":
            setLocal(parent, node.name);
            break;
        case "ObjectPattern":
            for (const prop of node.properties)switch(prop.type){
                case "RestElement":
                    declarePattern(prop.argument, parent);
                    break;
                case "ObjectProperty":
                    declarePattern(prop.value, parent);
                    break;
                default:
                    assert_never_1.default(prop);
                    break;
            }
            break;
        case "ArrayPattern":
            for (const element of node.elements)if (element) declarePattern(element, parent);
            break;
        case "RestElement":
            declarePattern(node.argument, parent);
            break;
        case "AssignmentPattern":
            declarePattern(node.left, parent);
            break;
        // istanbul ignore next
        default:
            throw new Error("Unrecognized pattern type: " + node.type);
    }
}
function declareModuleSpecifier(node, _state, parents) {
    for(let i = parents.length - 2; i >= 0; i--)if (isScope(parents[i])) {
        setLocal(parents[i], node.local.name);
        return;
    }
}
const firstPass = babel_walk_1.ancestor({
    VariableDeclaration (node, _state, parents) {
        for(let i = parents.length - 2; i >= 0; i--)if (node.kind === "var" ? t.isFunctionParent(parents[i]) : isBlockScope(parents[i])) {
            for (const declaration of node.declarations)declarePattern(declaration.id, parents[i]);
            return;
        }
    },
    FunctionDeclaration (node, _state, parents) {
        if (node.id) {
            for(let i = parents.length - 2; i >= 0; i--)if (isScope(parents[i])) {
                setLocal(parents[i], node.id.name);
                return;
            }
        }
    },
    Function: declareFunction,
    ClassDeclaration (node, _state, parents) {
        for(let i = parents.length - 2; i >= 0; i--)if (isScope(parents[i])) {
            setLocal(parents[i], node.id.name);
            return;
        }
    },
    TryStatement (node) {
        if (node.handler === null) return;
        if (node.handler.param === null) return;
        declarePattern(node.handler.param, node.handler);
    },
    ImportDefaultSpecifier: declareModuleSpecifier,
    ImportSpecifier: declareModuleSpecifier,
    ImportNamespaceSpecifier: declareModuleSpecifier
});
// Second pass
const secondPass = babel_walk_1.ancestor({
    Identifier (node, state, parents) {
        var _a;
        const name = node.name;
        if (name === "undefined") return;
        const lastParent = parents[parents.length - 2];
        if (lastParent) {
            if (!reference_1.default(node, lastParent)) return;
            for (const parent of parents){
                if (name === "arguments" && declaresArguments(parent)) return;
                if ((_a = getLocals(parent)) === null || _a === void 0 ? void 0 : _a.has(name)) return;
            }
        }
        state.globals.push(node);
    },
    ThisExpression (node, state, parents) {
        for (const parent of parents){
            if (declaresThis(parent)) return;
        }
        state.globals.push(node);
    }
});
function findGlobals(ast) {
    const globals = [];
    // istanbul ignore if
    if (!t.isNode(ast)) throw new TypeError("Source must be a Babylon AST");
    firstPass(ast, undefined);
    secondPass(ast, {
        globals
    });
    const groupedGlobals = new Map();
    for (const node of globals){
        const name = node.type === "ThisExpression" ? "this" : node.name;
        const existing = groupedGlobals.get(name);
        if (existing) existing.push(node);
        else groupedGlobals.set(name, [
            node
        ]);
    }
    return [
        ...groupedGlobals
    ].map(([name, nodes])=>({
            name,
            nodes
        })).sort((a, b)=>a.name < b.name ? -1 : 1);
}
exports.default = findGlobals;

},{"c54b0a4d88a81c77":"30dQU","5b750493b8ad46ae":"02ubw","550e1803451602ea":"hnm3y","d769cefcb84111a2":"dJqj8"}],"30dQU":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Helper function for exhaustive checks of discriminated unions.
 * https://basarat.gitbooks.io/typescript/docs/types/discriminated-unions.html
 *
 * @example
 *
 *    type A = {type: 'a'};
 *    type B = {type: 'b'};
 *    type Union = A | B;
 *
 *    function doSomething(arg: Union) {
 *      if (arg.type === 'a') {
 *        return something;
 *      }
 *
 *      if (arg.type === 'b') {
 *        return somethingElse;
 *      }
 *
 *      // TS will error if there are other types in the union
 *      // Will throw an Error when called at runtime.
 *      // Use `assertNever(arg, true)` instead to fail silently.
 *      return assertNever(arg);
 *    }
 */ function assertNever(value, noThrow) {
    if (noThrow) return value;
    throw new Error("Unhandled discriminated union member: " + JSON.stringify(value));
}
exports.assertNever = assertNever;
exports.default = assertNever;

},{}],"dJqj8":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const t = __importStar(require("bd45485ededdde9e"));
function isReferenced(node, parent) {
    switch(parent.type){
        // yes: { [NODE]: '' }
        // yes: { NODE }
        // no: { NODE: '' }
        case "ObjectProperty":
            return parent.value === node || parent.computed;
        // no: break NODE;
        // no: continue NODE;
        case "BreakStatement":
        case "ContinueStatement":
            return false;
        // yes: left = NODE;
        // yes: NODE = right;
        case "AssignmentExpression":
            return true;
    }
    return t.isReferenced(node, parent);
}
exports.default = isReferenced;

},{"bd45485ededdde9e":"hnm3y"}],"6dUxV":[function(require,module,exports) {
var runtime = require("fa31efec18599987");
module.exports = wrap;
function wrap(template, templateName) {
    templateName = templateName || "template";
    return Function("pug", template + "\n" + "return " + templateName + ";")(runtime);
}

},{"fa31efec18599987":"bDby4"}]},["gAoaA","6rimH"], "6rimH", "parcelRequiref458")

//# sourceMappingURL=index.8cfc62b9.js.map
